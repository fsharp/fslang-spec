
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
        <link rel="canonical" href="https://fsharp.github.io/fslang-spec/type-definitions/">
      
      
        <link rel="prev" href="../patterns/">
      
      
        <link rel="next" href="../units-of-measure/">
      
      
      <link rel="icon" href="../fsharp128.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.6.22">
    
    
      
        <title>8. Type Definitions - F# Language Specification</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.84d31ad4.min.css">
      
        
        <link rel="stylesheet" href="../assets/stylesheets/palette.06af60db.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    
    
      
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="indigo" data-md-color-accent="indigo">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#8-type-definitions" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="F# Language Specification" class="md-header__button md-logo" aria-label="F# Language Specification" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M0 12 11.39.61v5.695L5.695 12l5.695 5.695v5.695zm7.322 0 4.068-4.068v8.136zM24 12 12.203.61v5.695L17.898 12l-5.695 5.695v5.695z"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            F# Language Specification
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              8. Type Definitions
            
          </span>
        </div>
      </div>
    </div>
    
      
        <form class="md-header__option" data-md-component="palette">
  
    
    
    
    <input class="md-option" data-md-color-media="(prefers-color-scheme)" data-md-color-scheme="default" data-md-color-primary="indigo" data-md-color-accent="indigo"  aria-label="Switch to light mode"  type="radio" name="__palette" id="__palette_0">
    
      <label class="md-header__button md-icon" title="Switch to light mode" for="__palette_1" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="m14.3 16-.7-2h-3.2l-.7 2H7.8L11 7h2l3.2 9zM20 8.69V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12zm-9.15 3.96h2.3L12 9z"/></svg>
      </label>
    
  
    
    
    
    <input class="md-option" data-md-color-media="(prefers-color-scheme: light)" data-md-color-scheme="default" data-md-color-primary="indigo" data-md-color-accent="indigo"  aria-label="Switch to dark mode"  type="radio" name="__palette" id="__palette_1">
    
      <label class="md-header__button md-icon" title="Switch to dark mode" for="__palette_2" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a4 4 0 0 0-4 4 4 4 0 0 0 4 4 4 4 0 0 0 4-4 4 4 0 0 0-4-4m0 10a6 6 0 0 1-6-6 6 6 0 0 1 6-6 6 6 0 0 1 6 6 6 6 0 0 1-6 6m8-9.31V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12z"/></svg>
      </label>
    
  
    
    
    
    <input class="md-option" data-md-color-media="(prefers-color-scheme: dark)" data-md-color-scheme="slate" data-md-color-primary="indigo" data-md-color-accent="indigo"  aria-label="Switch to system preference"  type="radio" name="__palette" id="__palette_2">
    
      <label class="md-header__button md-icon" title="Switch to system preference" for="__palette_0" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 18c-.89 0-1.74-.2-2.5-.55C11.56 16.5 13 14.42 13 12s-1.44-4.5-3.5-5.45C10.26 6.2 11.11 6 12 6a6 6 0 0 1 6 6 6 6 0 0 1-6 6m8-9.31V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12z"/></svg>
      </label>
    
  
</form>
      
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      
      
        <label class="md-header__button md-icon" for="__search">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        </label>
        <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
      
    
    
      <div class="md-header__source">
        <a href="https://github.com/fsharp/fslang-spec" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 7.1.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2025 Fonticons, Inc.--><path d="M439.6 236.1 244 40.5c-5.4-5.5-12.8-8.5-20.4-8.5s-15 3-20.4 8.4L162.5 81l51.5 51.5c27.1-9.1 52.7 16.8 43.4 43.7l49.7 49.7c34.2-11.8 61.2 31 35.5 56.7-26.5 26.5-70.2-2.9-56-37.3L240.3 199v121.9c25.3 12.5 22.3 41.8 9.1 55-6.4 6.4-15.2 10.1-24.3 10.1s-17.8-3.6-24.3-10.1c-17.6-17.6-11.1-46.9 11.2-56v-123c-20.8-8.5-24.6-30.7-18.6-45L142.6 101 8.5 235.1C3 240.6 0 247.9 0 255.5s3 15 8.5 20.4l195.6 195.7c5.4 5.4 12.7 8.4 20.4 8.4s15-3 20.4-8.4l194.7-194.7c5.4-5.4 8.4-12.8 8.4-20.4s-3-15-8.4-20.4"/></svg>
  </div>
  <div class="md-source__repository">
    GitHub
  </div>
</a>
      </div>
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="F# Language Specification" class="md-nav__button md-logo" aria-label="F# Language Specification" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M0 12 11.39.61v5.695L5.695 12l5.695 5.695v5.695zm7.322 0 4.068-4.068v8.136zM24 12 12.203.61v5.695L17.898 12l-5.695 5.695v5.695z"/></svg>

    </a>
    F# Language Specification
  </label>
  
    <div class="md-nav__source">
      <a href="https://github.com/fsharp/fslang-spec" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 7.1.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2025 Fonticons, Inc.--><path d="M439.6 236.1 244 40.5c-5.4-5.5-12.8-8.5-20.4-8.5s-15 3-20.4 8.4L162.5 81l51.5 51.5c27.1-9.1 52.7 16.8 43.4 43.7l49.7 49.7c34.2-11.8 61.2 31 35.5 56.7-26.5 26.5-70.2-2.9-56-37.3L240.3 199v121.9c25.3 12.5 22.3 41.8 9.1 55-6.4 6.4-15.2 10.1-24.3 10.1s-17.8-3.6-24.3-10.1c-17.6-17.6-11.1-46.9 11.2-56v-123c-20.8-8.5-24.6-30.7-18.6-45L142.6 101 8.5 235.1C3 240.6 0 247.9 0 255.5s3 15 8.5 20.4l195.6 195.7c5.4 5.4 12.7 8.4 20.4 8.4s15-3 20.4-8.4l194.7-194.7c5.4-5.4 8.4-12.8 8.4-20.4s-3-15-8.4-20.4"/></svg>
  </div>
  <div class="md-source__repository">
    GitHub
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Front Matter
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../rfc-status/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    RFC status
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../introduction/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    1. Introduction
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../program-structure/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    2. Program Structure
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../lexical-analysis/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    3. Lexical Analysis
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../basic-grammar-elements/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    4. Basic Grammar Elements
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../types-and-type-constraints/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    5. Types and Type Constraints
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../expressions/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    6. Expressions
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../patterns/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    7. Patterns
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  
  <span class="md-ellipsis">
    8. Type Definitions
    
  </span>
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        
  
  
  <span class="md-ellipsis">
    8. Type Definitions
    
  </span>
  

      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#81-type-definition-group-checking-and-elaboration" class="md-nav__link">
    <span class="md-ellipsis">
      8.1 Type Definition Group Checking and Elaboration
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#82-type-kind-inference" class="md-nav__link">
    <span class="md-ellipsis">
      8.2 Type Kind Inference
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#83-type-abbreviations" class="md-nav__link">
    <span class="md-ellipsis">
      8.3 Type Abbreviations
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#84-record-type-definitions" class="md-nav__link">
    <span class="md-ellipsis">
      8.4 Record Type Definitions
    </span>
  </a>
  
    <nav class="md-nav" aria-label="8.4 Record Type Definitions">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#841-members-in-record-types" class="md-nav__link">
    <span class="md-ellipsis">
      8.4.1 Members in Record Types
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#842-name-resolution-and-record-field-labels" class="md-nav__link">
    <span class="md-ellipsis">
      8.4.2 Name Resolution and Record Field Labels
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#843-structural-hashing-equality-and-comparison-for-record-types" class="md-nav__link">
    <span class="md-ellipsis">
      8.4.3 Structural Hashing, Equality, and Comparison for Record Types
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#844-withend-in-record-type-definitions" class="md-nav__link">
    <span class="md-ellipsis">
      8.4.4 With/End in Record Type Definitions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#845-climutable-attributes" class="md-nav__link">
    <span class="md-ellipsis">
      8.4.5 CLIMutable Attributes
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#85-union-type-definitions" class="md-nav__link">
    <span class="md-ellipsis">
      8.5 Union Type Definitions
    </span>
  </a>
  
    <nav class="md-nav" aria-label="8.5 Union Type Definitions">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#851-members-in-union-types" class="md-nav__link">
    <span class="md-ellipsis">
      8.5.1 Members in Union Types
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#852-structural-hashing-equality-and-comparison-for-union-types" class="md-nav__link">
    <span class="md-ellipsis">
      8.5.2 Structural Hashing, Equality, and Comparison for Union Types
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#853-withend-in-union-type-definitions" class="md-nav__link">
    <span class="md-ellipsis">
      8.5.3 With/End in Union Type Definitions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#854-compiled-form-of-union-types-for-use-from-other-cli-languages" class="md-nav__link">
    <span class="md-ellipsis">
      8.5.4 Compiled Form of Union Types for Use from Other CLI Languages
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#86-class-type-definitions" class="md-nav__link">
    <span class="md-ellipsis">
      8.6 Class Type Definitions
    </span>
  </a>
  
    <nav class="md-nav" aria-label="8.6 Class Type Definitions">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#861-primary-constructors-in-classes" class="md-nav__link">
    <span class="md-ellipsis">
      8.6.1 Primary Constructors in Classes
    </span>
  </a>
  
    <nav class="md-nav" aria-label="8.6.1 Primary Constructors in Classes">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#8611-object-references-in-primary-constructors" class="md-nav__link">
    <span class="md-ellipsis">
      8.6.1.1 Object References in Primary Constructors
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#8612-inheritance-declarations-in-primary-constructors" class="md-nav__link">
    <span class="md-ellipsis">
      8.6.1.2 Inheritance Declarations in Primary Constructors
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#8613-instance-function-and-value-definitions-in-primary-constructors" class="md-nav__link">
    <span class="md-ellipsis">
      8.6.1.3 Instance Function and Value Definitions in Primary Constructors
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#8614-static-function-and-value-definitions-in-primary-constructors" class="md-nav__link">
    <span class="md-ellipsis">
      8.6.1.4 Static Function and Value Definitions in Primary Constructors
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#862-members-in-classes" class="md-nav__link">
    <span class="md-ellipsis">
      8.6.2 Members in Classes
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#863-additional-object-constructors-in-classes" class="md-nav__link">
    <span class="md-ellipsis">
      8.6.3 Additional Object Constructors in Classes
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#864-additional-fields-in-classes" class="md-nav__link">
    <span class="md-ellipsis">
      8.6.4 Additional Fields in Classes
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#87-interface-type-definitions" class="md-nav__link">
    <span class="md-ellipsis">
      8.7 Interface Type Definitions
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#88-struct-type-definitions" class="md-nav__link">
    <span class="md-ellipsis">
      8.8 Struct Type Definitions
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#89-enum-type-definitions" class="md-nav__link">
    <span class="md-ellipsis">
      8.9 Enum Type Definitions
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#810-delegate-type-definitions" class="md-nav__link">
    <span class="md-ellipsis">
      8.10 Delegate Type Definitions
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#811-exception-definitions" class="md-nav__link">
    <span class="md-ellipsis">
      8.11 Exception Definitions
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#812-type-extensions" class="md-nav__link">
    <span class="md-ellipsis">
      8.12 Type Extensions
    </span>
  </a>
  
    <nav class="md-nav" aria-label="8.12 Type Extensions">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#8121-imported-cli-c-extensions-members" class="md-nav__link">
    <span class="md-ellipsis">
      8.12.1 Imported CLI C# Extensions Members
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#813-members" class="md-nav__link">
    <span class="md-ellipsis">
      8.13 Members
    </span>
  </a>
  
    <nav class="md-nav" aria-label="8.13 Members">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#8131-property-members" class="md-nav__link">
    <span class="md-ellipsis">
      8.13.1 Property Members
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#8132-auto-implemented-properties" class="md-nav__link">
    <span class="md-ellipsis">
      8.13.2 Auto-implemented Properties
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#8133-method-members" class="md-nav__link">
    <span class="md-ellipsis">
      8.13.3 Method Members
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#8134-curried-method-members" class="md-nav__link">
    <span class="md-ellipsis">
      8.13.4 Curried Method Members
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#8135-named-arguments-to-method-members" class="md-nav__link">
    <span class="md-ellipsis">
      8.13.5 Named Arguments to Method Members
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#8136-optional-arguments-to-method-members" class="md-nav__link">
    <span class="md-ellipsis">
      8.13.6 Optional Arguments to Method Members
    </span>
  </a>
  
    <nav class="md-nav" aria-label="8.13.6 Optional Arguments to Method Members">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#81361-f-style-optional-arguments" class="md-nav__link">
    <span class="md-ellipsis">
      8.13.6.1 F#-Style Optional Arguments
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#81362-cli-compatible-optional-arguments" class="md-nav__link">
    <span class="md-ellipsis">
      8.13.6.2 CLI-Compatible Optional Arguments
    </span>
  </a>
  
    <nav class="md-nav" aria-label="8.13.6.2 CLI-Compatible Optional Arguments">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#813621-allowable-default-values" class="md-nav__link">
    <span class="md-ellipsis">
      8.13.6.2.1 Allowable Default Values
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#813622-usage-and-considerations" class="md-nav__link">
    <span class="md-ellipsis">
      8.13.6.2.2 Usage and Considerations
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#8137-type-directed-conversions-at-member-invocations" class="md-nav__link">
    <span class="md-ellipsis">
      8.13.7 Type-directed Conversions at Member Invocations
    </span>
  </a>
  
    <nav class="md-nav" aria-label="8.13.7 Type-directed Conversions at Member Invocations">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#81371-conversion-to-delegates" class="md-nav__link">
    <span class="md-ellipsis">
      8.13.7.1 Conversion to Delegates
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#81372-conversion-to-reference-cells" class="md-nav__link">
    <span class="md-ellipsis">
      8.13.7.2 Conversion to Reference Cells
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#81373-conversion-to-quotation-values" class="md-nav__link">
    <span class="md-ellipsis">
      8.13.7.3 Conversion to Quotation Values
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#81374-conversion-to-linq-expressions" class="md-nav__link">
    <span class="md-ellipsis">
      8.13.7.4 Conversion to LINQ Expressions
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#8138-overloading-of-methods" class="md-nav__link">
    <span class="md-ellipsis">
      8.13.8 Overloading of Methods
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#8139-naming-restrictions-for-members" class="md-nav__link">
    <span class="md-ellipsis">
      8.13.9 Naming Restrictions for Members
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#81310-members-represented-as-events" class="md-nav__link">
    <span class="md-ellipsis">
      8.13.10 Members Represented as Events
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#81311-members-represented-as-static-members" class="md-nav__link">
    <span class="md-ellipsis">
      8.13.11 Members Represented as Static Members
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#814-abstract-members-and-interface-implementations" class="md-nav__link">
    <span class="md-ellipsis">
      8.14 Abstract Members and Interface Implementations
    </span>
  </a>
  
    <nav class="md-nav" aria-label="8.14 Abstract Members and Interface Implementations">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#8141-abstract-members" class="md-nav__link">
    <span class="md-ellipsis">
      8.14.1 Abstract Members
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#8142-members-that-implement-abstract-members" class="md-nav__link">
    <span class="md-ellipsis">
      8.14.2 Members that Implement Abstract Members
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#8143-interface-implementations" class="md-nav__link">
    <span class="md-ellipsis">
      8.14.3 Interface Implementations
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#815-equality-hashing-and-comparison" class="md-nav__link">
    <span class="md-ellipsis">
      8.15 Equality, Hashing, and Comparison
    </span>
  </a>
  
    <nav class="md-nav" aria-label="8.15 Equality, Hashing, and Comparison">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#8151-equality-attributes" class="md-nav__link">
    <span class="md-ellipsis">
      8.15.1 Equality Attributes
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#8152-comparison-attributes" class="md-nav__link">
    <span class="md-ellipsis">
      8.15.2 Comparison Attributes
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#8153-behavior-of-the-generated-objectequals-implementation" class="md-nav__link">
    <span class="md-ellipsis">
      8.15.3 Behavior of the Generated Object.Equals Implementation
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#8154-behavior-of-the-generated-compareto-implementations" class="md-nav__link">
    <span class="md-ellipsis">
      8.15.4 Behavior of the Generated CompareTo Implementations
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#8155-behavior-of-the-generated-gethashcode-implementations" class="md-nav__link">
    <span class="md-ellipsis">
      8.15.5 Behavior of the Generated GetHashCode Implementations
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#8156-behavior-of-hash-and-compare" class="md-nav__link">
    <span class="md-ellipsis">
      8.15.6 Behavior of Hash, =, and Compare
    </span>
  </a>
  
    <nav class="md-nav" aria-label="8.15.6 Behavior of Hash, =, and Compare">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#81561-pseudocode-for-fsharpcoreoperatorscompare" class="md-nav__link">
    <span class="md-ellipsis">
      8.15.6.1 Pseudocode for FSharp.Core.Operators.compare
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#81562-pseudo-code-for-fsharpcoreoperators" class="md-nav__link">
    <span class="md-ellipsis">
      8.15.6.2 Pseudo code for FSharp.Core.Operators.(=)
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../units-of-measure/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    9. Units of Measure
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../namespaces-and-modules/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    10. Namespaces and Modules
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../namespace-and-module-signatures/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    11. Namespace and Module Signatures
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../program-structure-and-execution/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    12. Program Structure and Execution
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../custom-attributes-and-reflection/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    13. Custom Attributes and Reflection
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../inference-procedures/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    14. Inference Procedures
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../lexical-filtering/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    15. Lexical Filtering
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../provided-types/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    16. Provided Types
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../special-attributes-and-types/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    17. Special Attributes and Types
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../the-f-library-fsharpcoredll/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    18. The F# Library FSharp.Core.dll
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../features-for-ml-compatibility/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    19. Features for ML Compatibility
    
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#81-type-definition-group-checking-and-elaboration" class="md-nav__link">
    <span class="md-ellipsis">
      8.1 Type Definition Group Checking and Elaboration
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#82-type-kind-inference" class="md-nav__link">
    <span class="md-ellipsis">
      8.2 Type Kind Inference
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#83-type-abbreviations" class="md-nav__link">
    <span class="md-ellipsis">
      8.3 Type Abbreviations
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#84-record-type-definitions" class="md-nav__link">
    <span class="md-ellipsis">
      8.4 Record Type Definitions
    </span>
  </a>
  
    <nav class="md-nav" aria-label="8.4 Record Type Definitions">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#841-members-in-record-types" class="md-nav__link">
    <span class="md-ellipsis">
      8.4.1 Members in Record Types
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#842-name-resolution-and-record-field-labels" class="md-nav__link">
    <span class="md-ellipsis">
      8.4.2 Name Resolution and Record Field Labels
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#843-structural-hashing-equality-and-comparison-for-record-types" class="md-nav__link">
    <span class="md-ellipsis">
      8.4.3 Structural Hashing, Equality, and Comparison for Record Types
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#844-withend-in-record-type-definitions" class="md-nav__link">
    <span class="md-ellipsis">
      8.4.4 With/End in Record Type Definitions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#845-climutable-attributes" class="md-nav__link">
    <span class="md-ellipsis">
      8.4.5 CLIMutable Attributes
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#85-union-type-definitions" class="md-nav__link">
    <span class="md-ellipsis">
      8.5 Union Type Definitions
    </span>
  </a>
  
    <nav class="md-nav" aria-label="8.5 Union Type Definitions">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#851-members-in-union-types" class="md-nav__link">
    <span class="md-ellipsis">
      8.5.1 Members in Union Types
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#852-structural-hashing-equality-and-comparison-for-union-types" class="md-nav__link">
    <span class="md-ellipsis">
      8.5.2 Structural Hashing, Equality, and Comparison for Union Types
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#853-withend-in-union-type-definitions" class="md-nav__link">
    <span class="md-ellipsis">
      8.5.3 With/End in Union Type Definitions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#854-compiled-form-of-union-types-for-use-from-other-cli-languages" class="md-nav__link">
    <span class="md-ellipsis">
      8.5.4 Compiled Form of Union Types for Use from Other CLI Languages
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#86-class-type-definitions" class="md-nav__link">
    <span class="md-ellipsis">
      8.6 Class Type Definitions
    </span>
  </a>
  
    <nav class="md-nav" aria-label="8.6 Class Type Definitions">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#861-primary-constructors-in-classes" class="md-nav__link">
    <span class="md-ellipsis">
      8.6.1 Primary Constructors in Classes
    </span>
  </a>
  
    <nav class="md-nav" aria-label="8.6.1 Primary Constructors in Classes">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#8611-object-references-in-primary-constructors" class="md-nav__link">
    <span class="md-ellipsis">
      8.6.1.1 Object References in Primary Constructors
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#8612-inheritance-declarations-in-primary-constructors" class="md-nav__link">
    <span class="md-ellipsis">
      8.6.1.2 Inheritance Declarations in Primary Constructors
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#8613-instance-function-and-value-definitions-in-primary-constructors" class="md-nav__link">
    <span class="md-ellipsis">
      8.6.1.3 Instance Function and Value Definitions in Primary Constructors
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#8614-static-function-and-value-definitions-in-primary-constructors" class="md-nav__link">
    <span class="md-ellipsis">
      8.6.1.4 Static Function and Value Definitions in Primary Constructors
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#862-members-in-classes" class="md-nav__link">
    <span class="md-ellipsis">
      8.6.2 Members in Classes
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#863-additional-object-constructors-in-classes" class="md-nav__link">
    <span class="md-ellipsis">
      8.6.3 Additional Object Constructors in Classes
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#864-additional-fields-in-classes" class="md-nav__link">
    <span class="md-ellipsis">
      8.6.4 Additional Fields in Classes
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#87-interface-type-definitions" class="md-nav__link">
    <span class="md-ellipsis">
      8.7 Interface Type Definitions
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#88-struct-type-definitions" class="md-nav__link">
    <span class="md-ellipsis">
      8.8 Struct Type Definitions
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#89-enum-type-definitions" class="md-nav__link">
    <span class="md-ellipsis">
      8.9 Enum Type Definitions
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#810-delegate-type-definitions" class="md-nav__link">
    <span class="md-ellipsis">
      8.10 Delegate Type Definitions
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#811-exception-definitions" class="md-nav__link">
    <span class="md-ellipsis">
      8.11 Exception Definitions
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#812-type-extensions" class="md-nav__link">
    <span class="md-ellipsis">
      8.12 Type Extensions
    </span>
  </a>
  
    <nav class="md-nav" aria-label="8.12 Type Extensions">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#8121-imported-cli-c-extensions-members" class="md-nav__link">
    <span class="md-ellipsis">
      8.12.1 Imported CLI C# Extensions Members
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#813-members" class="md-nav__link">
    <span class="md-ellipsis">
      8.13 Members
    </span>
  </a>
  
    <nav class="md-nav" aria-label="8.13 Members">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#8131-property-members" class="md-nav__link">
    <span class="md-ellipsis">
      8.13.1 Property Members
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#8132-auto-implemented-properties" class="md-nav__link">
    <span class="md-ellipsis">
      8.13.2 Auto-implemented Properties
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#8133-method-members" class="md-nav__link">
    <span class="md-ellipsis">
      8.13.3 Method Members
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#8134-curried-method-members" class="md-nav__link">
    <span class="md-ellipsis">
      8.13.4 Curried Method Members
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#8135-named-arguments-to-method-members" class="md-nav__link">
    <span class="md-ellipsis">
      8.13.5 Named Arguments to Method Members
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#8136-optional-arguments-to-method-members" class="md-nav__link">
    <span class="md-ellipsis">
      8.13.6 Optional Arguments to Method Members
    </span>
  </a>
  
    <nav class="md-nav" aria-label="8.13.6 Optional Arguments to Method Members">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#81361-f-style-optional-arguments" class="md-nav__link">
    <span class="md-ellipsis">
      8.13.6.1 F#-Style Optional Arguments
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#81362-cli-compatible-optional-arguments" class="md-nav__link">
    <span class="md-ellipsis">
      8.13.6.2 CLI-Compatible Optional Arguments
    </span>
  </a>
  
    <nav class="md-nav" aria-label="8.13.6.2 CLI-Compatible Optional Arguments">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#813621-allowable-default-values" class="md-nav__link">
    <span class="md-ellipsis">
      8.13.6.2.1 Allowable Default Values
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#813622-usage-and-considerations" class="md-nav__link">
    <span class="md-ellipsis">
      8.13.6.2.2 Usage and Considerations
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#8137-type-directed-conversions-at-member-invocations" class="md-nav__link">
    <span class="md-ellipsis">
      8.13.7 Type-directed Conversions at Member Invocations
    </span>
  </a>
  
    <nav class="md-nav" aria-label="8.13.7 Type-directed Conversions at Member Invocations">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#81371-conversion-to-delegates" class="md-nav__link">
    <span class="md-ellipsis">
      8.13.7.1 Conversion to Delegates
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#81372-conversion-to-reference-cells" class="md-nav__link">
    <span class="md-ellipsis">
      8.13.7.2 Conversion to Reference Cells
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#81373-conversion-to-quotation-values" class="md-nav__link">
    <span class="md-ellipsis">
      8.13.7.3 Conversion to Quotation Values
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#81374-conversion-to-linq-expressions" class="md-nav__link">
    <span class="md-ellipsis">
      8.13.7.4 Conversion to LINQ Expressions
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#8138-overloading-of-methods" class="md-nav__link">
    <span class="md-ellipsis">
      8.13.8 Overloading of Methods
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#8139-naming-restrictions-for-members" class="md-nav__link">
    <span class="md-ellipsis">
      8.13.9 Naming Restrictions for Members
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#81310-members-represented-as-events" class="md-nav__link">
    <span class="md-ellipsis">
      8.13.10 Members Represented as Events
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#81311-members-represented-as-static-members" class="md-nav__link">
    <span class="md-ellipsis">
      8.13.11 Members Represented as Static Members
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#814-abstract-members-and-interface-implementations" class="md-nav__link">
    <span class="md-ellipsis">
      8.14 Abstract Members and Interface Implementations
    </span>
  </a>
  
    <nav class="md-nav" aria-label="8.14 Abstract Members and Interface Implementations">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#8141-abstract-members" class="md-nav__link">
    <span class="md-ellipsis">
      8.14.1 Abstract Members
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#8142-members-that-implement-abstract-members" class="md-nav__link">
    <span class="md-ellipsis">
      8.14.2 Members that Implement Abstract Members
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#8143-interface-implementations" class="md-nav__link">
    <span class="md-ellipsis">
      8.14.3 Interface Implementations
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#815-equality-hashing-and-comparison" class="md-nav__link">
    <span class="md-ellipsis">
      8.15 Equality, Hashing, and Comparison
    </span>
  </a>
  
    <nav class="md-nav" aria-label="8.15 Equality, Hashing, and Comparison">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#8151-equality-attributes" class="md-nav__link">
    <span class="md-ellipsis">
      8.15.1 Equality Attributes
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#8152-comparison-attributes" class="md-nav__link">
    <span class="md-ellipsis">
      8.15.2 Comparison Attributes
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#8153-behavior-of-the-generated-objectequals-implementation" class="md-nav__link">
    <span class="md-ellipsis">
      8.15.3 Behavior of the Generated Object.Equals Implementation
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#8154-behavior-of-the-generated-compareto-implementations" class="md-nav__link">
    <span class="md-ellipsis">
      8.15.4 Behavior of the Generated CompareTo Implementations
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#8155-behavior-of-the-generated-gethashcode-implementations" class="md-nav__link">
    <span class="md-ellipsis">
      8.15.5 Behavior of the Generated GetHashCode Implementations
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#8156-behavior-of-hash-and-compare" class="md-nav__link">
    <span class="md-ellipsis">
      8.15.6 Behavior of Hash, =, and Compare
    </span>
  </a>
  
    <nav class="md-nav" aria-label="8.15.6 Behavior of Hash, =, and Compare">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#81561-pseudocode-for-fsharpcoreoperatorscompare" class="md-nav__link">
    <span class="md-ellipsis">
      8.15.6.1 Pseudocode for FSharp.Core.Operators.compare
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#81562-pseudo-code-for-fsharpcoreoperators" class="md-nav__link">
    <span class="md-ellipsis">
      8.15.6.2 Pseudo code for FSharp.Core.Operators.(=)
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


  
  


<h1 id="8-type-definitions">8. Type Definitions</h1>
<p>Type definitions define new named types. The grammar of type definitions is shown below.</p>
<div class="highlight"><pre><span></span><code>type-defn :=
    abbrev-type-defn
    record-type-defn
    union-type-defn
    anon-type-defn
    class-type-defn
    struct-type-defn
    interface-type-defn
    enum-type-defn
    delegate-type-defn
    type-extension

type-name :=
    attributes~opt access~opt ident typar-defns~opt

abbrev-type-defn :=
    type-name = type

union-type-defn :=
    type-name &#39;=&#39; union-type-cases type-extension-elements~opt

union-type-cases :=
    &#39;|&#39;~opt union-type-case &#39;|&#39; ... &#39;|&#39; union-type-case

union-type-case :=
    attributes~opt union-type-case-data

union-type-case-data :=
    ident -- null union case
    ident of union-type-field * ... * union-type-field -- n-ary union case
    ident : uncurried-sig -- n-ary union case

union-type-field :=
    type -- unnamed union fiels
    ident : type -- named union field

record-type-defn :=
    type-name = &#39;{&#39; record-fields &#39;}&#39; type-extension-elements~opt

record-fields :=
    record-field ; ... ; record-field ;~opt

record-field :=
    attributes~opt mutable~opt access~opt ident : type

anon-type-defn :=
    type-name primary-constr-args~opt object-val~opt &#39;=&#39; begin class-type-body end

class-type-defn :=
    type-name primary-constr-args~opt object-val~opt &#39;=&#39; class class-type-body end

as-defn := as ident

class-type-body :=
    class-inherits-decl~opt class-function-or-value-defns~opt type-defn-elements~opt

class-inherits-decl := inherit type expr~opt

class-function-or-value-defn :=
    attributes~opt static~opt let rec~opt function-or-value-defns
    attributes~opt static~opt do expr

struct-type-defn :=
    type-name primary-constr-args~opt as-defn~opt &#39;=&#39; struct struct-type-body end

struct-type-body := type-defn-elements

interface-type-defn :=
    type-name &#39;=&#39; interface interface-type-body end

interface-type-body := type-defn-elements

exception-defn :=
    attributes~opt exception union-type-case-data -- exception definition
    attributes~opt exception ident = long-ident -- exception abbreviation

enum-type-defn :=
    type-name &#39;=&#39; enum-type-cases

enum-type-cases =
    &#39;|&#39;~opt enum-type-case &#39;|&#39; ... &#39;|&#39; enum-type-case

enum-type-case :=
    ident &#39;=&#39; const -- enum constant definition

delegate-type-defn :=
    type-name &#39;=&#39; delegate-sig

delegate-sig :=
    delegate of uncurried-sig -- CLI delegate definition

type-extension :=
    type-name type-extension-elements

type-extension-elements := with type-defn-elements end

type-defn-element :=
    member-defn
    interface-impl
    interface-spec

type-defn-elements := type-defn-element ... type-defn-element

primary-constr-args :=
    attributes~opt access~opt ( simple-pat, ... , simple-pat )

simple-pat :=
    | ident
    | simple-pat : type

additional-constr-defn :=
    attributes~opt access~opt new pat as-defn = additional-constr-expr

additional-constr-expr :=
    stmt &#39;;&#39; additional-constr-expr -- sequence construction (after)
    additional-constr-expr then expr -- sequence construction (before)
    if expr then additional-constr-expr else additional-constr-expr
    let function-or-value-defn in additional-constr-expr
    additional-constr-init-expr

additional-constr-init-expr :=
    &#39;{&#39; class-inherits-decl field-initializers &#39;}&#39; -- explicit construction
    new type expr -- delegated construction

member-defn :=
    attributes~opt static~opt member access~opt method-or-prop-defn -- concrete member
    attributes~opt abstract member~opt access~opt member-sig -- abstract member
    attributes~opt override access~opt method-or-prop-defn -- override member
    attributes~opt default access~opt method-or-prop-defn -- override member
    attributes~opt static~opt val mutable~opt access~opt ident : type -- value member
    additional-constr-defn -- additional constructor

method-or-prop-defn :=
    ident.~opt function-defn -- method definition
    ident.~opt value-defn -- property definition
    ident.~opt ident with function-or-value-defns -- property definition via get/set methods
    member ident = exp – - auto-implemented property definition
    member ident = exp with get – - auto-implemented property definition
    member ident = exp with set – - auto-implemented property definition
    member ident = exp with get,set – - auto-implemented property definition
    member ident = exp with set,get – - auto-implemented property definition

member-sig :=
    ident typar-defns~opt : curried-sig -- method or property signature
    ident typar-defns~opt : curried-sig with get -- property signature
    ident typar-defns~opt : curried-sig with set -- property signature
    ident typar-defns~opt : curried-sig with get,set -- property signature
    ident typar-defns~opt : curried-sig with set,get -- property signature

curried-sig :=
    args-spec - &gt; ... - &gt; args-spec - &gt; type

uncurried-sig :=
    args-spec - &gt; type

args-spec :=
    arg-spec * ... * arg-spec

arg-spec :=
    attributes~opt arg-name-spec~opt type

arg-name-spec :=
    ?~opt ident :

interface-spec :=
    interface type
</code></pre></div>
<p>For example:</p>
<div class="highlight"><pre><span></span><code><span class="k">type</span><span class="w"> </span><span class="nc">int</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nn">System</span><span class="p">.</span><span class="n">Int32</span>
<span class="k">type</span><span class="w"> </span><span class="nc">Color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Red</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">Green</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">Blue</span>
<span class="k">type</span><span class="w"> </span><span class="nc">Map</span><span class="o">&lt;</span><span class="k">&#39;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="n">entries</span><span class="o">:</span><span class="w"> </span><span class="k">&#39;</span><span class="n">T</span><span class="bp">[]</span><span class="w"> </span><span class="o">}</span>
</code></pre></div>
<p>Type definitions can be declared in:</p>
<ul>
<li>Module definitions</li>
<li>Namespace declaration groups</li>
</ul>
<p>F# supports the following kinds of type definitions:</p>
<ul>
<li>Type abbreviations (<a href="./#83-type-abbreviations">§8.3</a>)</li>
<li>Record type definitions (<a href="./#84-record-type-definitions">§8.4</a>)</li>
<li>Union type definitions (<a href="./#85-union-type-definitions">§8.5</a>)</li>
<li>Class type definitions (<a href="./#86-class-type-definitions">§8.6</a>)</li>
<li>Interface type definitions (<a href="./#87-interface-type-definitions">§8.7</a>)</li>
<li>Struct type definitions (<a href="./#88-struct-type-definitions">§8.8</a>)</li>
<li>Enum type definitions (<a href="./#89-enum-type-definitions">§8.9</a>)</li>
<li>Delegate type definitions (<a href="./#810-delegate-type-definitions">§8.10</a>)</li>
<li>Exception type definitions (<a href="./#811-exception-definitions">§8.11</a>)</li>
<li>Type extension definitions (<a href="./#812-type-extensions">§8.12</a>)</li>
<li>Measure type definitions (<a href="../units-of-measure/#94-measure-definitions">§9.4</a>)</li>
</ul>
<p>With the exception of type abbreviations and type extension definitions, type definitions define
fresh, named types that are distinct from other types.</p>
<p>A <em>type definition group</em> defines several type definitions or extensions simultaneously:</p>
<div class="highlight"><pre><span></span><code>type ... and ...
</code></pre></div>
<p>For example:</p>
<div class="highlight"><pre><span></span><code><span class="k">type</span><span class="w"> </span><span class="nc">RowVector</span><span class="o">(</span><span class="n">entries</span><span class="o">:</span><span class="w"> </span><span class="n">seq</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;)</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="k">let</span><span class="w"> </span><span class="nv">entries</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nn">Seq</span><span class="p">.</span><span class="n">toArray</span><span class="w"> </span><span class="n">entries</span>
<span class="w">    </span><span class="k">member</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="nf">Length</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">entries</span><span class="o">.</span><span class="n">Length</span>
<span class="w">    </span><span class="k">member</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="nf">Permute</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ColumnVector</span><span class="o">(</span><span class="n">entries</span><span class="o">)</span>
<span class="ow">and</span><span class="w"> </span><span class="n">ColumnVector</span><span class="o">(</span><span class="n">entries</span><span class="o">:</span><span class="w"> </span><span class="n">seq</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;)</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="k">let</span><span class="w"> </span><span class="nv">entries</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nn">Seq</span><span class="p">.</span><span class="n">toArray</span><span class="w"> </span><span class="n">entries</span>
<span class="w">    </span><span class="k">member</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="nf">Length</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">entries</span><span class="o">.</span><span class="n">Length</span>
<span class="w">    </span><span class="k">member</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="nf">Permute</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">RowVector</span><span class="o">(</span><span class="n">entries</span><span class="o">)</span>
</code></pre></div>
<p>A type definition group can include any type definitions except for exception type definitions and
module definitions.</p>
<p>Most forms of type definitions may contain both <em>static</em> elements and <em>instance</em> elements. Static
elements are accessed by using the type definition. Within a <code>static</code> definition, only the <code>static</code>
elements are in scope. Most forms of type definitions may contain <em>members</em> (<a href="./#813-members">§8.13</a>).</p>
<p>Custom attributes may be placed immediately before a type definition group, in which case they
apply to the first type definition, or immediately before the name of the type definition:</p>
<div class="highlight"><pre><span></span><code><span class="o">[&lt;</span><span class="n">Obsolete</span><span class="o">&gt;]</span><span class="w"> </span><span class="k">type</span><span class="w"> </span><span class="nc">X1</span><span class="bp">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="k">end</span>

<span class="k">type</span><span class="w"> </span><span class="o">[&lt;</span><span class="n">Obsolete</span><span class="o">&gt;]</span><span class="w"> </span><span class="n">X2</span><span class="bp">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="k">end</span>
<span class="ow">and</span><span class="w"> </span><span class="o">[&lt;</span><span class="n">Obsolete</span><span class="o">&gt;]</span><span class="w"> </span><span class="n">Y2</span><span class="bp">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="k">end</span>
</code></pre></div>
<h2 id="81-type-definition-group-checking-and-elaboration">8.1 Type Definition Group Checking and Elaboration</h2>
<p>F# checks type definition groups by determining the basic shape of the definitions and then filling in
the details. In overview, a type definition group is checked as follows:</p>
<ol>
<li>For each type definition:<ul>
<li>Determine the generic arguments, accessibility and kind of the type definition</li>
<li>Determine whether the type definition supports equality and/or comparison</li>
<li>Elaborate the explicit constraints for the generic parameters.</li>
</ul>
</li>
<li>For each type definition:<ul>
<li>Establish type abbreviations</li>
<li>Determine the base types and implemented interfaces of each new type definition</li>
<li>Detect any cyclic abbreviations</li>
<li>Verify the consistency of types in fields, union cases, and base types.</li>
</ul>
</li>
<li>For each type definition:<ul>
<li>Determine the union cases, fields, and abstract members (<a href="./#814-abstract-members-and-interface-implementations">§8.14</a>) of each new type
definition.</li>
<li>Check the union cases, fields, and abstract members themselves, as described in the
corresponding sections of this chapter.</li>
</ul>
</li>
<li>For each member, add items that represent the members to the environment as a recursive
group.</li>
<li>Check the members, function, and value definitions in order and apply incremental
generalization.</li>
</ol>
<p>In the context in which type definitions are checked, the type definition itself is in scope, as are all
members and other accessible functionality of the type. This context enables recursive references to
the accessible static content of a type. It also enables recursive references to the accessible
properties of any object that has the same type as the type definition or a related type.</p>
<p>In more detail, given an initial environment <code>env</code>, a type definition group is checked as described in
the following paragraphs.</p>
<p>First, check the individual type definitions. For each type definition:</p>
<ol>
<li>Determine the number, names, and sorts of generic arguments of the type definition.<ul>
<li>For each generic argument, if a <code>Measure</code> attribute is present, mark the generic argument as a
   measure parameter. The generic arguments are initially inference parameters, and
   additional constraints may be inferred for these parameters.</li>
<li>For each type definition <code>T</code> , the subsequent steps use an environment <code>envT</code> that is produced
   by adding the type definitions themselves and the generic arguments for <code>T</code> to <code>env</code>.</li>
</ul>
</li>
<li>Determine the accessibility of the type definition.</li>
<li>Determine and check the basic kind of the type definition, using <em>Type Kind Inference</em> if necessary
    (<a href="./#82-type-kind-inference">§8.2</a>).</li>
<li>
<p>Mark the type definition as a measure type definition if a <code>Measure</code> attribute is present.</p>
</li>
<li>
<p>If the type definition is generic, infer whether the type definition supports equality and/or
comparison.</p>
</li>
<li>
<p>Elaborate and add the explicit constraints for the generic parameters of the type definition, and
    then generalize the generic parameters. Inference of additional constraints is not permitted.</p>
</li>
<li>If the type definition is a type abbreviation, elaborate and establish the type being abbreviated.</li>
<li>Check and elaborate any base types and implemented interfaces.</li>
<li>If the type definition is a type abbreviation, check that the type abbreviation is not cyclic.</li>
<li>Check whether the type definition has a single, zero-argument constructor, and hence forms a
    type that satisfies the default constructor constraint.</li>
<li>Recheck the following to ensure that constraints are consist:<ul>
<li>The type being abbreviated, if any.</li>
<li>The explicit constraints for any generic parameters, if any.</li>
<li>The types and constraints occurring in the base types and implemented interfaces, if any.</li>
</ul>
</li>
<li>Determine the union cases, fields, and abstract members, if any, of the type definition. Check
    and elaborate the types that the union cases, fields, and abstract members include.</li>
<li>Make additional checks as defined elsewhere in this chapter. For example, check that the
    <code>AbstractClass</code> attribute does not appear on a union type.</li>
<li>
<p>For each type definition that is a struct, class, or interface, check that the inheritance graph and
    the struct-inclusion graph are not cyclic. This check ensures that a struct does not contain itself
    and that a class or interface does not inherit from itself. This check includes the following steps:</p>
<p>a) Create a graph with one node for each type definition.</p>
<p>b) Close the graph under edges.</p>
<ul>
<li>(T, base-type-definition)</li>
<li>(T, interface-type-definition)</li>
<li>(T 1 , T 2 ) where T 1 is a struct and T 2 is a type that would store a value of type T 1 &lt;...&gt; for
    some instantiation. Here “X storing Y” means that X is Y or is a struct type with an
    instance field that stores Y.</li>
</ul>
<p>c) Check for cycles.</p>
<p>The special case of a struct <code>S&lt;typars&gt;</code> storing a static field of type <code>S&lt;typars&gt;</code> is allowed.
15. Collectively add the elaborated member items that represent the members for all new type
definitions to the environment as a recursive group (<a href="./#813-members">§8.13</a>), excluding interface implementation
members.</p>
</li>
<li>
<p>If the type definition has a primary constructor, create a member item to represent the primary
    constructor.</p>
</li>
</ol>
<p>After these steps are complete for each type definition, check the members. For each member:</p>
<ol>
<li>If the member is in a generic type, create a copy of the type parameters for the generic type and
    add the copy to the environment for that member.</li>
<li>If the member has explicit type parameters, elaborate these type parameters and any explicit
    constraints.</li>
<li>If the member is an override, default, or interface implementation member, apply dispatch-slot
    inference.</li>
<li>If the member has syntactic parameters, assign an initial type to the elaborated member item
    based on the patterns that specify arguments for the members.</li>
<li>If the member is an instance member, assign a type to the instance variable.</li>
</ol>
<p>Finally, check the function, value, and member definitions of each new type definition in order as a
recursive group.</p>
<h2 id="82-type-kind-inference">8.2 Type Kind Inference</h2>
<p>A type that is specified in one of the following ways has an anonymous type kind:</p>
<ul>
<li>By using <code>begin</code> and <code>end</code> on the right-hand side of the = token.</li>
<li>In lightweight syntax, with an implicit <code>begin</code>/<code>end</code>.</li>
</ul>
<p>F# infers the kind of an anonymous type by applying the following rules, in order:</p>
<ol>
<li>If the type has a <code>Class</code> attribute, <code>Interface</code> attribute, or <code>Struct</code> attribute, this attribute identifies
    the kind of the type.</li>
<li>If the type has any concrete elements, the type is a class. Concrete elements are primary
    constructors, additional object constructors, function definitions, value definitions, non-abstract
    members, and any <code>inherit</code> declarations that have arguments.</li>
<li>Otherwise, the type is an interface type.</li>
</ol>
<p>For example:</p>
<div class="highlight"><pre><span></span><code><span class="c1">// This is implicitly an interface</span>
<span class="k">type</span><span class="w"> </span><span class="nc">IName</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="k">abstract</span><span class="w"> </span><span class="n">Name</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">string</span>

<span class="c1">// This is implicitly a class, because it has a constructor</span>
<span class="k">type</span><span class="w"> </span><span class="nc">ConstantName</span><span class="o">(</span><span class="n">n</span><span class="o">:</span><span class="kt">string</span><span class="o">)</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="k">member</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="nf">Name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">n</span>

<span class="c1">// This is implicitly a class, because it has a constructor</span>
<span class="k">type</span><span class="w"> </span><span class="nc">AbstractName</span><span class="o">(</span><span class="n">n</span><span class="o">:</span><span class="kt">string</span><span class="o">)</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="k">abstract</span><span class="w"> </span><span class="n">Name</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">string</span>
<span class="w">    </span><span class="k">default</span><span class="w"> </span><span class="n">x</span><span class="o">.</span><span class="n">Name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;&lt;no-name&gt;&quot;</span>
</code></pre></div>
<p>If a type is not an anonymous type, any use of the <code>Class</code> attribute, <code>Interface</code> attribute, or <code>Struct</code>
attribute must match the <code>class</code>/<code>end</code>, <code>interface</code>/<code>end</code>, and <code>struct</code>/<code>end</code> tokens, if such tokens are
present. These attributes cannot be used with other kinds of type definitions such as type
abbreviations, record, union, or enum types.</p>
<h2 id="83-type-abbreviations">8.3 Type Abbreviations</h2>
<p>Type abbreviations define new names for other types. For example:</p>
<div class="highlight"><pre><span></span><code><span class="k">type</span><span class="w"> </span><span class="nc">PairOfInt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">int</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">int</span>
</code></pre></div>
<p>Type abbreviations are expanded and erased during compilation and do not appear in the
elaborated form of F# declarations, nor can they be referred to or accessed at runtime.</p>
<p>The process of repeatedly eliminating type abbreviations in favor of their equivalent types must not
result in an infinite type derivation. For example, the following are not valid type definitions:</p>
<div class="highlight"><pre><span></span><code><span class="k">type</span><span class="w"> </span><span class="nc">X</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">option</span><span class="o">&lt;</span><span class="n">X</span><span class="o">&gt;</span>

<span class="k">type</span><span class="w"> </span><span class="nc">Identity</span><span class="o">&lt;</span><span class="k">&#39;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">&#39;</span><span class="n">T</span>
<span class="ow">and</span><span class="w"> </span><span class="n">Y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Identity</span><span class="o">&lt;</span><span class="n">Y</span><span class="o">&gt;</span>
</code></pre></div>
<p>The constraints on a type abbreviation must satisfy any constraints that the abbreviated type
requires.</p>
<p>For example, assuming the following declarations:</p>
<div class="highlight"><pre><span></span><code><span class="k">type</span><span class="w"> </span><span class="nc">IA</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="k">abstract</span><span class="w"> </span><span class="n">AbstractMember</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">int</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">int</span>

<span class="k">type</span><span class="w"> </span><span class="nc">IB</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="k">abstract</span><span class="w"> </span><span class="n">AbstractMember</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">int</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">int</span>

<span class="k">type</span><span class="w"> </span><span class="nc">C</span><span class="o">&lt;</span><span class="k">&#39;</span><span class="n">T</span><span class="w"> </span><span class="k">when</span><span class="w"> </span><span class="k">&#39;</span><span class="n">T</span><span class="w"> </span><span class="o">:&gt;</span><span class="w"> </span><span class="n">IB</span><span class="o">&gt;</span><span class="bp">()</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="k">member</span><span class="w"> </span><span class="n">StaticMember</span><span class="o">(</span><span class="n">x</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">&#39;</span><span class="n">a</span><span class="o">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="o">.</span><span class="n">AbstractMember</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>
</code></pre></div>
<p>the following is permitted:</p>
<div class="highlight"><pre><span></span><code><span class="k">type</span><span class="w"> </span><span class="nc">D</span><span class="o">&lt;</span><span class="k">&#39;</span><span class="n">T</span><span class="w"> </span><span class="k">when</span><span class="w"> </span><span class="k">&#39;</span><span class="n">T</span><span class="w"> </span><span class="o">:&gt;</span><span class="w"> </span><span class="n">IB</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">C</span><span class="o">&lt;</span><span class="k">&#39;</span><span class="n">T</span><span class="o">&gt;</span>
</code></pre></div>
<p>whereas the following is not permitted:</p>
<div class="highlight"><pre><span></span><code><span class="k">type</span><span class="w"> </span><span class="nc">E</span><span class="o">&lt;</span><span class="k">&#39;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">C</span><span class="o">&lt;</span><span class="k">&#39;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="c1">// invalid: missing constraint</span>
</code></pre></div>
<p>Type abbreviations can define additional constraints, so the following is permitted:</p>
<div class="highlight"><pre><span></span><code><span class="k">type</span><span class="w"> </span><span class="nc">F</span><span class="o">&lt;</span><span class="k">&#39;</span><span class="n">T</span><span class="w"> </span><span class="k">when</span><span class="w"> </span><span class="k">&#39;</span><span class="n">T</span><span class="w"> </span><span class="o">:&gt;</span><span class="w"> </span><span class="n">IA</span><span class="w"> </span><span class="ow">and</span><span class="w"> </span><span class="k">&#39;</span><span class="n">T</span><span class="w"> </span><span class="o">:&gt;</span><span class="w"> </span><span class="n">IB</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">C</span><span class="o">&lt;</span><span class="k">&#39;</span><span class="n">T</span><span class="o">&gt;</span>
</code></pre></div>
<p>The right side of a type abbreviation must use all the declared type variables that appear on the left
side. For this purpose, the order of type variables that are used on the right-hand side of a type
definition is determined by their left-to-right occurrence in the type.</p>
<p>For example, the following is not a valid type abbreviation.</p>
<div class="highlight"><pre><span></span><code><span class="k">type</span><span class="w"> </span><span class="nc">Drop</span><span class="o">&lt;</span><span class="k">&#39;</span><span class="n">T</span><span class="o">,</span><span class="k">&#39;</span><span class="n">U</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">&#39;</span><span class="n">T</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">&#39;</span><span class="n">T</span><span class="w"> </span><span class="c1">// invalid: dropped type variable</span>
</code></pre></div>
<blockquote>
<p>Note : This restriction simplifies the process of guaranteeing a stable and consistent
compilation to generic CLI code.</p>
</blockquote>
<p>Flexible type constraints # <em>type</em> may not be used on the right side of a type abbreviation, because
they expand to a type variable that has not been named in the type arguments of the type
abbreviation. For example, the following type is disallowed:</p>
<div class="highlight"><pre><span></span><code><span class="k">type</span><span class="w"> </span><span class="nc">BadType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">#</span><span class="n">Exception</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">int</span><span class="w"> </span><span class="c1">// disallowed</span>
</code></pre></div>
<p>Type abbreviations may be declared <code>internal</code> or <code>private</code>.</p>
<blockquote>
<p>Note: Private type abbreviations are still, for all purposes, considered equivalent to the
abbreviated types.</p>
</blockquote>
<h2 id="84-record-type-definitions">8.4 Record Type Definitions</h2>
<p>A <em>record type definition</em> introduces a type in which all the inputs that are used to construct a value
are accessible as properties on values of the type. For example:</p>
<div class="highlight"><pre><span></span><code><span class="k">type</span><span class="w"> </span><span class="nc">R1</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="o">{</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">int</span><span class="o">;</span>
<span class="w">    </span><span class="n">y</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">int</span><span class="w"> </span><span class="o">}</span>
<span class="w">    </span><span class="k">member</span><span class="w"> </span><span class="n">this</span><span class="p">.</span><span class="nf">Sum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">this</span><span class="o">.</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">this</span><span class="o">.</span><span class="n">y</span>
</code></pre></div>
<p>In this example, the integers x and y can be accessed as properties on values of type R1.</p>
<p>Record fields may be marked mutable. For example:</p>
<div class="highlight"><pre><span></span><code><span class="k">type</span><span class="w"> </span><span class="nc">R2</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="o">{</span><span class="w"> </span><span class="k">mutable</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">int</span><span class="o">;</span>
<span class="w">      </span><span class="k">mutable</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">int</span><span class="w"> </span><span class="o">}</span>
<span class="w">    </span><span class="k">member</span><span class="w"> </span><span class="n">this</span><span class="p">.</span><span class="nf">Move</span><span class="o">(</span><span class="n">dx</span><span class="o">,</span><span class="n">dy</span><span class="o">)</span><span class="w"> </span><span class="o">=</span>
<span class="w">        </span><span class="n">this</span><span class="o">.</span><span class="n">x</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">this</span><span class="o">.</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">dx</span>
<span class="w">        </span><span class="n">this</span><span class="o">.</span><span class="n">y</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">this</span><span class="o">.</span><span class="n">y</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">dy</span>
</code></pre></div>
<p>The <code>mutable</code> attribute on <code>x</code> and <code>y</code> makes the assignments valid.</p>
<p>Record types are implicitly sealed and may not be given the <code>Sealed</code> attribute. Record types may not
be given the <code>AbstractClass</code> attribute.</p>
<p>Record types are implicitly marked serializable unless the <code>AutoSerializable(false)</code> attribute is used.</p>
<h3 id="841-members-in-record-types">8.4.1 Members in Record Types</h3>
<p>Record types may declare members (<a href="./#813-members">§8.13</a>), overrides, and interface implementations. Like all types
with overrides and interface implementations, they are subject to <em>Dispatch Slot Checking</em> (<a href="../inference-procedures/#148-dispatch-slot-checking">§14.8</a>).</p>
<h3 id="842-name-resolution-and-record-field-labels">8.4.2 Name Resolution and Record Field Labels</h3>
<p>For a record type, the record field labels <code>field1</code> ... <code>field</code><em> are added to the _FieldLabels</em> table of the
current name resolution environment unless the record type has the <code>RequireQualifiedAccess</code>
attribute.</p>
<p>Record field labels in the <em>FieldLabels</em> table play a special role in <em>Name Resolution for Members</em>
(<a href="../inference-procedures/#141-name-resolution">§14.1</a>): an expression’s type may be inferred from a record label. For example:</p>
<div class="highlight"><pre><span></span><code><span class="k">type</span><span class="w"> </span><span class="nc">R</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="n">dx</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">int</span><span class="o">;</span><span class="w"> </span><span class="n">dy</span><span class="o">:</span><span class="w"> </span><span class="n">int</span><span class="w"> </span><span class="o">}</span>
<span class="k">let</span><span class="w"> </span><span class="nv">f</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="o">.</span><span class="n">dx</span><span class="w"> </span><span class="c1">// x is inferred to have type R</span>
</code></pre></div>
<p>In this example, the lookup <code>.dx</code> is resolved to be a field lookup.</p>
<h3 id="843-structural-hashing-equality-and-comparison-for-record-types">8.4.3 Structural Hashing, Equality, and Comparison for Record Types</h3>
<p>Record types implicitly implement the following interfaces and dispatch slots unless they are
explicitly implemented as part of the definition of the record type:</p>
<div class="highlight"><pre><span></span><code><span class="k">interface</span><span class="w"> </span><span class="nn">System</span><span class="p">.</span><span class="nn">Collections</span><span class="p">.</span><span class="n">IStructuralEquatable</span>
<span class="k">interface</span><span class="w"> </span><span class="nn">System</span><span class="p">.</span><span class="nn">Collections</span><span class="p">.</span><span class="n">IStructuralComparable</span>
<span class="k">interface</span><span class="w"> </span><span class="nn">System</span><span class="p">.</span><span class="n">IComparable</span>
<span class="k">override</span><span class="w"> </span><span class="n">GetHashCode</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">unit</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">int</span>
<span class="k">override</span><span class="w"> </span><span class="n">Equals</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">obj</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">bool</span>
</code></pre></div>
<p>The implicit implementations of these interfaces and overrides are described in <a href="./#815-equality-hashing-and-comparison">§8.15</a>.</p>
<h3 id="844-withend-in-record-type-definitions">8.4.4 With/End in Record Type Definitions</h3>
<p>Record type definitions can include <code>with</code>/<code>end</code> tokens, as the following shows:</p>
<div class="highlight"><pre><span></span><code><span class="k">type</span><span class="w"> </span><span class="nc">R1</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="o">{</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">int</span><span class="o">;</span>
<span class="w">      </span><span class="n">y</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">int</span><span class="w"> </span><span class="o">}</span>
<span class="w">    </span><span class="k">with</span>
<span class="w">        </span><span class="k">member</span><span class="w"> </span><span class="n">this</span><span class="p">.</span><span class="nf">Sum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">this</span><span class="o">.</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">this</span><span class="o">.</span><span class="n">y</span>
<span class="w">    </span><span class="k">end</span>
</code></pre></div>
<p>The <code>with</code>/<code>end</code> tokens can be omitted if the type-defn-elements vertically align with the <code>{</code> in the
<code>record-fields</code>. The semicolon (<code>;</code>) tokens can be omitted if the next <code>record-field</code> vertically aligns
with the previous <code>record-field</code>.</p>
<h3 id="845-climutable-attributes">8.4.5 CLIMutable Attributes</h3>
<p>Adding the <code>CLIMutable</code> attribute to a record type causes it to be compiled to a CLI representation as
a plain-old CLR object (POCO) with a default constructor along with property getters and setters.
Adding the default constructor and mutable properties makes objects of the record type usable with
.NET tools and frameworks such as database queries, serialization frameworks, and data models in
XAML programming.</p>
<p>For example, an F# immutable record cannot be serialized because it does not have a constructor.
However, if you attach the CLIMutable attribute as in the following example, the XmlSerializer is
enable to serialize or deserialize this record type:</p>
<div class="highlight"><pre><span></span><code><span class="o">[&lt;</span><span class="n">CLIMutable</span><span class="o">&gt;]</span>
<span class="k">type</span><span class="w"> </span><span class="nc">R1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">string</span><span class="o">;</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">int</span><span class="w"> </span><span class="o">}</span>
</code></pre></div>
<h2 id="85-union-type-definitions">8.5 Union Type Definitions</h2>
<p>A <em>union type definition</em> is a type definition that includes one or more <em>union cases</em>. For example:</p>
<div class="highlight"><pre><span></span><code><span class="k">type</span><span class="w"> </span><span class="nc">Message</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="o">|</span><span class="w"> </span><span class="n">Result</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="kt">string</span>
<span class="w">    </span><span class="o">|</span><span class="w"> </span><span class="n">Request</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="n">int</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="kt">string</span>
<span class="w">    </span><span class="k">member</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="nf">Name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">match</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="k">with</span><span class="w"> </span><span class="n">Result</span><span class="o">(</span><span class="n">nm</span><span class="o">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">nm</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">Request</span><span class="o">(_,</span><span class="n">nm</span><span class="o">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">nm</span>
</code></pre></div>
<p>Union case names must begin with an uppercase letter, which is defined to mean any character for
which the CLI library function <code>System.Char.IsUpper</code> returns <code>true</code> and <code>System.Char.IsLower</code> returns
<code>false</code>.</p>
<p>The union cases <code>Case1</code> ... <code>CaseN</code> have module scope and are added to the <em>ExprItems</em> and <em>PatItems</em>
tables in the name resolution environment. This means that their unqualified names can be used to
form both expressions and patterns, unless the record type has the <code>RequireQualifiedAccess</code>
attribute.</p>
<p>Parentheses are significant in union definitions. Thus, the following two definitions differ:</p>
<div class="highlight"><pre><span></span><code><span class="k">type</span><span class="w"> </span><span class="nc">CType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">C</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="n">int</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">int</span>
<span class="k">type</span><span class="w"> </span><span class="nc">CType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">C</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="o">(</span><span class="n">int</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">int</span><span class="o">)</span>
</code></pre></div>
<p>The lack of parentheses in the first example indicates that the union case takes two arguments. The
parentheses in the second example indicate that the union case takes one argument that is a first-
class tuple value.</p>
<p>Union fields may optionally be named within each case of a union type. For example:</p>
<div class="highlight"><pre><span></span><code><span class="k">type</span><span class="w"> </span><span class="nc">Shape</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="o">|</span><span class="w"> </span><span class="n">Rectangle</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="n">width</span><span class="o">:</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">length</span><span class="o">:</span><span class="w"> </span><span class="kt">float</span>
<span class="w">    </span><span class="o">|</span><span class="w"> </span><span class="n">Circle</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="n">radius</span><span class="o">:</span><span class="w"> </span><span class="kt">float</span>
<span class="w">    </span><span class="o">|</span><span class="w"> </span><span class="n">Prism</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="n">width</span><span class="o">:</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">height</span><span class="o">:</span><span class="w"> </span><span class="kt">float</span>
</code></pre></div>
<p>The names are referenced when pattern matching on union values of this type. When using pattern
matching with multiple fields, semicolons are used to delimit the named fields, e.g. <code>Prism(width=w; height=h).</code></p>
<p>The following declaration defines a type abbreviation if the named type <code>A</code> exists in the name
resolution environment. Otherwise it defines a union type.</p>
<div class="highlight"><pre><span></span><code><span class="k">type</span><span class="w"> </span><span class="nc">OneChoice</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">A</span>
</code></pre></div>
<p>To disambiguate this case and declare an explicit union type, use the following:</p>
<div class="highlight"><pre><span></span><code><span class="k">type</span><span class="w"> </span><span class="nc">OneChoice</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="o">|</span><span class="w"> </span><span class="n">A</span>
</code></pre></div>
<p>Union types are implicitly marked serializable unless the <code>AutoSerializable(false)</code> attribute is used.</p>
<h3 id="851-members-in-union-types">8.5.1 Members in Union Types</h3>
<p>Union types may declare members (<a href="./#813-members">§8.13</a>), overrides, and interface implementations. As with all
types that declare overrides and interface implementations, they are subject to <em>Dispatch Slot
Checking</em> (<a href="../inference-procedures/#148-dispatch-slot-checking">§14.8</a>).</p>
<h3 id="852-structural-hashing-equality-and-comparison-for-union-types">8.5.2 Structural Hashing, Equality, and Comparison for Union Types</h3>
<p>Union types implicitly implement the following interfaces and dispatch slots unless they are explicitly
implemented as part of the definition of the union type:</p>
<div class="highlight"><pre><span></span><code><span class="k">interface</span><span class="w"> </span><span class="nn">System</span><span class="p">.</span><span class="nn">Collections</span><span class="p">.</span><span class="n">IStructuralEquatable</span>
<span class="k">interface</span><span class="w"> </span><span class="nn">System</span><span class="p">.</span><span class="nn">Collections</span><span class="p">.</span><span class="n">IStructuralComparable</span>
<span class="k">interface</span><span class="w"> </span><span class="nn">System</span><span class="p">.</span><span class="n">IComparable</span>
<span class="k">override</span><span class="w"> </span><span class="n">GetHashCode</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">unit</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">int</span>
<span class="k">override</span><span class="w"> </span><span class="n">Equals</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">obj</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">bool</span>
</code></pre></div>
<p>The implicit implementations of these interfaces and overrides are described in <a href="./#815-equality-hashing-and-comparison">§8.15</a>.</p>
<h3 id="853-withend-in-union-type-definitions">8.5.3 With/End in Union Type Definitions</h3>
<p>Union type definitions can include <code>with</code>/<code>end</code> tokens, as the following shows:</p>
<div class="highlight"><pre><span></span><code><span class="k">type</span><span class="w"> </span><span class="nc">R1</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="o">{</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">int</span><span class="o">;</span>
<span class="w">      </span><span class="n">y</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">int</span><span class="w"> </span><span class="o">}</span>
<span class="w">    </span><span class="k">with</span>
<span class="w">        </span><span class="k">member</span><span class="w"> </span><span class="n">this</span><span class="p">.</span><span class="nf">Sum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">this</span><span class="o">.</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">this</span><span class="o">.</span><span class="n">y</span>
<span class="w">    </span><span class="k">end</span>
</code></pre></div>
<p>The <code>with</code>/<code>end</code> tokens can be omitted if the type-defn-elements vertically align with the <code>{</code> in the
record-fields. The semicolon (<code>;</code>) tokens can be omitted if the next <em>record-field</em> vertically aligns
with the previous <em>record-field</em>.</p>
<p>For union types, the <code>with</code>/<code>end</code> tokens can be omitted if the type-defn-elements vertically alignwith
the first <code>|</code> in the union-type-cases. However, <code>with</code>/<code>end</code> must be present if the <code>|</code> tokens align with the
<code>type</code> token. For example:</p>
<div class="highlight"><pre><span></span><code><span class="sd">/// Note: this layout is permitted</span>
<span class="k">type</span><span class="w"> </span><span class="nc">Message</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="o">|</span><span class="w"> </span><span class="n">Result</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="kt">string</span>
<span class="w">    </span><span class="o">|</span><span class="w"> </span><span class="n">Request</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="n">int</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="kt">string</span>
<span class="w">    </span><span class="k">member</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="nf">Name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">match</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="k">with</span><span class="w"> </span><span class="n">Result</span><span class="o">(</span><span class="n">nm</span><span class="o">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">nm</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">Request</span><span class="o">(_,</span><span class="n">nm</span><span class="o">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">nm</span>

<span class="sd">/// Note: this layout is not permitted</span>
<span class="k">type</span><span class="w"> </span><span class="nc">Message</span><span class="w"> </span><span class="o">=</span>
<span class="o">|</span><span class="w"> </span><span class="n">Result</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="kt">string</span>
<span class="o">|</span><span class="w"> </span><span class="n">Request</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="n">int</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="kt">string</span>
<span class="k">member</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="nf">Name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">match</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="k">with</span><span class="w"> </span><span class="n">Result</span><span class="o">(</span><span class="n">nm</span><span class="o">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">nm</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">Request</span><span class="o">(_,</span><span class="n">nm</span><span class="o">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">nm</span>
</code></pre></div>
<h3 id="854-compiled-form-of-union-types-for-use-from-other-cli-languages">8.5.4 Compiled Form of Union Types for Use from Other CLI Languages</h3>
<p>A compiled union type <code>U</code> has:</p>
<ul>
<li>One CLI static getter property <code>U.C</code> for each null union case <code>C</code>. This property gets a singleton
    object that represents each such case.</li>
<li>One CLI nested type <code>U.C</code> for each non-null union case <code>C</code>. This type has instance properties <code>Item1</code>,
    <code>Item2</code> ... for each field of the union case, or a single instance property <code>Item</code> if there is only one
    field. However, a compiled union type that has only one case does not have a nested type.
    Instead, the union type itself plays the role of the case type.</li>
<li>One CLI static method <code>U.NewC</code> for each non-null union case <code>C</code>. This method constructs an object
    for that case.</li>
<li>One CLI instance property <code>U.IsC</code> for each case <code>C</code>. This property returns <code>true</code> or <code>false</code> for the case.</li>
<li>One CLI instance property <code>U.Tag</code> for each case <code>C</code>. This property fetches or computes an integer
    tag corresponding to the case.</li>
<li>If <code>U</code> has more than one case, it has one CLI nested type <code>U.Tags</code>. The <code>U.Tags</code> type contains one
    integer literal for each case, in increasing order starting from zero.</li>
<li>A compiled union type has the methods that are required to implement its auto-generated
    interfaces, in addition to any user-defined properties or methods.</li>
</ul>
<p>These methods and properties may not be used directly from F#. However, these types have user-
facing <code>List.Empty</code>, <code>List.Cons</code>, <code>Option.None</code>, and <code>Option.Some</code> properties and/or methods.</p>
<p>A compiled union type may not be used as a base type in another CLI language, because it has at
least one assembly-private constructor and no public constructors.</p>
<h2 id="86-class-type-definitions">8.6 Class Type Definitions</h2>
<p>A <em>class type definition</em> encapsulates values that are constructed by using one or more object
constructors. Class types have the form:</p>
<div class="highlight"><pre><span></span><code>type type-name pat~opt as-defn~opt =
    class
        class-inherits-decl~opt
        class-function-or-value-defns~opt
        type-defn-elements
    end
</code></pre></div>
<p>The <code>class</code>/<code>end</code> tokens can be omitted, in which case <em>Type Kind Inference</em> (<a href="./#82-type-kind-inference">§8.2</a>) is used to determine
the kind of the type.</p>
<p>In F#, class types are implicitly marked serializable unless the <code>AutoSerializable(false)</code> attribute is
present.</p>
<h3 id="861-primary-constructors-in-classes">8.6.1 Primary Constructors in Classes</h3>
<p>An <em>object constructor</em> represents a way of initializing an object. Object constructors can create values
of the type and can partially initialize an object from a subclass. A class can have an optional <em>primary
constructor</em> and zero or more <em>additional object constructors</em>.</p>
<p>If a type definition has a pattern immediately after the <code>type-name</code> and any accessibility annotation,
then it has a <em>primary constructor</em>. For example, the following type has a primary constructor:</p>
<div class="highlight"><pre><span></span><code><span class="k">type</span><span class="w"> </span><span class="nc">Vector2D</span><span class="o">(</span><span class="n">dx</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">float</span><span class="o">,</span><span class="w"> </span><span class="n">dy</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">float</span><span class="o">)</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="k">let</span><span class="w"> </span><span class="nv">length</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sqrt</span><span class="o">(</span><span class="n">dx</span><span class="o">*</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">dy</span><span class="o">*</span><span class="n">dy</span><span class="o">)</span>
<span class="w">    </span><span class="k">member</span><span class="w"> </span><span class="n">v</span><span class="p">.</span><span class="nf">Length</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">length</span>
<span class="w">    </span><span class="k">member</span><span class="w"> </span><span class="n">v</span><span class="p">.</span><span class="nf">DX</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dx</span>
<span class="w">    </span><span class="k">member</span><span class="w"> </span><span class="n">v</span><span class="p">.</span><span class="nf">DY</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dy</span>
</code></pre></div>
<p>Class definitions that have a primary constructor may contain function and value definitions,
including those that use <code>let rec</code>.</p>
<p>The pattern for a primary constructor must have zero or more patterns of the following form:</p>
<div class="highlight"><pre><span></span><code>( simple-pat , ..., simple-pat )
</code></pre></div>
<p>Each <code>simple-pat</code> has this form:</p>
<div class="highlight"><pre><span></span><code>simple-pat :=
    | ident
    | simple-pat : type
</code></pre></div>
<p>Specifically, nested patterns may not be used in the primary constructor arguments. For example,
the following is not permitted because the primary constructor arguments contain a nested tuple
pattern:</p>
<div class="highlight"><pre><span></span><code><span class="k">type</span><span class="w"> </span><span class="nc">TwoVectors</span><span class="o">((</span><span class="n">px</span><span class="o">,</span><span class="w"> </span><span class="n">py</span><span class="o">),</span><span class="w"> </span><span class="o">(</span><span class="n">qx</span><span class="o">,</span><span class="w"> </span><span class="n">qy</span><span class="o">))</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="k">member</span><span class="w"> </span><span class="n">v</span><span class="p">.</span><span class="nf">Length</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sqrt</span><span class="o">((</span><span class="n">qx</span><span class="o">-</span><span class="n">px</span><span class="o">)*(</span><span class="n">qx</span><span class="o">-</span><span class="n">px</span><span class="o">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="o">(</span><span class="n">qy</span><span class="o">-</span><span class="n">py</span><span class="o">)*(</span><span class="n">qy</span><span class="o">-</span><span class="n">py</span><span class="o">))</span>
</code></pre></div>
<p>Instead, one or more value definitions should be used to accomplish the same effect:</p>
<div class="highlight"><pre><span></span><code><span class="k">type</span><span class="w"> </span><span class="nc">TwoVectors</span><span class="o">(</span><span class="n">pv</span><span class="o">,</span><span class="w"> </span><span class="n">qv</span><span class="o">)</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="k">let</span><span class="w"> </span><span class="o">(</span><span class="n">px</span><span class="o">,</span><span class="w"> </span><span class="n">py</span><span class="o">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pv</span>
<span class="w">    </span><span class="k">let</span><span class="w"> </span><span class="o">(</span><span class="n">qx</span><span class="o">,</span><span class="w"> </span><span class="n">qy</span><span class="o">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">qv</span>
<span class="w">    </span><span class="k">member</span><span class="w"> </span><span class="n">v</span><span class="p">.</span><span class="nf">Length</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sqrt</span><span class="o">((</span><span class="n">qx</span><span class="o">-</span><span class="n">px</span><span class="o">)*(</span><span class="n">qx</span><span class="o">-</span><span class="n">px</span><span class="o">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="o">(</span><span class="n">qy</span><span class="o">-</span><span class="n">py</span><span class="o">)*(</span><span class="n">qy</span><span class="o">-</span><span class="n">py</span><span class="o">))</span>
</code></pre></div>
<p>When a primary constructor is evaluated, the inheritance and function and value definitions are
evaluated in order.</p>
<h4 id="8611-object-references-in-primary-constructors">8.6.1.1 Object References in Primary Constructors</h4>
<p>For types that have a primary constructor, the name of the object parameter can be bound and used
in the non-static function, value, and member definitions of the type definition as follows:</p>
<div class="highlight"><pre><span></span><code><span class="k">type</span><span class="w"> </span><span class="nc">X</span><span class="o">(</span><span class="n">a</span><span class="o">:</span><span class="n">int</span><span class="o">)</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="k">let</span><span class="w"> </span><span class="nv">mutable</span><span class="w"> </span><span class="n">currentA</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span>
<span class="w">    </span><span class="k">let</span><span class="w"> </span><span class="nv">mutable</span><span class="w"> </span><span class="n">currentB</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span>
<span class="w">    </span><span class="k">do</span><span class="w"> </span><span class="n">x</span><span class="o">.</span><span class="n">B</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">x</span><span class="o">.</span><span class="n">A</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">3</span>
<span class="w">    </span><span class="k">member</span><span class="w"> </span><span class="n">self</span><span class="p">.</span><span class="nf">GetResult</span><span class="bp">()</span><span class="o">=</span><span class="w"> </span><span class="n">currentA</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">currentB</span>
<span class="w">    </span><span class="k">member</span><span class="w"> </span><span class="n">self</span><span class="p">.</span><span class="nf">A</span><span class="w"> </span><span class="k">with</span><span class="w"> </span><span class="n">get</span><span class="bp">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">currentA</span><span class="w"> </span><span class="ow">and</span><span class="w"> </span><span class="n">set</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">currentA</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">v</span>
<span class="w">    </span><span class="k">member</span><span class="w"> </span><span class="n">self</span><span class="p">.</span><span class="nf">B</span><span class="w"> </span><span class="k">with</span><span class="w"> </span><span class="n">get</span><span class="bp">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">currentB</span><span class="w"> </span><span class="ow">and</span><span class="w"> </span><span class="n">set</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">currentB</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">v</span>
</code></pre></div>
<p>During construction, no member on the type may be called before the last value or function
definition in the type has completed; such a call results in an <code>InvalidOperationException</code>. For
example, the following code raises this exception:</p>
<div class="highlight"><pre><span></span><code><span class="k">type</span><span class="w"> </span><span class="nc">C</span><span class="bp">()</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">self</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="k">let</span><span class="w"> </span><span class="nv">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">(</span><span class="k">fun</span><span class="w"> </span><span class="o">(</span><span class="n">x</span><span class="o">:</span><span class="n">C</span><span class="o">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">x</span><span class="o">.</span><span class="n">F</span><span class="bp">()</span><span class="o">)</span>
<span class="w">    </span><span class="k">let</span><span class="w"> </span><span class="nv">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">self</span>
<span class="w">    </span><span class="k">do</span><span class="w"> </span><span class="n">printfn</span><span class="w"> </span><span class="s">&quot;construct&quot;</span>
<span class="w">    </span><span class="k">member</span><span class="w"> </span><span class="n">this</span><span class="p">.</span><span class="nf">F</span><span class="bp">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">printfn</span><span class="w"> </span><span class="s">&quot;hi, y = %A&quot;</span><span class="w"> </span><span class="n">y</span>

<span class="k">let</span><span class="w"> </span><span class="nv">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">C</span><span class="bp">()</span><span class="w"> </span><span class="c1">// raises InvalidOperationException</span>
</code></pre></div>
<p>The exception is raised because an attempt may be made to access the value of the field <code>y</code> before
initialization is complete.</p>
<h4 id="8612-inheritance-declarations-in-primary-constructors">8.6.1.2 Inheritance Declarations in Primary Constructors</h4>
<p>An <code>inherit</code> declaration specifies that the type being defined is an extension of an existing type. Such
declarations have the following form:</p>
<div class="highlight"><pre><span></span><code>class-inherits-decl := inherit type expr~opt
</code></pre></div>
<p>For example:</p>
<div class="highlight"><pre><span></span><code><span class="k">type</span><span class="w"> </span><span class="nc">MyDerived</span><span class="o">(...)</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="k">inherit</span><span class="w"> </span><span class="n">MyBase</span><span class="o">(...)</span>
</code></pre></div>
<p>If a class definition does not contain an <code>inherit</code> declaration, the class inherits <code>fromSystem.Object</code> by
default.</p>
<p>The <code>inherit</code> declaration for a type must have arguments if and only if the type has a primary
constructor.</p>
<p>Unlike <a href="./#8611-object-references-in-primary-constructors">§8.6.1.1</a>, members of a base type can be accessed during construction of the derived class.
For example, the following code does not raise an exception:</p>
<div class="highlight"><pre><span></span><code><span class="k">type</span><span class="w"> </span><span class="nc">B</span><span class="bp">()</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="k">member</span><span class="w"> </span><span class="n">this</span><span class="p">.</span><span class="nf">G</span><span class="bp">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">printfn</span><span class="w"> </span><span class="s">&quot;hello &quot;</span>

<span class="k">type</span><span class="w"> </span><span class="nc">C</span><span class="bp">()</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">self</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="k">inherit</span><span class="w"> </span><span class="n">B</span><span class="bp">()</span>
<span class="w">    </span><span class="k">let</span><span class="w"> </span><span class="nv">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">(</span><span class="k">fun</span><span class="w"> </span><span class="o">(</span><span class="n">x</span><span class="o">:</span><span class="n">C</span><span class="o">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">x</span><span class="o">.</span><span class="n">G</span><span class="bp">()</span><span class="o">)</span>
<span class="w">    </span><span class="k">let</span><span class="w"> </span><span class="nv">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">self</span>
<span class="w">    </span><span class="k">do</span><span class="w"> </span><span class="n">printfn</span><span class="w"> </span><span class="s">&quot;construct&quot;</span>
<span class="w">    </span><span class="k">member</span><span class="w"> </span><span class="n">this</span><span class="p">.</span><span class="nf">F</span><span class="bp">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">printfn</span><span class="w"> </span><span class="s">&quot;hi, y = %A&quot;</span><span class="w"> </span><span class="n">y</span>

<span class="k">let</span><span class="w"> </span><span class="nv">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">C</span><span class="bp">()</span><span class="w"> </span><span class="c1">// does not raise InvalidOperationException</span>
</code></pre></div>
<h4 id="8613-instance-function-and-value-definitions-in-primary-constructors">8.6.1.3 Instance Function and Value Definitions in Primary Constructors</h4>
<p>Classes that have primary constructors may include function definitions, value definitions, and “do”
statements. The following rules apply to these definitions:</p>
<ul>
<li>
<p>Each definition may be marked <code>static</code> (see <a href="./#8614-static-function-and-value-definitions-in-primary-constructors">§8.6.1.4</a>). If the definition is not marked <code>static</code>, it is
    called an instance definition.</p>
</li>
<li>
<p>The functions and values defined by instance definitions are lexically scoped (and thus implicitly
    private) to the object being defined.</p>
</li>
<li>Each value definition may optionally be marked <code>mutable</code>.</li>
<li>A group of function and value definitions may optionally be marked <code>rec</code>.</li>
<li>Function and value definitions are generalized.</li>
<li>Value definitions that declared in classes are represented in compiled code as follows:</li>
<li>If a value definition is not mutable, and is not used in any function or member, then the
       value is represented as a local value in the object constructor.</li>
<li>If a value definition is mutable, or used in any function or member, then the value is
       represented as an instance field in the corresponding CLI type.</li>
<li>
<p>Function definitions are represented in compiled code as private members of the corresponding
    CLI type.
    For example, consider this type:</p>
<div class="highlight"><pre><span></span><code><span class="w">   </span><span class="k">type</span><span class="w"> </span><span class="nc">C</span><span class="o">(</span><span class="n">x</span><span class="o">:</span><span class="n">int</span><span class="o">,</span><span class="n">y</span><span class="o">:</span><span class="n">int</span><span class="o">)</span><span class="w"> </span><span class="o">=</span>
<span class="w">       </span><span class="k">let</span><span class="w"> </span><span class="nv">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span>
<span class="w">       </span><span class="k">let</span><span class="w"> </span><span class="nv">f</span><span class="w"> </span><span class="n">w</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">w</span>
<span class="w">       </span><span class="k">member</span><span class="w"> </span><span class="n">this</span><span class="p">.</span><span class="nf">Z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">z</span>
<span class="w">       </span><span class="k">member</span><span class="w"> </span><span class="n">this</span><span class="p">.</span><span class="nf">Add</span><span class="o">(</span><span class="n">w</span><span class="o">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">w</span>
</code></pre></div>
</li>
</ul>
<p>The input <code>y</code> is used only during construction, and no field is stored for it. Likewise the function <code>f</code>
is represented as a member rather than a field that is a function value.</p>
<p>A value definition is considered a function definition if its immediate right-hand-side is an
anonymous function, as in this example:</p>
<div class="highlight"><pre><span></span><code><span class="k">let</span><span class="w"> </span><span class="nv">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">(</span><span class="k">fun</span><span class="w"> </span><span class="n">w</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">w</span><span class="o">)</span>
</code></pre></div>
<p>Function and value definitions may have attributes as follows:</p>
<ul>
<li>Value definitions represented as fields may have attributes that target fields.</li>
<li>Value definitions represented as locals may have attributes that target fields, but these
    attributes will not be attached to any construct in the resulting CLI assembly.</li>
<li>Function definitions represented as methods may have attributes that target methods.</li>
</ul>
<p>For example:</p>
<div class="highlight"><pre><span></span><code><span class="k">type</span><span class="w"> </span><span class="nc">C</span><span class="o">(</span><span class="n">x</span><span class="o">:</span><span class="n">int</span><span class="o">)</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="o">[&lt;</span><span class="nn">System</span><span class="p">.</span><span class="n">Obsolete</span><span class="o">&gt;]</span>
<span class="w">    </span><span class="k">let</span><span class="w"> </span><span class="nv">unused</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span>
<span class="w">    </span><span class="k">member</span><span class="w"> </span><span class="n">__</span><span class="p">.</span><span class="nf">P</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span>
</code></pre></div>
<p>In this example, no field is generated for <code>unused</code>, and no corresponding compiled CLI attribute is
generated.</p>
<h4 id="8614-static-function-and-value-definitions-in-primary-constructors">8.6.1.4 Static Function and Value Definitions in Primary Constructors</h4>
<p>Classes that have primary constructors may have function definitions, value definitions, and “do”
statements that are marked as static:</p>
<ul>
<li>The values that are defined by static function and value definitions are lexically scoped (and thus
    implicitly private) to the type being defined.</li>
<li>Each value definition may optionally be marked <code>mutable</code>.</li>
<li>A group of function and value definitions may optionally be marked <code>rec</code>.</li>
<li>Static function and value definitions are generalized.</li>
<li>Static function and value definitions are computed once per generic instantiation.</li>
<li>Static function and value definitions are elaborated to a <em>static initializer</em> associated with each
    generic instantiation of the generated class. Static initializers are executed on demand in the
    same way as static initializers for implementation files <a href="../program-structure-and-execution/#125-program-execution">§12.5</a>.</li>
<li>The compiled representation for static value definitions is as follows:</li>
<li>If the value is not used in any function or member then the value is represented as a local
       value in the CLI class initializer of the type.</li>
<li>If the value is used in any function or member, then the value is represented as a static field
       of the CLI class for the type.</li>
<li>The compiled representation for a static function definition is a private static member of the
    corresponding CLI type.</li>
</ul>
<p>Static function and value definitions may have attributes as follows:</p>
<ul>
<li>Static function and value definitions represented as fields may have attributes that target fields.</li>
<li>Static function and value definitions represented as methods may have attributes that target
    methods.</li>
</ul>
<p>For example:</p>
<div class="highlight"><pre><span></span><code><span class="k">type</span><span class="w"> </span><span class="nc">C</span><span class="o">&lt;</span><span class="k">&#39;</span><span class="n">T</span><span class="o">&gt;</span><span class="bp">()</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="k">let</span><span class="w"> </span><span class="nv">mutable</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="k">do</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="mi">3</span>

<span class="w">    </span><span class="k">member</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="nf">P</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v</span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="k">member</span><span class="w"> </span><span class="n">P2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v</span><span class="o">+</span><span class="n">v</span>

<span class="n">printfn</span><span class="w"> </span><span class="s">&quot;check: %d = 3&quot;</span><span class="w"> </span><span class="o">(</span><span class="k">new</span><span class="w"> </span><span class="n">C</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;</span><span class="bp">()</span><span class="o">).</span><span class="n">P</span>
<span class="n">printfn</span><span class="w"> </span><span class="s">&quot;check: %d = 3&quot;</span><span class="w"> </span><span class="o">(</span><span class="k">new</span><span class="w"> </span><span class="n">C</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;</span><span class="bp">()</span><span class="o">).</span><span class="n">P</span>
<span class="n">printfn</span><span class="w"> </span><span class="s">&quot;check: %d = 3&quot;</span><span class="w"> </span><span class="o">(</span><span class="k">new</span><span class="w"> </span><span class="n">C</span><span class="o">&lt;</span><span class="kt">string</span><span class="o">&gt;</span><span class="bp">()</span><span class="o">).</span><span class="n">P</span>
<span class="n">printfn</span><span class="w"> </span><span class="s">&quot;check: %d = 6&quot;</span><span class="w"> </span><span class="o">(</span><span class="n">C</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;.</span><span class="n">P2</span><span class="o">)</span>
<span class="n">printfn</span><span class="w"> </span><span class="s">&quot;check: %d = 6&quot;</span><span class="w"> </span><span class="o">(</span><span class="n">C</span><span class="o">&lt;</span><span class="kt">string</span><span class="o">&gt;.</span><span class="n">P2</span><span class="o">)</span>
</code></pre></div>
<p>In this example, the value <code>v</code> is represented as a static field in the CLI type for <code>C</code>. One instance of this
field exists for each generic instantiation of <code>C</code>. The output of the program is</p>
<div class="highlight"><pre><span></span><code>check: 3 = 3
check: 3 = 3
check: 3 = 3
check: 6 = 6
check: 6 = 6
</code></pre></div>
<h3 id="862-members-in-classes">8.6.2 Members in Classes</h3>
<p>Class types may declare members (<a href="./#813-members">§8.13</a>), overrides, and interface implementations. As with all
types that have overrides and interface implementations, such class types are subject to <em>Dispatch
Slot Checking</em> (<a href="../inference-procedures/#148-dispatch-slot-checking">§14.8</a>).</p>
<h3 id="863-additional-object-constructors-in-classes">8.6.3 Additional Object Constructors in Classes</h3>
<p>Although the use of primary object constructors is generally preferable, additional object
constructors may also be specified. Additional object constructors are required in two situations:</p>
<ul>
<li>To define classes that have more than one constructor.</li>
<li>To specify explicit <code>val</code> fields without the <code>DefaultValue</code> attribute.</li>
</ul>
<p>For example, the following statement adds a second constructor to a class that has a primary
constructor:</p>
<div class="highlight"><pre><span></span><code><span class="k">type</span><span class="w"> </span><span class="nc">PairOfIntegers</span><span class="o">(</span><span class="n">x</span><span class="o">:</span><span class="n">int</span><span class="o">,</span><span class="n">y</span><span class="o">:</span><span class="n">int</span><span class="o">)</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="k">new</span><span class="w"> </span><span class="o">(</span><span class="n">x</span><span class="o">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PairOfIntegers</span><span class="o">(</span><span class="n">x</span><span class="o">,</span><span class="n">x</span><span class="o">)</span>
</code></pre></div>
<p>The next example declares a class without a primary constructor:</p>
<div class="highlight"><pre><span></span><code><span class="k">type</span><span class="w"> </span><span class="nc">PairOfStrings</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="k">val</span><span class="w"> </span><span class="n">s1</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">string</span>
<span class="w">    </span><span class="k">val</span><span class="w"> </span><span class="n">s2</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">string</span>
<span class="w">    </span><span class="k">new</span><span class="w"> </span><span class="o">(</span><span class="n">s</span><span class="o">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="n">s1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s</span><span class="o">;</span><span class="w"> </span><span class="n">s2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">}</span>
<span class="w">    </span><span class="k">new</span><span class="w"> </span><span class="o">(</span><span class="n">s1</span><span class="o">,</span><span class="n">s2</span><span class="o">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="n">s1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s1</span><span class="o">;</span><span class="w"> </span><span class="n">s2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s2</span><span class="w"> </span><span class="o">}</span>
</code></pre></div>
<p>If a primary constructor is present, additional object constructors must call another object
constructor in the same type, which may be another additional constructor or the primary
constructor.</p>
<p>If no primary constructor is present, additional constructors must initialize any <code>val</code> fields of the
object that do not have the <code>DefaultValue</code> attribute. They must also specify a call to a base class
constructor for any inherited class type. A call to a base class constructor is not required if the base
class is <code>System.Object</code>.</p>
<p>The use of additional object constructors and <code>val</code> fields is required if a class has multiple object
constructors that must each call different base class constructors. For example:</p>
<div class="highlight"><pre><span></span><code><span class="k">type</span><span class="w"> </span><span class="nc">BaseClass</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="k">val</span><span class="w"> </span><span class="n">s1</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">string</span>
<span class="w">    </span><span class="k">new</span><span class="w"> </span><span class="o">(</span><span class="n">s</span><span class="o">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="n">s1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">}</span>
<span class="w">    </span><span class="k">new</span><span class="w"> </span><span class="bp">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;default&quot;</span><span class="w"> </span><span class="o">}</span>

<span class="k">type</span><span class="w"> </span><span class="nc">SubClass</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="k">inherit</span><span class="w"> </span><span class="n">BaseClass</span>
<span class="w">    </span><span class="k">val</span><span class="w"> </span><span class="n">s2</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">string</span>
<span class="w">    </span><span class="k">new</span><span class="w"> </span><span class="o">(</span><span class="n">s1</span><span class="o">,</span><span class="n">s2</span><span class="o">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="k">inherit</span><span class="w"> </span><span class="n">BaseClass</span><span class="o">(</span><span class="n">s1</span><span class="o">);</span><span class="w"> </span><span class="n">s2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s2</span><span class="w"> </span><span class="o">}</span>
<span class="w">    </span><span class="k">new</span><span class="w"> </span><span class="o">(</span><span class="n">s2</span><span class="o">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="k">inherit</span><span class="w"> </span><span class="n">BaseClass</span><span class="bp">()</span><span class="o">;</span><span class="w"> </span><span class="n">s2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s2</span><span class="w"> </span><span class="o">}</span>
</code></pre></div>
<p>To implement additional object constructors, F# uses a restricted subset of expressions that ensure
that the code generated for the constructor is valid according to the rules of object construction for
CLI objects. Note that precisely one <code>additional-constr-init-expr</code> occurs for each branch of a
construction expression.</p>
<p>For classes without a primary constructor, side effects can be performed after the initialization of
the fields of the object by using the <code>additional-constr-expr then stmt</code> form. For example:</p>
<div class="highlight"><pre><span></span><code><span class="k">type</span><span class="w"> </span><span class="nc">PairOfIntegers</span><span class="o">(</span><span class="n">x</span><span class="o">:</span><span class="n">int</span><span class="o">,</span><span class="n">y</span><span class="o">:</span><span class="n">int</span><span class="o">)</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="c1">// This additional constructor has a side effect after initialization.</span>
<span class="w">    </span><span class="k">new</span><span class="o">(</span><span class="n">x</span><span class="o">)</span><span class="w"> </span><span class="o">=</span>
<span class="w">        </span><span class="n">PairOfIntegers</span><span class="o">(</span><span class="n">x</span><span class="o">,</span><span class="w"> </span><span class="n">x</span><span class="o">)</span>
<span class="w">        </span><span class="k">then</span>
<span class="w">            </span><span class="n">printfn</span><span class="w"> </span><span class="s">&quot;Initialized with only one integer&quot;</span>
</code></pre></div>
<p>The name of the object parameter can be bound within additional constructors. For example:</p>
<div class="highlight"><pre><span></span><code><span class="k">type</span><span class="w"> </span><span class="nc">X</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="k">val</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="o">(</span><span class="kt">unit</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">string</span><span class="o">)</span>
<span class="w">    </span><span class="k">val</span><span class="w"> </span><span class="k">mutable</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">string</span>
<span class="w">    </span><span class="k">new</span><span class="bp">()</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">(</span><span class="k">fun</span><span class="w"> </span><span class="bp">()</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">x</span><span class="o">.</span><span class="n">b</span><span class="o">);</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;b&quot;</span><span class="w"> </span><span class="o">}</span>
</code></pre></div>
<p>A warning is given if x occurs syntactically in or before the <code>additional-constr-init-expr</code> of the
construction expression. If any member is called before the completion of execution of the
<code>additional-constr-init-expr</code> within the <code>additional-constr-expr</code> then an <code>InvalidOperationException</code>
is thrown.</p>
<h3 id="864-additional-fields-in-classes">8.6.4 Additional Fields in Classes</h3>
<p>Additional field declarations indicate that a value is stored in an object. They are generally used only
for classes without a primary constructor, or for mutable fields that use default initialization, and
typically occur only in generated code. For example:</p>
<div class="highlight"><pre><span></span><code><span class="k">type</span><span class="w"> </span><span class="nc">PairOfIntegers</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="k">val</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">int</span>
<span class="w">    </span><span class="k">val</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">int</span>
<span class="w">    </span><span class="k">new</span><span class="o">(</span><span class="n">x</span><span class="o">,</span><span class="w"> </span><span class="n">y</span><span class="o">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">{</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="o">;</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">y</span><span class="o">}</span>
</code></pre></div>
<p>The following shows an additional field declaration as a static field in an explicit class type:</p>
<div class="highlight"><pre><span></span><code><span class="k">type</span><span class="w"> </span><span class="nc">TypeWithADefaultMutableBooleanField</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="o">[&lt;</span><span class="n">DefaultValue</span><span class="o">&gt;]</span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="k">val</span><span class="w"> </span><span class="k">mutable</span><span class="w"> </span><span class="n">ready</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">bool</span>
</code></pre></div>
<p>At runtime, such a field is initially assigned the zero value for its type (<a href="../expressions/#693-zero-values">§6.9.3</a>). For example:</p>
<div class="highlight"><pre><span></span><code><span class="k">type</span><span class="w"> </span><span class="nc">MyClass</span><span class="o">(</span><span class="n">name</span><span class="o">:</span><span class="kt">string</span><span class="o">)</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="c1">// Keep a global count. It is initially zero.</span>
<span class="w">    </span><span class="o">[&lt;</span><span class="n">DefaultValue</span><span class="o">&gt;]</span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="k">val</span><span class="w"> </span><span class="k">mutable</span><span class="w"> </span><span class="n">count</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">int</span>

<span class="w">    </span><span class="c1">// Increment the count each time an object is created</span>
<span class="w">    </span><span class="k">do</span><span class="w"> </span><span class="nn">MyClass</span><span class="p">.</span><span class="n">count</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nn">MyClass</span><span class="p">.</span><span class="n">count</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span>

<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="k">member</span><span class="w"> </span><span class="n">NumCreatedObjects</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nn">MyClass</span><span class="p">.</span><span class="n">count</span>

<span class="w">    </span><span class="k">member</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="nf">Name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">name</span>
</code></pre></div>
<p>A <code>val</code> specification in a type that has a primary constructor must be marked mutable and must have
the <code>DefaultValue</code> attribute. For example:</p>
<div class="highlight"><pre><span></span><code><span class="k">type</span><span class="w"> </span><span class="nc">X</span><span class="bp">()</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="o">[&lt;</span><span class="n">DefaultValue</span><span class="o">&gt;]</span>
<span class="w">    </span><span class="k">val</span><span class="w"> </span><span class="k">mutable</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">int</span>
</code></pre></div>
<p>The <code>DefaultValue</code> attribute takes a check parameter, which indicates whether to ensure that the <code>val</code>
specification does not create unexpected <code>null</code> values. The default value for <code>check</code> is <code>true</code>. If this
parameter is <code>true</code>, the type of the field must permit default initialization (<a href="../types-and-type-constraints/#548-nullness">§5.4.8</a>). For example, the
following type is rejected:</p>
<div class="highlight"><pre><span></span><code><span class="k">type</span><span class="w"> </span><span class="nc">MyClass</span><span class="o">&lt;</span><span class="k">&#39;</span><span class="n">T</span><span class="o">&gt;</span><span class="bp">()</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="o">[&lt;</span><span class="n">DefaultValue</span><span class="o">&gt;]</span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="k">val</span><span class="w"> </span><span class="k">mutable</span><span class="w"> </span><span class="n">uninitialized</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">&#39;</span><span class="n">T</span>
</code></pre></div>
<p>The reason is that the type <code>'T</code> does not admit default initialization. However, in compiler-generated
and hand-optimized code it is sometimes essential to be able to emit fields that are completely
uninitialized. In this case, <code>DefaultValue(false)</code> can be used. For example:</p>
<div class="highlight"><pre><span></span><code><span class="k">type</span><span class="w"> </span><span class="nc">MyNullable</span><span class="o">&lt;</span><span class="k">&#39;</span><span class="n">T</span><span class="o">&gt;</span><span class="bp">()</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="o">[&lt;</span><span class="n">DefaultValue</span><span class="o">&gt;]</span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="k">val</span><span class="w"> </span><span class="k">mutable</span><span class="w"> </span><span class="n">ready</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">bool</span>

<span class="w">    </span><span class="o">[&lt;</span><span class="n">DefaultValue</span><span class="o">(</span><span class="k">false</span><span class="o">)&gt;]</span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="k">val</span><span class="w"> </span><span class="k">mutable</span><span class="w"> </span><span class="n">uninitialized</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">&#39;</span><span class="n">T</span>
</code></pre></div>
<h2 id="87-interface-type-definitions">8.7 Interface Type Definitions</h2>
<p>An <em>interface type definition</em> represents a contract that an object may implement. Such a type
definition containsonly abstract members. For example:</p>
<div class="highlight"><pre><span></span><code><span class="k">type</span><span class="w"> </span><span class="nc">IPair</span><span class="o">&lt;</span><span class="k">&#39;</span><span class="n">T</span><span class="o">,</span><span class="k">&#39;</span><span class="n">U</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="k">interface</span>
<span class="w">        </span><span class="k">abstract</span><span class="w"> </span><span class="n">First</span><span class="o">:</span><span class="w"> </span><span class="k">&#39;</span><span class="n">T</span>
<span class="w">        </span><span class="k">abstract</span><span class="w"> </span><span class="n">Second</span><span class="o">:</span><span class="w"> </span><span class="k">&#39;</span><span class="n">U</span>
<span class="w">    </span><span class="k">end</span>

<span class="k">type</span><span class="w"> </span><span class="nc">IThinker</span><span class="o">&lt;</span><span class="k">&#39;</span><span class="n">Thought</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="k">abstract</span><span class="w"> </span><span class="n">Think</span><span class="o">:</span><span class="w"> </span><span class="o">(</span><span class="k">&#39;</span><span class="n">Thought</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">unit</span><span class="o">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">unit</span>
<span class="w">    </span><span class="k">abstract</span><span class="w"> </span><span class="n">StopThinking</span><span class="o">:</span><span class="w"> </span><span class="o">(</span><span class="kt">unit</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">unit</span><span class="o">)</span>
</code></pre></div>
<blockquote>
<p>Note: The <code>interface</code>/<code>end</code> tokens can be omitted when lightweight syntax is used, in
which case Type Kind Inference (<a href="./#82-type-kind-inference">§8.2</a>) is used to determine the kind of the type. The
presence of any non-abstract members or constructors means a type is not an interface
type.
<br>
By convention, interface type names start with <code>I</code>, as in <code>IEvent</code>. However, this convention
is not followed as strictly in F# as in other CLI languages.</p>
</blockquote>
<p>Interface types may be arranged hierarchically by specifying inherit declarations. For example:</p>
<div class="highlight"><pre><span></span><code><span class="k">type</span><span class="w"> </span><span class="nc">IA</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="k">abstract</span><span class="w"> </span><span class="n">One</span><span class="o">:</span><span class="w"> </span><span class="n">int</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">int</span>

<span class="k">type</span><span class="w"> </span><span class="nc">IB</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="k">abstract</span><span class="w"> </span><span class="n">Two</span><span class="o">:</span><span class="w"> </span><span class="n">int</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">int</span>
<span class="k">type</span><span class="w"> </span><span class="nc">IC</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="k">inherit</span><span class="w"> </span><span class="n">IA</span>
<span class="w">    </span><span class="k">inherit</span><span class="w"> </span><span class="n">IB</span>
<span class="w">    </span><span class="k">abstract</span><span class="w"> </span><span class="n">Three</span><span class="o">:</span><span class="w"> </span><span class="n">int</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">int</span>
</code></pre></div>
<p>Each <code>inherit</code> declaration must itself be an interface type. Circular references are not allowed among
<code>inherit</code> declarations. F# uses the named types of the inherited interface types to determine
whether references are circular.</p>
<h2 id="88-struct-type-definitions">8.8 Struct Type Definitions</h2>
<p>A <em>struct type definition</em> is a type definition whose instances are stored inline inside the stack frame or
object of which they are a part. The type is represented as a CLI struct type, also called a <em>value type</em>.
For example:</p>
<div class="highlight"><pre><span></span><code><span class="k">type</span><span class="w"> </span><span class="nc">Complex</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="k">struct</span>
<span class="w">        </span><span class="k">val</span><span class="w"> </span><span class="n">real</span><span class="o">:</span><span class="w"> </span><span class="kt">float</span><span class="o">;</span>
<span class="w">        </span><span class="k">val</span><span class="w"> </span><span class="n">imaginary</span><span class="o">:</span><span class="w"> </span><span class="kt">float</span>
<span class="w">        </span><span class="k">member</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="nf">R</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="o">.</span><span class="n">real</span>
<span class="w">        </span><span class="k">member</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="nf">I</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="o">.</span><span class="n">imaginary</span>
<span class="w">    </span><span class="k">end</span>
</code></pre></div>
<blockquote>
<p>Note: The <code>struct</code>/<code>end</code> tokens can be omitted when lightweight syntax is used, in which
case Type Kind Inference (<a href="./#82-type-kind-inference">§8.2</a>) is used to determine the kind of the type.</p>
</blockquote>
<p>Because structs undergo type kind inference (<a href="./#82-type-kind-inference">§8.2</a>), the following is valid:</p>
<div class="highlight"><pre><span></span><code><span class="o">[&lt;</span><span class="n">Struct</span><span class="o">&gt;]</span>
<span class="k">type</span><span class="w"> </span><span class="nc">Complex</span><span class="o">(</span><span class="n">r</span><span class="o">:</span><span class="kt">float</span><span class="o">,</span><span class="w"> </span><span class="n">i</span><span class="o">:</span><span class="kt">float</span><span class="o">)</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="k">member</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="nf">R</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">r</span>
<span class="w">    </span><span class="k">member</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="nf">I</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span>
</code></pre></div>
<p>Structs may have primary constructors:</p>
<div class="highlight"><pre><span></span><code><span class="o">[&lt;</span><span class="n">Struct</span><span class="o">&gt;]</span>
<span class="k">type</span><span class="w"> </span><span class="nc">Complex</span><span class="o">(</span><span class="n">r</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">float</span><span class="o">,</span><span class="w"> </span><span class="n">I</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">float</span><span class="o">)</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="k">member</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="nf">R</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">r</span>
<span class="w">    </span><span class="k">member</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="nf">I</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span>
</code></pre></div>
<p>Structs that have primary constructors must accept at least one argument.</p>
<p>Structs may have additional constructors. For example:</p>
<div class="highlight"><pre><span></span><code><span class="o">[&lt;</span><span class="n">Struct</span><span class="o">&gt;]</span>
<span class="k">type</span><span class="w"> </span><span class="nc">Complex</span><span class="o">(</span><span class="n">r</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">float</span><span class="o">,</span><span class="w"> </span><span class="n">I</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">float</span><span class="o">)</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="k">member</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="nf">R</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">r</span>
<span class="w">    </span><span class="k">member</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="nf">I</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span>
<span class="w">    </span><span class="k">new</span><span class="o">(</span><span class="n">r</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">float</span><span class="o">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Complex</span><span class="o">(</span><span class="n">r</span><span class="o">,</span><span class="w"> </span><span class="mi">0</span><span class="o">.</span><span class="mi">0</span><span class="o">)</span>
</code></pre></div>
<p>The fields in a struct may be mutable only if the struct does not have a primary constructor. For
example:</p>
<div class="highlight"><pre><span></span><code><span class="o">[&lt;</span><span class="n">Struct</span><span class="o">&gt;]</span>
<span class="k">type</span><span class="w"> </span><span class="nc">MutableComplex</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="k">val</span><span class="w"> </span><span class="k">mutable</span><span class="w"> </span><span class="n">real</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">float</span><span class="o">;</span>
<span class="w">    </span><span class="k">val</span><span class="w"> </span><span class="k">mutable</span><span class="w"> </span><span class="n">imaginary</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">float</span>
<span class="w">    </span><span class="k">member</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="nf">R</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="o">.</span><span class="n">real</span>
<span class="w">    </span><span class="k">member</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="nf">I</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="o">.</span><span class="n">imaginary</span>
<span class="w">    </span><span class="k">member</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="nf">Change</span><span class="o">(</span><span class="n">r</span><span class="o">,</span><span class="w"> </span><span class="n">i</span><span class="o">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="o">.</span><span class="n">real</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">r</span><span class="o">;</span><span class="w"> </span><span class="n">x</span><span class="o">.</span><span class="n">imaginary</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">i</span>
<span class="w">    </span><span class="k">new</span><span class="w"> </span><span class="o">(</span><span class="n">r</span><span class="o">,</span><span class="w"> </span><span class="n">i</span><span class="o">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="n">real</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">r</span><span class="o">;</span><span class="w"> </span><span class="n">imaginary</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">}</span>
</code></pre></div>
<p>Struct types may declare members, overrides, and interface implementations. As for all types that
declare overrides and interface implementations, struct types are subject to <em>Dispatch Slot Checking</em>
(<a href="../inference-procedures/#148-dispatch-slot-checking">§14.8</a>).</p>
<p>Structs may not have <code>inherit</code> declarations.</p>
<p>Structs may not have “let” or “do” statements unless they are static. For example, the following is
not valid:</p>
<div class="highlight"><pre><span></span><code><span class="o">[&lt;</span><span class="n">Struct</span><span class="o">&gt;]</span>
<span class="k">type</span><span class="w"> </span><span class="nc">BadStruct1</span><span class="w"> </span><span class="o">(</span><span class="n">def</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">int</span><span class="o">)</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="k">do</span><span class="w"> </span><span class="nn">System</span><span class="p">.</span><span class="nn">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="o">(</span><span class="s">&quot;Structs cannot use &#39;do&#39;!&quot;</span><span class="o">)</span>
</code></pre></div>
<p>Structs may have static “let” or “do” statements. For example, the following is valid:</p>
<div class="highlight"><pre><span></span><code><span class="o">[&lt;</span><span class="n">Struct</span><span class="o">&gt;]</span>
<span class="k">type</span><span class="w"> </span><span class="nc">GoodStruct1</span><span class="w"> </span><span class="o">(</span><span class="n">def</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">int</span><span class="o">)</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="k">do</span><span class="w"> </span><span class="nn">System</span><span class="p">.</span><span class="nn">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="o">(</span><span class="s">&quot;Structs can use &#39;static do&#39;&quot;</span><span class="o">)</span>
</code></pre></div>
<p>A struct type must be valid according to the CLI rules for structs; in particular, recursively
constructed structs are not permitted. For example, the following type definition is not permitted,
because the size of <code>BadStruct2</code> would be infinite:</p>
<div class="highlight"><pre><span></span><code><span class="o">[&lt;</span><span class="n">Struct</span><span class="o">&gt;]</span>
<span class="k">type</span><span class="w"> </span><span class="nc">BadStruct</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="k">val</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">float</span><span class="o">;</span>
<span class="w">    </span><span class="k">val</span><span class="w"> </span><span class="n">rest</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">BadStruct</span><span class="w"> </span><span class="mi">2</span>
<span class="w">    </span><span class="k">new</span><span class="w"> </span><span class="o">(</span><span class="n">data</span><span class="o">,</span><span class="w"> </span><span class="n">rest</span><span class="o">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data</span><span class="o">;</span><span class="w"> </span><span class="n">rest</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rest</span><span class="w"> </span><span class="o">}</span>
</code></pre></div>
<p>Likewise, the implied size of the following struct would be infinite:</p>
<div class="highlight"><pre><span></span><code><span class="o">[&lt;</span><span class="n">Struct</span><span class="o">&gt;]</span>
<span class="k">type</span><span class="w"> </span><span class="nc">BadStruct</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">(</span><span class="n">data</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">float</span><span class="o">,</span><span class="w"> </span><span class="n">rest</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">BadStruct</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">)</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="k">member</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="nf">Data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data</span>
<span class="w">    </span><span class="k">member</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="nf">Rest</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rest</span>
</code></pre></div>
<p>If the types of all the fields in a struct type permit default initialization, the struct type has an <em>implicit
default constructor</em>, which initializes all the fields to the default value. For example, the <code>Complex</code> type
defined earlier in this section permits default initialization.</p>
<div class="highlight"><pre><span></span><code><span class="o">[&lt;</span><span class="n">Struct</span><span class="o">&gt;]</span>
<span class="k">type</span><span class="w"> </span><span class="nc">Complex</span><span class="o">(</span><span class="n">r</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">float</span><span class="o">,</span><span class="w"> </span><span class="n">I</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">float</span><span class="o">)</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="k">member</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="nf">R</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">r</span>
<span class="w">    </span><span class="k">member</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="nf">I</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span>

<span class="w">    </span><span class="k">new</span><span class="o">(</span><span class="n">r</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">float</span><span class="o">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Complex</span><span class="o">(</span><span class="n">r</span><span class="o">,</span><span class="w"> </span><span class="mi">0</span><span class="o">.</span><span class="mi">0</span><span class="o">)</span>

<span class="k">let</span><span class="w"> </span><span class="nv">zero</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Complex</span><span class="bp">()</span>
</code></pre></div>
<blockquote>
<p>Note : The existence of the implicit default constructor for structs is not recorded in CLI
metadata and is an artifact of the CLI specification and implementation itself. A CLI
implementation permits default constructors for all struct types, although F# does not
permit their direct use for F# struct types unless all field types admit default
initialization. This is similar to the way that F# considers some types to have null as an
abnormal value.
<br>
Public struct types for use from other CLI languages should be designed with the
existence of the default zero-initializing constructor in mind.</p>
</blockquote>
<h2 id="89-enum-type-definitions">8.9 Enum Type Definitions</h2>
<p>Occasionally the need arises to represent a type that compiles as a CLI enumeration type. An <em>enum
type definition</em> has values that are represented by integer constants and has a CLI enumeration as its
compiled form. Enum type definitions are declared by specifying integer constants in a format that is
syntactically similar to a union type definition. For example:</p>
<div class="highlight"><pre><span></span><code><span class="k">type</span><span class="w"> </span><span class="nc">Color</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="o">|</span><span class="w"> </span><span class="n">Red</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span>
<span class="w">    </span><span class="o">|</span><span class="w"> </span><span class="n">Green</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span>
<span class="w">    </span><span class="o">|</span><span class="w"> </span><span class="n">Blue</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span>

<span class="k">let</span><span class="w"> </span><span class="nv">rgb</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">(</span><span class="nn">Color</span><span class="p">.</span><span class="n">Red</span><span class="o">,</span><span class="w"> </span><span class="nn">Color</span><span class="p">.</span><span class="n">Green</span><span class="o">,</span><span class="w"> </span><span class="nn">Color</span><span class="p">.</span><span class="n">Blue</span><span class="o">)</span>

<span class="k">let</span><span class="w"> </span><span class="nv">show</span><span class="o">(</span><span class="n">colorScheme</span><span class="o">)</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="n">colorScheme</span><span class="w"> </span><span class="k">with</span>
<span class="w">    </span><span class="o">|</span><span class="w"> </span><span class="o">(</span><span class="nn">Color</span><span class="p">.</span><span class="n">Red</span><span class="o">,</span><span class="w"> </span><span class="nn">Color</span><span class="p">.</span><span class="n">Green</span><span class="o">,</span><span class="w"> </span><span class="nn">Color</span><span class="p">.</span><span class="n">Blue</span><span class="o">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">printfn</span><span class="w"> </span><span class="s">&quot;RGB in use&quot;</span>
<span class="w">    </span><span class="o">|</span><span class="w"> </span><span class="o">_</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">printfn</span><span class="w"> </span><span class="s">&quot;Unknown color scheme in use&quot;</span>
</code></pre></div>
<p>The example defines the enum type <code>Color</code>, which has the values <code>Red</code>, <code>Green</code>, and <code>Blue</code>, mapped to
the constants <code>0</code>, <code>1</code>, and <code>2</code> respectively. The values are accessed by their qualified names: <code>Color.Red</code>,
<code>Color.Green</code>, and <code>Color.Blue</code>.</p>
<p>Each case must be given a constant value of the same type. The constant values dictate the
<em>underlying type</em> of the enum, and must be one of the following types:</p>
<ul>
<li><code>sbyte</code>, <code>int16</code>, <code>int32</code>, <code>int64</code> , <code>byte</code>, <code>uint16</code>, <code>uint32</code>, <code>uint64</code>, <code>char</code></li>
</ul>
<p>The declaration of an enumeration type in an implementation file has the following effects on the
typing environment:</p>
<ul>
<li>Brings a named type into scope.</li>
<li>Adds the named type to the inferred signature of the containing namespace or module.</li>
</ul>
<p>Enum types coerce to <code>System.Enum</code> and satisfy the <code>enum&lt;underlying-type&gt;</code> constraint for their
underlying type.</p>
<p>Each enum type declaration is implicitly annotated with the <code>RequiresQualifiedAccess</code> attribute and
does not add the tags of the enumeration to the name environment.</p>
<div class="highlight"><pre><span></span><code><span class="k">type</span><span class="w"> </span><span class="nc">Color</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="o">|</span><span class="w"> </span><span class="n">Red</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span>
<span class="w">    </span><span class="o">|</span><span class="w"> </span><span class="n">Green</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span>
<span class="w">    </span><span class="o">|</span><span class="w"> </span><span class="n">Blue</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span>

<span class="k">let</span><span class="w"> </span><span class="nv">red</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Red</span><span class="w"> </span><span class="c1">// not accepted, must use Color.Red</span>
</code></pre></div>
<p>Unlike unions, enumeration types are fundamentally “incomplete,” because CLI enumerations can
be converted to and from their underlying primitive type representation. For example, a <code>Color</code> value
that is not in the above enumeration can be generated by using the <code>enum</code> function from the F#
library:</p>
<div class="highlight"><pre><span></span><code><span class="k">let</span><span class="w"> </span><span class="nv">unknownColor</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">Color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">enum</span><span class="o">&lt;</span><span class="n">Color</span><span class="o">&gt;(</span><span class="mi">7</span><span class="o">)</span>
</code></pre></div>
<p>This statement adds the value named <code>unknownColor</code>, equal to the constant <code>7</code>, to the <code>Color</code>
enumeration.</p>
<h2 id="810-delegate-type-definitions">8.10 Delegate Type Definitions</h2>
<p>Occasionally the need arises to represent a type that compiles as a CLI delegate type. A <em>delegate
type definition</em> has as its values functions that are represented as CLI delegate values. A delegate
type definition is declared by using the <code>delegate</code> keyword with a member signature. For example:</p>
<div class="highlight"><pre><span></span><code><span class="k">type</span><span class="w"> </span><span class="nc">Handler</span><span class="o">&lt;</span><span class="k">&#39;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">delegate</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="kt">obj</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">&#39;</span><span class="n">T</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">unit</span>
</code></pre></div>
<p>Delegates are often used when using Platform Invoke (P/Invoke) to interface with CLI libraries, as in
the following example:</p>
<div class="highlight"><pre><span></span><code><span class="k">type</span><span class="w"> </span><span class="nc">ControlEventHandler</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">delegate</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="n">int</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">bool</span>

<span class="o">[&lt;</span><span class="n">DllImport</span><span class="o">(</span><span class="s">&quot;kernel32.dll&quot;</span><span class="o">)&gt;]</span>
<span class="k">extern</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="n">SetConsoleCtrlHandler</span><span class="o">(</span><span class="n">ControlEventHandler</span><span class="w"> </span><span class="n">callback</span><span class="o">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">add</span><span class="o">)</span>
</code></pre></div>
<h2 id="811-exception-definitions">8.11 Exception Definitions</h2>
<p>An <em>exception definition</em> defines a new way of constructing values of type <code>exn</code> (a type abbreviation for
<code>System.Exception</code>). Exception definitions have the form:</p>
<div class="highlight"><pre><span></span><code>exception ident of type1 * ... * typen
</code></pre></div>
<p>An exception definition has the following effect:</p>
<ul>
<li>The identifier <code>ident</code> can be used to generate values of type <code>exn</code>.</li>
<li>The identifier <code>ident</code> can be used to pattern match on values of type <code>exn</code>.</li>
<li>The definition generates a type with name <code>ident</code> that derives from <code>exn</code>.</li>
</ul>
<p>For example:</p>
<div class="highlight"><pre><span></span><code><span class="k">exception</span><span class="w"> </span><span class="n">Error</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="n">int</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="kt">string</span>
<span class="n">raise</span><span class="w"> </span><span class="o">(</span><span class="n">Error</span><span class="w"> </span><span class="o">(</span><span class="mi">3</span><span class="o">,</span><span class="w"> </span><span class="s">&quot;well that didn&#39;t work did it&quot;</span><span class="o">))</span>

<span class="k">try</span>
<span class="w">    </span><span class="n">raise</span><span class="w"> </span><span class="o">(</span><span class="n">Error</span><span class="w"> </span><span class="o">(</span><span class="mi">3</span><span class="o">,</span><span class="w"> </span><span class="s">&quot;well that didn&#39;t work did it&quot;</span><span class="o">))</span>
<span class="k">with</span>
<span class="w">    </span><span class="o">|</span><span class="w"> </span><span class="n">Error</span><span class="o">(</span><span class="n">sev</span><span class="o">,</span><span class="w"> </span><span class="n">msg</span><span class="o">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">printfn</span><span class="w"> </span><span class="s">&quot;severity = %d, message = %s&quot;</span><span class="w"> </span><span class="n">sev</span><span class="w"> </span><span class="n">msg</span>
</code></pre></div>
<p>The type that corresponds to the exception definition can be used as a type in F# code. For example:</p>
<div class="highlight"><pre><span></span><code><span class="k">let</span><span class="w"> </span><span class="nv">exn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Error</span><span class="w"> </span><span class="o">(</span><span class="mi">3</span><span class="o">,</span><span class="w"> </span><span class="s">&quot;well that didn&#39;t work did it&quot;</span><span class="o">)</span>
<span class="k">let</span><span class="w"> </span><span class="nv">checkException</span><span class="bp">()</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="o">(</span><span class="kt">exn</span><span class="w"> </span><span class="o">:?</span><span class="w"> </span><span class="n">Error</span><span class="o">)</span><span class="w"> </span><span class="k">then</span><span class="w"> </span><span class="n">printfn</span><span class="w"> </span><span class="s">&quot;It is of type Error&quot;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="o">(</span><span class="kt">exn</span><span class="o">.</span><span class="n">GetType</span><span class="bp">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">typeof</span><span class="o">&lt;</span><span class="n">Error</span><span class="o">&gt;)</span><span class="w"> </span><span class="k">then</span><span class="w"> </span><span class="n">printfn</span><span class="w"> </span><span class="s">&quot;Yes, it really is of type Error&quot;</span>
</code></pre></div>
<p>Exception abbreviations may abbreviate existing exception constructors. For example:</p>
<div class="highlight"><pre><span></span><code><span class="k">exception</span><span class="w"> </span><span class="n">ThatWentBadlyWrong</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="kt">string</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">int</span>
<span class="k">exception</span><span class="w"> </span><span class="n">ThatWentWrongBadly</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ThatWentBadlyWrong</span>

<span class="k">let</span><span class="w"> </span><span class="nv">checkForBadDay</span><span class="bp">()</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="nn">System</span><span class="p">.</span><span class="nn">DateTime</span><span class="p">.</span><span class="nn">Today</span><span class="p">.</span><span class="n">DayOfWeek</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nn">System</span><span class="p">.</span><span class="nn">DayOfWeek</span><span class="p">.</span><span class="n">Monday</span><span class="w"> </span><span class="k">then</span>
<span class="w">        </span><span class="n">raise</span><span class="w"> </span><span class="o">(</span><span class="n">ThatWentWrongBadly</span><span class="o">(</span><span class="s">&quot;yes indeed&quot;</span><span class="o">,</span><span class="mi">123</span><span class="o">))</span>
</code></pre></div>
<p>Exception values may also be generated by defining and using classes that extend <code>System.Exception</code>.</p>
<h2 id="812-type-extensions">8.12 Type Extensions</h2>
<p>A <em>type extension</em> associates additional members with an existing type. For example, the following
associates the additional member <code>IsLong</code> with the existing type <code>System.String</code>:</p>
<div class="highlight"><pre><span></span><code><span class="k">type</span><span class="w"> </span><span class="nc">System</span><span class="o">.</span><span class="n">String</span><span class="w"> </span><span class="k">with</span>
<span class="w">    </span><span class="k">member</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="nf">IsLong</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="n">Length</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">1000</span><span class="o">)</span>
</code></pre></div>
<p>Type extensions may be applied to any accessible type definition except those defined by type
abbreviations. For example, to add an extension method to a list type, use <code>'a List</code> because <code>'a list</code>
is a type abbreviation of <code>'a List</code>. For example:</p>
<div class="highlight"><pre><span></span><code><span class="k">type</span><span class="w"> </span><span class="k">&#39;</span><span class="n">a</span><span class="w"> </span><span class="n">List</span><span class="w"> </span><span class="k">with</span>
<span class="w">    </span><span class="k">member</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="nf">GetOrDefault</span><span class="o">(</span><span class="n">n</span><span class="o">)</span><span class="w"> </span><span class="o">=</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">x</span><span class="o">.</span><span class="n">Length</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="k">then</span><span class="w"> </span><span class="n">x</span><span class="o">.[</span><span class="n">n</span><span class="o">]</span>
<span class="w">        </span><span class="k">else</span><span class="w"> </span><span class="nn">Unchecked</span><span class="p">.</span><span class="n">defaultof</span><span class="o">&lt;</span><span class="k">&#39;</span><span class="n">a</span><span class="o">&gt;</span>
<span class="k">let</span><span class="w"> </span><span class="nv">intlst</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">[</span><span class="mi">1</span><span class="o">;</span><span class="w"> </span><span class="mi">2</span><span class="o">;</span><span class="w"> </span><span class="mi">3</span><span class="o">]</span>
<span class="n">intlst</span><span class="o">.</span><span class="n">GetOrDefault</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span><span class="w"> </span><span class="c1">//2</span>
<span class="n">intlst</span><span class="o">.</span><span class="n">GetOrDefault</span><span class="o">(</span><span class="mi">4</span><span class="o">)</span><span class="w"> </span><span class="c1">//0</span>
</code></pre></div>
<p>For an array type, backtick marks can be used to define an extension method to the array type:</p>
<div class="highlight"><pre><span></span><code><span class="k">type</span><span class="w"> </span><span class="k">&#39;</span><span class="n">a</span><span class="w"> </span><span class="n">``[]``</span><span class="w"> </span><span class="k">with</span>
<span class="w">    </span><span class="k">member</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="nf">GetOrDefault</span><span class="o">(</span><span class="n">n</span><span class="o">)</span><span class="w"> </span><span class="o">=</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">x</span><span class="o">.</span><span class="n">Length</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="k">then</span><span class="w"> </span><span class="n">x</span><span class="o">.[</span><span class="n">n</span><span class="o">]</span>
<span class="w">        </span><span class="k">else</span><span class="w"> </span><span class="nn">Unchecked</span><span class="p">.</span><span class="n">defaultof</span><span class="o">&lt;</span><span class="k">&#39;</span><span class="n">a</span><span class="o">&gt;</span>
<span class="k">let</span><span class="w"> </span><span class="nv">arrlist</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">[|</span><span class="w"> </span><span class="mi">1</span><span class="o">;</span><span class="w"> </span><span class="mi">2</span><span class="o">;</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">|]</span>
<span class="n">arrlist</span><span class="o">.</span><span class="n">GetOrDefault</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span><span class="w"> </span><span class="c1">//2</span>
<span class="n">arrlist</span><span class="o">.</span><span class="n">GetOrDefault</span><span class="o">(</span><span class="mi">4</span><span class="o">)</span><span class="w"> </span><span class="c1">//0</span>
</code></pre></div>
<p>A type can have any number of extensions.</p>
<p>If the type extension is in the same module or namespace declaration group as the original type
definition, it is called an <em>intrinsic extension</em>. Members that are defined in intrinsic extensions follow
the same name resolution and other language rules as members that are defined as part of the
original type definition.</p>
<p>If the type extension is not intrinsic, it must be in a module, and it is called an <em>extension member</em>.
Opening a module that contains an extension member extends the name resolution of the dot
syntax for the extended type. That is, extension members are accessible only if the module that
contains the extension is open.</p>
<p>Name resolution for members that are defined in type extensions behaves as follows:</p>
<ul>
<li>In method application resolution (see <a href="../inference-procedures/#144-method-application-resolution">§14.4</a>), regular members (that is, members that are part of
    the original definition of a type, plus intrinsic extensions) are preferred to extension members.</li>
<li>Extension members that are in scope and have the correct name are included in the group of
    members considered for method application resolution (see <a href="../inference-procedures/#144-method-application-resolution">§14.4</a>).</li>
<li>An intrinsic member is always preferred to an extension member. If an extension member has
    the same name and type signature as a member in the original type definition or an inherited
    member, then it will be inaccessible.</li>
</ul>
<p>The following illustrates the definition of one intrinsic and one extension member for the same type:</p>
<div class="highlight"><pre><span></span><code><span class="k">namespace</span><span class="w"> </span><span class="n">Numbers</span>
<span class="k">type</span><span class="w"> </span><span class="nc">Complex</span><span class="o">(</span><span class="n">r</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">float</span><span class="o">,</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">float</span><span class="o">)</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="k">member</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="nf">R</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">r</span>
<span class="w">    </span><span class="k">member</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="nf">I</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span>

<span class="c1">// intrinsic extension</span>
<span class="k">type</span><span class="w"> </span><span class="nc">Complex</span><span class="w"> </span><span class="k">with</span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="k">member</span><span class="w"> </span><span class="n">Create</span><span class="o">(</span><span class="n">a</span><span class="o">,</span><span class="w"> </span><span class="n">b</span><span class="o">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Complex</span><span class="w"> </span><span class="o">(</span><span class="n">a</span><span class="o">,</span><span class="w"> </span><span class="n">b</span><span class="o">)</span>
<span class="w">    </span><span class="k">member</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="nf">RealPart</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="o">.</span><span class="n">R</span>
<span class="w">    </span><span class="k">member</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="nf">ImaginaryPart</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="o">.</span><span class="n">I</span>

<span class="k">namespace</span><span class="w"> </span><span class="n">Numbers</span>

<span class="k">module</span><span class="w"> </span><span class="nn">ComplexExtensions</span><span class="w"> </span><span class="o">=</span>

<span class="w">    </span><span class="c1">// extension member</span>
<span class="w">    </span><span class="k">type</span><span class="w"> </span><span class="nc">Numbers</span><span class="o">.</span><span class="n">Complex</span><span class="w"> </span><span class="k">with</span>
<span class="w">        </span><span class="k">member</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="nf">Magnitude</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">...</span>
<span class="w">        </span><span class="k">member</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="nf">Phase</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">...</span>
</code></pre></div>
<p>Extensions may define both instance members and static members.</p>
<p>Extensions are checked as follows:</p>
<ul>
<li>Checking applies to the member definitions in an extension together with the members and
    other definitions in the group of type definitions of which the extension is a part.</li>
<li>Two intrinsic extensions may not contain conflicting members because intrinsic extensions are
    considered part of the definition of the type.</li>
<li>Extensions may not define fields, interfaces, abstract slots, inherit declarations, or dispatch slot
    (interface and override) implementations.</li>
<li>Extension members must be in modules.</li>
<li>Extension members are compiled as CLI static members with encoded names.</li>
<li>The elaborated form of an application of a static extension member <code>C.M(arg1, ..., argn)</code> is a call
       to this static member with arguments <code>arg1, ..., argn</code>.</li>
<li>The elaborated form of an application of an instance extension member <code>obj.M(arg1, ..., argn)</code>
       is an invocation of the static instance member where the object parameter is supplied as the
       first argument to the extension member followed by arguments <code>arg1 ... argn</code>.</li>
</ul>
<h3 id="8121-imported-cli-c-extensions-members">8.12.1 Imported CLI C# Extensions Members</h3>
<p>The CLI C# language defines an “extension member,” which commonly occurs in CLI libraries, along
with some other CLI languages. C# limits extension members to instance methods.</p>
<p>C#-defined extension members are made available to F# code in environments where the C#-
authored assembly is referenced and an <code>open</code> declaration of the corresponding namespace is in
effect.</p>
<p>The encoding of compiled names for F# extension members is not compatible with C# encodings of
C# extension members. However, for instance extension methods, the naming can be made
compatible. For example:</p>
<div class="highlight"><pre><span></span><code><span class="k">open</span><span class="w"> </span><span class="nn">System.Runtime.CompilerServices</span>

<span class="o">[&lt;</span><span class="n">Extension</span><span class="o">&gt;]</span>
<span class="k">module</span><span class="w"> </span><span class="nn">EnumerableExtensions</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="o">[&lt;</span><span class="n">CompiledName</span><span class="o">(</span><span class="s">&quot;OutputAll&quot;</span><span class="o">);</span><span class="w"> </span><span class="n">Extension</span><span class="o">&gt;]</span>
<span class="w">    </span><span class="k">type</span><span class="w"> </span><span class="nc">System</span><span class="o">.</span><span class="n">Collections</span><span class="o">.</span><span class="n">Generic</span><span class="o">.</span><span class="n">IEnumerable</span><span class="o">&lt;</span><span class="k">&#39;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="k">with</span>
<span class="w">        </span><span class="k">member</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="nf">OutputAll</span><span class="w"> </span><span class="o">(</span><span class="n">this</span><span class="o">:</span><span class="n">seq</span><span class="o">&lt;</span><span class="k">&#39;</span><span class="n">T</span><span class="o">&gt;)</span><span class="w"> </span><span class="o">=</span>
<span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">this</span><span class="w"> </span><span class="k">do</span>
<span class="w">                </span><span class="nn">System</span><span class="p">.</span><span class="nn">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="w"> </span><span class="o">(</span><span class="n">box</span><span class="w"> </span><span class="n">x</span><span class="o">)</span>
</code></pre></div>
<p>C#-style extension members may also be declared directly in F#. When combined with the “inline”
feature of F#, this allows the definition of generic, constrained extension members that are not
otherwise definable in C# or F#.</p>
<div class="highlight"><pre><span></span><code><span class="o">[&lt;</span><span class="n">Extension</span><span class="o">&gt;]</span>
<span class="k">type</span><span class="w"> </span><span class="nc">ExtraCSharpStyleExtensionMethodsInFSharp</span><span class="w"> </span><span class="bp">()</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="o">[&lt;</span><span class="n">Extension</span><span class="o">&gt;]</span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="k">member</span><span class="w"> </span><span class="k">inline</span><span class="w"> </span><span class="n">Sum</span><span class="o">(</span><span class="n">xs</span><span class="o">:</span><span class="w"> </span><span class="n">seq</span><span class="o">&lt;</span><span class="k">&#39;</span><span class="n">T</span><span class="o">&gt;)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nn">Seq</span><span class="p">.</span><span class="n">sum</span><span class="w"> </span><span class="n">xs</span>
</code></pre></div>
<p>Such an extension member can be used as follows:</p>
<div class="highlight"><pre><span></span><code><span class="k">let</span><span class="w"> </span><span class="nv">listOfIntegers</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">[</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">..</span><span class="w"> </span><span class="mi">100</span><span class="w"> </span><span class="o">]</span>
<span class="k">let</span><span class="w"> </span><span class="nv">listOfBigIntegers</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">[</span><span class="w"> </span><span class="mi">1I</span><span class="w"> </span><span class="o">..</span><span class="w"> </span><span class="mi">100I</span><span class="w"> </span><span class="o">]</span>
<span class="n">listOfIntegers</span><span class="o">.</span><span class="n">Sum</span><span class="bp">()</span>
<span class="n">listOfBigIntegers</span><span class="o">.</span><span class="n">Sum</span><span class="bp">()</span>
</code></pre></div>
<h2 id="813-members">8.13 Members</h2>
<p>Member definitions describe functions that are associated with type definitions and/or values of
particular types. Member definitions can be used in type definitions. Members can be classified as
follows:</p>
<ul>
<li>Property members</li>
<li>Method members</li>
</ul>
<p>A <em>static member</em> is prefixed by <code>static</code> and is associated with the type, rather than with any particular
object. Here are some examples of static members:</p>
<div class="highlight"><pre><span></span><code><span class="k">type</span><span class="w"> </span><span class="nc">MyClass</span><span class="bp">()</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="k">let</span><span class="w"> </span><span class="nv">mutable</span><span class="w"> </span><span class="n">adjustableStaticValue</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;3&quot;</span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="k">let</span><span class="w"> </span><span class="nv">staticArray</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">[|</span><span class="w"> </span><span class="s">&quot;A&quot;</span><span class="o">;</span><span class="w"> </span><span class="s">&quot;B&quot;</span><span class="w"> </span><span class="o">|]</span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="k">let</span><span class="w"> </span><span class="nv">staticArray2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">[|[|</span><span class="w"> </span><span class="s">&quot;A&quot;</span><span class="o">;</span><span class="w"> </span><span class="s">&quot;B&quot;</span><span class="w"> </span><span class="o">|];</span><span class="w"> </span><span class="o">[|</span><span class="w"> </span><span class="s">&quot;A&quot;</span><span class="o">;</span><span class="w"> </span><span class="s">&quot;B&quot;</span><span class="w"> </span><span class="o">|]</span><span class="w"> </span><span class="o">|]</span>

<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="k">member</span><span class="w"> </span><span class="n">StaticMethod</span><span class="o">(</span><span class="n">y</span><span class="o">:</span><span class="n">int</span><span class="o">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span>

<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="k">member</span><span class="w"> </span><span class="n">StaticProperty</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">staticArray</span><span class="o">.</span><span class="n">Length</span>

<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="k">member</span><span class="w"> </span><span class="n">StaticProperty2</span>
<span class="w">        </span><span class="k">with</span><span class="w"> </span><span class="n">get</span><span class="bp">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">staticArray</span><span class="o">.</span><span class="n">Length</span>

<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="k">member</span><span class="w"> </span><span class="n">MutableStaticProperty</span>
<span class="w">        </span><span class="k">with</span><span class="w"> </span><span class="n">get</span><span class="bp">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">adjustableStaticValue</span>
<span class="w">        </span><span class="ow">and</span><span class="w"> </span><span class="n">set</span><span class="o">(</span><span class="n">v</span><span class="o">:</span><span class="kt">string</span><span class="o">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">adjustableStaticValue</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">v</span>

<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="k">member</span><span class="w"> </span><span class="n">StaticIndexer</span>
<span class="w">        </span><span class="k">with</span><span class="w"> </span><span class="n">get</span><span class="o">(</span><span class="n">idx</span><span class="o">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">staticArray</span><span class="o">.[</span><span class="n">idx</span><span class="o">]</span>

<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="k">member</span><span class="w"> </span><span class="n">StaticIndexer2</span>
<span class="w">        </span><span class="k">with</span><span class="w"> </span><span class="n">get</span><span class="o">(</span><span class="n">idx1</span><span class="o">,</span><span class="n">idx2</span><span class="o">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">staticArray2</span><span class="o">.[</span><span class="n">idx1</span><span class="o">].[</span><span class="n">idx2</span><span class="o">]</span>

<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="k">member</span><span class="w"> </span><span class="n">MutableStaticIndexer</span>
<span class="w">        </span><span class="k">with</span><span class="w"> </span><span class="n">get</span><span class="w"> </span><span class="o">(</span><span class="n">idx1</span><span class="o">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">staticArray</span><span class="o">.[</span><span class="n">idx1</span><span class="o">]</span>
<span class="w">        </span><span class="ow">and</span><span class="w"> </span><span class="n">set</span><span class="w"> </span><span class="o">(</span><span class="n">idx1</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">v</span><span class="o">:</span><span class="kt">string</span><span class="o">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">staticArray</span><span class="o">.[</span><span class="n">idx1</span><span class="o">]</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">v</span>
</code></pre></div>
<p>An <em>instance member</em> is a member without <code>static</code>. Here are some examples of instance members:</p>
<div class="highlight"><pre><span></span><code><span class="k">type</span><span class="w"> </span><span class="nc">MyClass</span><span class="bp">()</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="k">let</span><span class="w"> </span><span class="nv">mutable</span><span class="w"> </span><span class="n">adjustableInstanceValue</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;3&quot;</span>
<span class="w">    </span><span class="k">let</span><span class="w"> </span><span class="nv">instanceArray</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">[|</span><span class="w"> </span><span class="s">&quot;A&quot;</span><span class="o">;</span><span class="w"> </span><span class="s">&quot;B&quot;</span><span class="w"> </span><span class="o">|]</span>
<span class="w">    </span><span class="k">let</span><span class="w"> </span><span class="nv">instanceArray2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">[|</span><span class="w"> </span><span class="o">[|</span><span class="w"> </span><span class="s">&quot;A&quot;</span><span class="o">;</span><span class="w"> </span><span class="s">&quot;B&quot;</span><span class="w"> </span><span class="o">|];</span><span class="w"> </span><span class="o">[|</span><span class="w"> </span><span class="s">&quot;A&quot;</span><span class="o">;</span><span class="w"> </span><span class="s">&quot;B&quot;</span><span class="w"> </span><span class="o">|]</span><span class="w"> </span><span class="o">|]</span>

<span class="w">    </span><span class="k">member</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="nf">InstanceMethod</span><span class="o">(</span><span class="n">y</span><span class="o">:</span><span class="n">int</span><span class="o">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">instanceArray</span><span class="o">.</span><span class="n">Length</span>

<span class="w">    </span><span class="k">member</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="nf">InstanceProperty</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">instanceArray</span><span class="o">.</span><span class="n">Length</span>

<span class="w">    </span><span class="k">member</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="nf">InstanceProperty2</span>
<span class="w">        </span><span class="k">with</span><span class="w"> </span><span class="n">get</span><span class="w"> </span><span class="bp">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">instanceArray</span><span class="o">.</span><span class="n">Length</span>

<span class="w">    </span><span class="k">member</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="nf">InstanceIndexer</span>
<span class="w">        </span><span class="k">with</span><span class="w"> </span><span class="n">get</span><span class="w"> </span><span class="o">(</span><span class="n">idx</span><span class="o">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">instanceArray</span><span class="o">.[</span><span class="n">idx</span><span class="o">]</span>

<span class="w">    </span><span class="k">member</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="nf">InstanceIndexer2</span>
<span class="w">        </span><span class="k">with</span><span class="w"> </span><span class="n">get</span><span class="w"> </span><span class="o">(</span><span class="n">idx1</span><span class="o">,</span><span class="n">idx2</span><span class="o">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">instanceArray2</span><span class="o">.[</span><span class="n">idx1</span><span class="o">].[</span><span class="n">idx2</span><span class="o">]</span>

<span class="w">    </span><span class="k">member</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="nf">MutableInstanceProperty</span>
<span class="w">        </span><span class="k">with</span><span class="w"> </span><span class="n">get</span><span class="w"> </span><span class="bp">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">adjustableInstanceValue</span>
<span class="w">        </span><span class="ow">and</span><span class="w"> </span><span class="n">set</span><span class="w"> </span><span class="o">(</span><span class="n">v</span><span class="o">:</span><span class="kt">string</span><span class="o">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">adjustableInstanceValue</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">v</span>

<span class="w">    </span><span class="k">member</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="nf">MutableInstanceIndexer</span>
<span class="w">        </span><span class="k">with</span><span class="w"> </span><span class="n">get</span><span class="w"> </span><span class="o">(</span><span class="n">idx1</span><span class="o">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">instanceArray</span><span class="o">.[</span><span class="n">idx1</span><span class="o">]</span>
<span class="w">        </span><span class="ow">and</span><span class="w"> </span><span class="n">set</span><span class="w"> </span><span class="o">(</span><span class="n">idx1</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">v</span><span class="o">:</span><span class="kt">string</span><span class="o">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">instanceArray</span><span class="o">.[</span><span class="n">idx1</span><span class="o">]</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">v</span>
</code></pre></div>
<p>Members from a set of mutually recursive type definitions are checked as a single mutually recursive
group. As with collections of recursive functions, recursive calls to potentially-generic methods may
result in inconsistent type constraints:</p>
<div class="highlight"><pre><span></span><code><span class="k">type</span><span class="w"> </span><span class="nc">Test</span><span class="bp">()</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="k">member</span><span class="w"> </span><span class="n">Id</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span>
<span class="w">    </span><span class="k">member</span><span class="w"> </span><span class="n">t</span><span class="p">.</span><span class="nf">M1</span><span class="w"> </span><span class="o">(</span><span class="n">x</span><span class="o">:</span><span class="w"> </span><span class="n">int</span><span class="o">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nn">Test</span><span class="p">.</span><span class="n">Id</span><span class="o">(</span><span class="n">x</span><span class="o">)</span>
<span class="w">    </span><span class="k">member</span><span class="w"> </span><span class="n">t</span><span class="p">.</span><span class="nf">M2</span><span class="w"> </span><span class="o">(</span><span class="n">x</span><span class="o">:</span><span class="w"> </span><span class="kt">string</span><span class="o">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nn">Test</span><span class="p">.</span><span class="n">Id</span><span class="o">(</span><span class="n">x</span><span class="o">)</span><span class="w"> </span><span class="c1">// error, x has type &#39;string&#39; not &#39;int&#39;</span>
</code></pre></div>
<p>A target method that has a full type annotation is eligible for early generalization (<a href="../inference-procedures/#1467-generalization">§14.6.7</a>).</p>
<div class="highlight"><pre><span></span><code><span class="k">type</span><span class="w"> </span><span class="nc">Test</span><span class="bp">()</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="k">member</span><span class="w"> </span><span class="n">Id</span><span class="o">&lt;</span><span class="k">&#39;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="o">(</span><span class="n">x</span><span class="o">:</span><span class="k">&#39;</span><span class="n">T</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">&#39;</span><span class="n">T</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span>
<span class="w">    </span><span class="k">member</span><span class="w"> </span><span class="n">t</span><span class="p">.</span><span class="nf">M1</span><span class="w"> </span><span class="o">(</span><span class="n">x</span><span class="o">:</span><span class="w"> </span><span class="n">int</span><span class="o">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nn">Test</span><span class="p">.</span><span class="n">Id</span><span class="o">(</span><span class="n">x</span><span class="o">)</span>
<span class="w">    </span><span class="k">member</span><span class="w"> </span><span class="n">t</span><span class="p">.</span><span class="nf">M2</span><span class="w"> </span><span class="o">(</span><span class="n">x</span><span class="o">:</span><span class="w"> </span><span class="kt">string</span><span class="o">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nn">Test</span><span class="p">.</span><span class="n">Id</span><span class="o">(</span><span class="n">x</span><span class="o">)</span>
</code></pre></div>
<h3 id="8131-property-members">8.13.1 Property Members</h3>
<p>A <em>property member</em> is a <code>method-or-prop-defn</code> in one of the following forms:</p>
<div class="highlight"><pre><span></span><code>static~opt member ident.~opt ident = expr
static~opt member ident.~opt ident with get pat = expr
static~opt member ident.~opt ident with set pat~opt pat = expr
static~opt member ident.~opt ident with get pat = expr and set pat~opt pat = expr
static~opt member ident.~opt ident with set pat~opt pat = expr and get pat = expr
</code></pre></div>
<p>A property member in the form</p>
<div class="highlight"><pre><span></span><code>static~opt member ident.~opt ident with get pat1 = expr1 and set pat2a pat2b~opt = expr2
</code></pre></div>
<p>is equivalent to two property members of the form:</p>
<div class="highlight"><pre><span></span><code>static~opt member ident.~opt ident with get pat1 = expr1
static~opt member ident.~opt ident with set pat2a pat2b~opt = expr2
</code></pre></div>
<p>Furthermore, the following two members are equivalent:</p>
<div class="highlight"><pre><span></span><code>static~opt member ident.~opt ident = expr
static~opt member ident.~opt ident with get() = expr
</code></pre></div>
<p>These two are also equivalent:</p>
<div class="highlight"><pre><span></span><code>static~opt member ident.~opt ident with set pat = expr
static~opt member ident.~opt ident with set() pat = expr
</code></pre></div>
<p>Thus, property members may be reduced to the following two forms:</p>
<div class="highlight"><pre><span></span><code>static~opt member ident.~opt ident with get patidx = expr
static~opt member ident.~opt ident with set patidx pat = expr
</code></pre></div>
<p>The <code>ident.~opt</code> must be present if and only if the property member is an instance member. When
evaluated, the identifier <code>ident</code> is bound to the “this” or “self” object parameter that is associated
with the object within the expression <code>expr</code>.</p>
<p>A property member is an <em>indexer property</em> if <code>patidx</code> is not the unit pattern <code>()</code>. Indexer properties
called <code>Item</code> are special in the sense that they are accessible via the <code>.[]</code> notation. An <code>Item</code> property
that takes one argument is accessed by using <code>x.[i]</code>; with two arguments by <code>x.[i,j]</code>, and so on.
Setter properties must return type <code>unit</code>.</p>
<blockquote>
<p>Note : As of F# 3. 1 , the special <code>.[]</code> notation for <code>Item</code> properties is available only for
instance members. A static indexer property cannot be accessible by using the <code>.[]</code>
notation.</p>
</blockquote>
<p>Property members may be declared <code>abstract</code>. If a property has both a getter and a setter, then both
must be abstract or neither must be abstract.</p>
<p>Each property member has an implied property type. The property type is the type of the value that
the getter property returns or the setter property accepts. If a property member has both a getter
and a setter, and neither is an indexer property, the signatures of both the getter and the setter
must imply the same property type.</p>
<p>Static and instance property members are evaluated every time the member is invoked. For
example, in the following, the body of the member is evaluated each time <code>C.Time</code> is evaluated:</p>
<div class="highlight"><pre><span></span><code><span class="k">type</span><span class="w"> </span><span class="nc">C</span><span class="w"> </span><span class="bp">()</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="k">member</span><span class="w"> </span><span class="n">Time</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nn">System</span><span class="p">.</span><span class="nn">DateTime</span><span class="p">.</span><span class="n">Now</span>
</code></pre></div>
<p>Note that a static property member may also be written with an explicit <code>get</code> method:</p>
<div class="highlight"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="k">member</span><span class="w"> </span><span class="n">ComputerName</span>
<span class="w">    </span><span class="k">with</span><span class="w"> </span><span class="n">get</span><span class="bp">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nn">System</span><span class="p">.</span><span class="nn">Environment</span><span class="p">.</span><span class="n">GetEnvironmentVariable</span><span class="o">(</span><span class="s">&quot;COMPUTERNAME&quot;</span><span class="o">)</span>
</code></pre></div>
<p>Property members that have the same name may not appear in the same type definition even if
their signatures are different. For example:</p>
<div class="highlight"><pre><span></span><code><span class="k">type</span><span class="w"> </span><span class="nc">C</span><span class="w"> </span><span class="bp">()</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="k">member</span><span class="w"> </span><span class="n">P</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">false</span><span class="w"> </span><span class="c1">// error: Duplicate property.</span>
<span class="w">    </span><span class="k">member</span><span class="w"> </span><span class="n">this</span><span class="p">.</span><span class="nf">P</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">true</span>
</code></pre></div>
<p>However, methods that have the same name can be overloaded when their signatures are different.</p>
<h3 id="8132-auto-implemented-properties">8.13.2 Auto-implemented Properties</h3>
<p>Properties can be declared in two ways: either explicitly specified with the underlying value or
automatically generated by the compiler. The compiler creates a backing field automatically if all of
the following are true for the declaration:</p>
<ul>
<li>The declaration uses the <code>member val</code> keywords.</li>
<li>The declaration omits the self-identifier.</li>
<li>The declaration includes an expression to initialize the property.</li>
</ul>
<p>To create a mutable property, include <code>with get</code>, <code>with set</code>,or both:</p>
<div class="highlight"><pre><span></span><code>static~opt member val access~opt ident : ty~opt = expr
static~opt member val access~opt ident : ty~opt = expr with get
static~opt member val access~opt ident : ty~opt = expr with set
static~opt member val access~opt ident : ty~opt = expr with get, set
</code></pre></div>
<p>Automatically implemented properties are part of the initialization of a type, so they must be
included before any other member definitions, in the same way as let bindings and do bindings in a
type definition. The expression that initializes an automatically implemented property is evaluated
only at initialization, and not every time the property is accessed. This behavior is different from the
behavior of an explicitly implemented property.</p>
<p>For example, the following class type includes two automatically implemented properties. <code>Property1</code>
is read-only and is initialized to the argument provided to the primary constructor and <code>Property2</code> is a
settable property that is initialized to an empty string:</p>
<div class="highlight"><pre><span></span><code><span class="k">type</span><span class="w"> </span><span class="nc">D</span><span class="w"> </span><span class="o">(</span><span class="n">x</span><span class="o">:</span><span class="n">int</span><span class="o">)</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="k">member</span><span class="w"> </span><span class="k">val</span><span class="w"> </span><span class="n">Property1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span>
<span class="w">    </span><span class="k">member</span><span class="w"> </span><span class="k">val</span><span class="w"> </span><span class="n">Property2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="w"> </span><span class="k">with</span><span class="w"> </span><span class="n">get</span><span class="o">,</span><span class="w"> </span><span class="n">set</span>
</code></pre></div>
<p>Auto-implemented properties can also be used to implement default or override properties:</p>
<div class="highlight"><pre><span></span><code><span class="k">type</span><span class="w"> </span><span class="nc">MyBase</span><span class="w"> </span><span class="bp">()</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="k">abstract</span><span class="w"> </span><span class="n">Property</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">string</span><span class="w"> </span><span class="k">with</span><span class="w"> </span><span class="n">get</span><span class="o">,</span><span class="w"> </span><span class="n">set</span>
<span class="w">    </span><span class="k">default</span><span class="w"> </span><span class="k">val</span><span class="w"> </span><span class="n">Property</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="err">“</span><span class="k">default</span><span class="err">”</span><span class="w"> </span><span class="k">with</span><span class="w"> </span><span class="n">get</span><span class="o">,</span><span class="w"> </span><span class="n">set</span>

<span class="k">type</span><span class="w"> </span><span class="nc">MyDerived</span><span class="bp">()</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="k">inherit</span><span class="w"> </span><span class="n">MyBase</span><span class="bp">()</span>
<span class="w">    </span><span class="k">override</span><span class="w"> </span><span class="k">val</span><span class="w"> </span><span class="n">Property</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;derived&quot;</span><span class="w"> </span><span class="k">with</span><span class="w"> </span><span class="n">get</span><span class="o">,</span><span class="w"> </span><span class="n">set</span>
</code></pre></div>
<p>The following example shows how to use an auto-implemented property to implement an interface:</p>
<div class="highlight"><pre><span></span><code><span class="k">type</span><span class="w"> </span><span class="nc">MyInterface</span><span class="w"> </span><span class="bp">()</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="k">abstract</span><span class="w"> </span><span class="n">Property</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">string</span><span class="w"> </span><span class="k">with</span><span class="w"> </span><span class="n">get</span><span class="o">,</span><span class="w"> </span><span class="n">set</span>

<span class="k">type</span><span class="w"> </span><span class="nc">MyImplementation</span><span class="w"> </span><span class="bp">()</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="k">interface</span><span class="w"> </span><span class="n">MyInterface</span><span class="w"> </span><span class="k">with</span>
<span class="w">        </span><span class="k">member</span><span class="w"> </span><span class="k">val</span><span class="w"> </span><span class="n">Property</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;implemented&quot;</span><span class="w"> </span><span class="k">with</span><span class="w"> </span><span class="n">get</span><span class="o">,</span><span class="w"> </span><span class="n">set</span>
</code></pre></div>
<h3 id="8133-method-members">8.13.3 Method Members</h3>
<p>A <em>method member</em> is of the form:</p>
<div class="highlight"><pre><span></span><code>static~opt member ident.~opt ident pat1 ... patn = expr
</code></pre></div>
<p>The <code>ident.~opt</code> can be present if and only if the property member is an instance member. In this case,
the identifier <code>ident</code> corresponds to the “this” (or “self”) variable associated with the object on which
the member is being invoked.</p>
<p>Arity analysis (<a href="../inference-procedures/#1411-arity-inference">§14.11</a>) applies to method members. This is because F# members must compile to CLI
methods, which accept only a single fixed collection of arguments.</p>
<h3 id="8134-curried-method-members">8.13.4 Curried Method Members</h3>
<p>Methods that take multiple arguments may be written in iterated (“curried”) form. For example:</p>
<div class="highlight"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="k">member</span><span class="w"> </span><span class="n">StaticMethod2</span><span class="w"> </span><span class="n">s1</span><span class="w"> </span><span class="n">s2</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="n">sprintf</span><span class="w"> </span><span class="s">&quot;In StaticMethod(%s,%s)&quot;</span><span class="w"> </span><span class="n">s1</span><span class="w"> </span><span class="n">s2</span>
</code></pre></div>
<p>The rules of arity analysis (<a href="../inference-procedures/#1411-arity-inference">§14.11</a>) determine the compiled form of these members.</p>
<p>The following limitations apply to curried method members:</p>
<ul>
<li>Additional argument groups may not include optional or byref parameters.</li>
<li>When the member is called, additional argument groups may not use named
    arguments(<a href="./#8135-named-arguments-to-method-members">§8.13.5</a>).</li>
<li>Curried members may not be overloaded.</li>
</ul>
<p>The compiled representation of a curried method member is a .NET method in which the arguments
are concatenated into a single argument group.</p>
<blockquote>
<p>Note : It is recommended that curried argument members do not appear in the public
API of an F# assembly that is designed for use from other .NET languages. Information
about the currying order is not visible to these languages.</p>
</blockquote>
<h3 id="8135-named-arguments-to-method-members">8.13.5 Named Arguments to Method Members</h3>
<p>Calls to methods—but not to let-bound functions or function values—may use named arguments.
For example:</p>
<div class="highlight"><pre><span></span><code><span class="nn">System</span><span class="p">.</span><span class="nn">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="o">(</span><span class="n">format</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;Hello {0}&quot;</span><span class="o">,</span><span class="w"> </span><span class="n">arg0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;World&quot;</span><span class="o">)</span>
<span class="nn">System</span><span class="p">.</span><span class="nn">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="o">(</span><span class="s">&quot;Hello {0}&quot;</span><span class="o">,</span><span class="w"> </span><span class="n">arg0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;World&quot;</span><span class="o">)</span>
<span class="nn">System</span><span class="p">.</span><span class="nn">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="o">(</span><span class="n">arg0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;World&quot;</span><span class="o">,</span><span class="w"> </span><span class="n">format</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;Hello {0}&quot;</span><span class="o">)</span>
</code></pre></div>
<p>The argument names that are associated with a method declaration are derived from the names
that appear in the first pattern of a member definition, or from the names used in the signature for a
method member. For example:</p>
<div class="highlight"><pre><span></span><code><span class="k">type</span><span class="w"> </span><span class="nc">C</span><span class="bp">()</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="k">member</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="nf">Swap</span><span class="o">(</span><span class="n">first</span><span class="o">,</span><span class="w"> </span><span class="n">second</span><span class="o">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">(</span><span class="n">second</span><span class="o">,</span><span class="w"> </span><span class="n">first</span><span class="o">)</span>
<span class="k">let</span><span class="w"> </span><span class="nv">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">C</span><span class="bp">()</span>
<span class="n">c</span><span class="o">.</span><span class="n">Swap</span><span class="o">(</span><span class="n">first</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="o">,</span><span class="n">second</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="o">)</span><span class="w"> </span><span class="c1">// result is &#39;(2,1)&#39;</span>
<span class="n">c</span><span class="o">.</span><span class="n">Swap</span><span class="o">(</span><span class="n">second</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="o">,</span><span class="n">first</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="o">)</span><span class="w"> </span><span class="c1">// result is &#39;(1,2)&#39;</span>
</code></pre></div>
<p>Named arguments may be used only with the arguments that correspond to the arity of the
member. That is, because members have an arity only up to the first set of tupled arguments, named
arguments may not be used with subsequent curried arguments of the member.</p>
<p>The resolution of calls that use named arguments is specified in <em>Method Application Resolution</em> (see
<a href="../inference-procedures/#144-method-application-resolution">§14.4</a>). The rules in that section describe how resolution matches a named argument with either a
formal parameter of the same name or a “settable” return property of the same name. For example,
the following code resolves the named argument to a settable property:</p>
<div class="highlight"><pre><span></span><code><span class="nn">System</span><span class="p">.</span><span class="nn">Windows</span><span class="p">.</span><span class="nn">Forms</span><span class="p">.</span><span class="n">Form</span><span class="o">(</span><span class="n">Text</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;Hello World&quot;</span><span class="o">)</span>
</code></pre></div>
<p>If an ambiguity exists, assigning the named argument is assigned to a formal parameter rather than
to a settable return property.</p>
<p>The <em>Method Application Resolution</em> (<a href="../inference-procedures/#144-method-application-resolution">§14.4</a>) rules ensure that:</p>
<ul>
<li>Named arguments must appear after all other arguments, including optional arguments that
    are matched by position.</li>
</ul>
<p>After named arguments have been assigned, the remaining required arguments are called the
<em>required unnamed arguments</em>. The required unnamed arguments must precede the named
arguments in the argument list. The <em>n</em> unnamed arguments are matched to the first <em>n</em> formal
parameters; the subsequent named arguments must include only the remaining formal parameters.
In addition, the arguments must appear in the correct sequence.</p>
<p>For example, the following code is invalid:</p>
<div class="highlight"><pre><span></span><code><span class="c1">// error: unnamed args after named</span>
<span class="nn">System</span><span class="p">.</span><span class="nn">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="o">(</span><span class="n">arg0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;World&quot;</span><span class="o">,</span><span class="w"> </span><span class="s">&quot;Hello {0}&quot;</span><span class="o">)</span>
</code></pre></div>
<p>Similarly, the following code is invalid:</p>
<div class="highlight"><pre><span></span><code><span class="k">type</span><span class="w"> </span><span class="nc">Foo</span><span class="bp">()</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="k">member</span><span class="w"> </span><span class="n">M</span><span class="w"> </span><span class="o">(</span><span class="n">arg1</span><span class="o">,</span><span class="w"> </span><span class="n">arg2</span><span class="o">,</span><span class="w"> </span><span class="n">arg3</span><span class="o">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span>
<span class="c1">// error: arg1, arg3 not a prefix of the argument list</span>
<span class="nn">Foo</span><span class="p">.</span><span class="n">M</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="mi">2</span><span class="o">,</span><span class="w"> </span><span class="n">arg2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="o">)</span>
</code></pre></div>
<p>The following code is valid:</p>
<div class="highlight"><pre><span></span><code><span class="k">type</span><span class="w"> </span><span class="nc">Foo</span><span class="bp">()</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="k">member</span><span class="w"> </span><span class="n">M</span><span class="w"> </span><span class="o">(</span><span class="n">arg1</span><span class="o">,</span><span class="w"> </span><span class="n">arg2</span><span class="o">,</span><span class="w"> </span><span class="n">arg3</span><span class="o">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span>

<span class="nn">Foo</span><span class="p">.</span><span class="n">M</span><span class="w"> </span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="mi">2</span><span class="o">,</span><span class="w"> </span><span class="n">arg</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="o">)</span>
</code></pre></div>
<p>The names of arguments to members may be listed in member signatures. For example, in a
signature file:</p>
<div class="highlight"><pre><span></span><code><span class="k">type</span><span class="w"> </span><span class="nc">C</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="k">member</span><span class="w"> </span><span class="n">ThreeArgs</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">arg1</span><span class="o">:</span><span class="n">int</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">arg2</span><span class="o">:</span><span class="n">int</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">arg3</span><span class="o">:</span><span class="n">int</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">int</span>
<span class="w">    </span><span class="k">abstract</span><span class="w"> </span><span class="n">TwoArgs</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">arg1</span><span class="o">:</span><span class="n">int</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">arg2</span><span class="o">:</span><span class="n">int</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">int</span>
</code></pre></div>
<h3 id="8136-optional-arguments-to-method-members">8.13.6 Optional Arguments to Method Members</h3>
<p>Method members—but not functions definitions—may have optional arguments. F# supports
two forms of optional arguments: F#-style optional arguments and CLI-compatible optional arguments.</p>
<p>CLI-compatible optional arguments are handled on the <strong>caller side</strong>. When a method call omits
an optional argument, the compiler reads the default value from the method's metadata and
explicitly passes that value. This contrasts with F#-style optional arguments, which are
handled by the <strong>callee</strong>. With F#-style optional arguments, if an argument is omitted, the
compiler passes <code>None</code>, and the callee determines the default value to use.</p>
<p>From the caller's perspective both styles appear as optional arguments. However, their
underlying mechanism and primary use cases differ.</p>
<p>The compiled representation of members varies as additional optional arguments are added. The
addition of optional arguments to a member signature results in a compiled form that is not binary-
compatible with the previous compiled form.</p>
<h4 id="81361-f-style-optional-arguments">8.13.6.1 F#-Style Optional Arguments</h4>
<p>F#-style optional arguments must appear at the end of the argument list. An optional argument
is marked with a <code>?</code> before its name in the method declaration. Inside the member, the argument
has the type <code>option&lt;argType&gt;</code>. The <code>option</code> type is used to represent a value that may or may
not exist.</p>
<p>The following example declares a method member that has two optional arguments:</p>
<div class="highlight"><pre><span></span><code><span class="k">let</span><span class="w"> </span><span class="nv">defaultArg</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">match</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="k">with</span><span class="w"> </span><span class="n">None</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">Some</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">v</span>

<span class="k">type</span><span class="w"> </span><span class="nc">T</span><span class="bp">()</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="k">member</span><span class="w"> </span><span class="n">OneNormalTwoOptional</span><span class="w"> </span><span class="o">(</span><span class="n">arg1</span><span class="o">,</span><span class="w"> </span><span class="o">?</span><span class="n">arg2</span><span class="o">,</span><span class="w"> </span><span class="o">?</span><span class="n">arg3</span><span class="o">)</span><span class="w"> </span><span class="o">=</span>
<span class="w">        </span><span class="k">let</span><span class="w"> </span><span class="nv">arg2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">defaultArg</span><span class="w"> </span><span class="n">arg2</span><span class="w"> </span><span class="mi">3</span>
<span class="w">        </span><span class="k">let</span><span class="w"> </span><span class="nv">arg3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">defaultArg</span><span class="w"> </span><span class="n">arg3</span><span class="w"> </span><span class="mi">10</span>
<span class="w">        </span><span class="n">arg1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">arg2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">arg3</span>
</code></pre></div>
<p>Optional arguments may be used in interface and abstract members. In a signature, optional
arguments appear as follows:</p>
<div class="highlight"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="k">member</span><span class="w"> </span><span class="n">OneNormalTwoOptional</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">arg1</span><span class="o">:</span><span class="n">int</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="o">?</span><span class="n">arg2</span><span class="o">:</span><span class="n">int</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="o">?</span><span class="n">arg3</span><span class="o">:</span><span class="n">int</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">int</span>
</code></pre></div>
<p>Callers may specify values for optional arguments in the following ways:</p>
<ul>
<li>By name, such as <code>arg2 = 1</code>.</li>
<li>By propagating an existing optional value by name, such as <code>?arg2=None</code> or <code>?arg2=Some(3)</code> or
    <code>?arg2=arg2</code>. This can be useful when building a method that passes optional arguments on to
    another method.</li>
<li>By using normal, unnamed arguments that are matched by position.</li>
</ul>
<p>For example:</p>
<div class="highlight"><pre><span></span><code><span class="nn">T</span><span class="p">.</span><span class="n">OneNormalTwoOptional</span><span class="o">(</span><span class="mi">3</span><span class="o">)</span>
<span class="nn">T</span><span class="p">.</span><span class="n">OneNormalTwoOptional</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span><span class="w"> </span><span class="mi">2</span><span class="o">)</span>
<span class="nn">T</span><span class="p">.</span><span class="n">OneNormalTwoOptional</span><span class="o">(</span><span class="n">arg1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="o">)</span>
<span class="nn">T</span><span class="p">.</span><span class="n">OneNormalTwoOptional</span><span class="o">(</span><span class="n">arg1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="o">,</span><span class="w"> </span><span class="n">arg2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="o">)</span>
<span class="nn">T</span><span class="p">.</span><span class="n">OneNormalTwoOptional</span><span class="o">(</span><span class="n">arg2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="o">,</span><span class="w"> </span><span class="n">arg1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="o">)</span>
<span class="nn">T</span><span class="p">.</span><span class="n">OneNormalTwoOptional</span><span class="o">(</span><span class="n">arg2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="o">,</span><span class="w"> </span><span class="n">arg1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="o">,</span><span class="w"> </span><span class="n">arg3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">11</span><span class="o">)</span>
<span class="nn">T</span><span class="p">.</span><span class="n">OneNormalTwoOptional</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span><span class="w"> </span><span class="mi">3</span><span class="o">,</span><span class="w"> </span><span class="mi">11</span><span class="o">)</span>
<span class="nn">T</span><span class="p">.</span><span class="n">OneNormalTwoOptional</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span><span class="w"> </span><span class="mi">3</span><span class="o">,</span><span class="w"> </span><span class="n">arg3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">11</span><span class="o">)</span>
<span class="nn">T</span><span class="p">.</span><span class="n">OneNormalTwoOptional</span><span class="o">(</span><span class="n">arg1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="o">,</span><span class="w"> </span><span class="o">?</span><span class="n">arg2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Some</span><span class="w"> </span><span class="mi">1</span><span class="o">)</span>
<span class="nn">T</span><span class="p">.</span><span class="n">OneNormalTwoOptional</span><span class="o">(</span><span class="n">arg2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="o">,</span><span class="w"> </span><span class="n">arg1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="o">,</span><span class="w"> </span><span class="n">arg3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">11</span><span class="o">)</span>
<span class="nn">T</span><span class="p">.</span><span class="n">OneNormalTwoOptional</span><span class="o">(?</span><span class="n">arg2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Some</span><span class="w"> </span><span class="mi">3</span><span class="o">,</span><span class="w"> </span><span class="n">arg1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="o">,</span><span class="w"> </span><span class="n">arg3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">11</span><span class="o">)</span>
<span class="nn">T</span><span class="p">.</span><span class="n">OneNormalTwoOptional</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span><span class="w"> </span><span class="mi">3</span><span class="o">,</span><span class="w"> </span><span class="o">?</span><span class="n">arg3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Some</span><span class="w"> </span><span class="mi">11</span><span class="o">)</span>
</code></pre></div>
<p>The resolution of calls that use optional arguments is specified in <em>Method Application Resolution</em> (see
<a href="../inference-procedures/#144-method-application-resolution">§14.4</a>).</p>
<p>Optional arguments may not be used in member constraints.</p>
<p>Marking an argument as optional is equivalent to adding the <code>FSharp.Core.OptionalArgument</code>
attribute (<a href="../special-attributes-and-types/#171-custom-attributes-recognized-by-f">§17.1</a>) to a required argument. This attribute is added implicitly for optional arguments.
Adding the <code>[&lt;OptionalArgument&gt;]</code> attribute to a parameter of type <code>'a option</code> in a virtual method
signature is equivalent to using the <code>(?x:'a)</code> syntax in a method definition. If the attribute is applied
to an argument of a method, it should also be applied to all subsequent arguments of the method.
Otherwise, it has no effect and callers must provide all of the arguments.</p>
<h4 id="81362-cli-compatible-optional-arguments">8.13.6.2 CLI-Compatible Optional Arguments</h4>
<p>For interoperability with C# and other CLI languages, F# supports optional arguments with default values using
the <code>Optional</code> and <code>DefaultParameterValue</code> attributes. This mechanism is equivalent to defining an optional
argument in C# with a default value, such as <code>MyMethod(int i = 3)</code>. In F#, this would be written as:</p>
<div class="highlight"><pre><span></span><code><span class="k">open</span><span class="w"> </span><span class="nn">System.Runtime.InteropServices</span>

<span class="k">type</span><span class="w"> </span><span class="nc">C</span><span class="bp">()</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="k">member</span><span class="w"> </span><span class="n">MyMethod</span><span class="o">([&lt;</span><span class="n">Optional</span><span class="o">;</span><span class="w"> </span><span class="n">DefaultParameterValue</span><span class="o">(</span><span class="mi">3</span><span class="o">)&gt;]</span><span class="w"> </span><span class="n">i</span><span class="o">:</span><span class="w"> </span><span class="n">int</span><span class="o">)</span><span class="w"> </span><span class="o">=</span>
<span class="w">        </span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span>
</code></pre></div>
<p>These attributes are typically used for C# and VB interop so that callers in those languages see an argument as optional.
They can also be from F# code in the same assembly and from separate assemblies.</p>
<p>CLI-compatible optional arguments are not passed as values of type <code>Option&lt;_&gt;</code>. If the optional
argument is present, its value is passed. If the optional argument is omitted, the default
value from the CLI metadata is supplied instead. The value <code>System.Reflection.Missing.Value</code>
is supplied for any CLI optional arguments of type <code>System.Object</code> that do not have a
corresponding CLI default value, and the default (zero-bit pattern) value is supplied for
other CLI optional arguments of other types that have no default value.</p>
<h5 id="813621-allowable-default-values">8.13.6.2.1 Allowable Default Values</h5>
<p>The <code>DefaultParameterValue</code> attribute accepts the following types of values:</p>
<ul>
<li><strong>Primitive Types</strong>: Constant values for <code>sbyte</code>, <code>byte</code>, <code>int16</code>, <code>uint16</code>, <code>int32</code>, <code>uint32</code>, <code>int64</code>, <code>uint64</code>, <code>float32</code>, <code>float</code>, and <code>string</code>.</li>
<li><strong>Reference Types</strong>: The only allowed default value is <code>null</code>.</li>
<li><strong>Value Types</strong>: The only allowed default value is the default value of the struct.</li>
</ul>
<h5 id="813622-usage-and-considerations">8.13.6.2.2 Usage and Considerations</h5>
<p>The value provided to <code>DefaultParameterValue</code> must match the parameter's type. A mismatch will generate a compiler warning, and both the <code>Optional</code> and <code>DefaultParameterValue</code> attributes will be ignored.</p>
<p>For example, the following is not allowed:</p>
<div class="highlight"><pre><span></span><code><span class="k">type</span><span class="w"> </span><span class="nc">Class</span><span class="bp">()</span><span class="w"> </span><span class="o">=</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="k">member</span><span class="w"> </span><span class="n">Wrong</span><span class="o">([&lt;</span><span class="n">Optional</span><span class="o">;</span><span class="w"> </span><span class="n">DefaultParameterValue</span><span class="o">(</span><span class="s">&quot;string&quot;</span><span class="o">)&gt;]</span><span class="w"> </span><span class="n">i</span><span class="o">:</span><span class="n">int</span><span class="o">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">()</span><span class="o">```</span>

<span class="n">This</span><span class="w"> </span><span class="n">will</span><span class="w"> </span><span class="n">be</span><span class="w"> </span><span class="n">compiled</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="n">were</span><span class="w"> </span><span class="n">written</span><span class="o">:</span>
<span class="o">```</span><span class="n">fsharp</span>
<span class="k">type</span><span class="w"> </span><span class="nc">Class</span><span class="bp">()</span><span class="w"> </span><span class="o">=</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="k">member</span><span class="w"> </span><span class="n">Wrong</span><span class="o">(</span><span class="n">i</span><span class="o">:</span><span class="n">int</span><span class="o">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">()</span>
</code></pre></div>
<p>Note that the <code>null</code> value for reference types must be type-annotated, for instance: <code>[&lt;Optional; DefaultParameterValue(null:obj)&gt;] o:obj</code>.</p>
<p>It is possible to use these attributes in the following ways, though it is not standard practice:</p>
<ul>
<li>Specifying <code>Optional</code> without <code>DefaultParameterValue</code>: Callers can omit the argument, and a default value will be chosen by convention (the default constructor for primitive types and structs).</li>
<li>Specifying <code>DefaultParameterValue</code> without <code>Optional</code>.</li>
<li>Specifying <code>Optional; DefaultParameterValue</code> on any parameter, not necessarily the last one.</li>
</ul>
<blockquote>
<p>Note : Imported CLI metadata may specify arguments as optional and may additionally
specify a default value for the argument. CLI optional arguments can propagate an existing optional
value by name; for example, <code>?ValueTitle = Some (...)</code>.
<br>For example, here is a fragment of a call to a Microsoft Excel COM automation API that
uses named and optional arguments.</p>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="w">    </span><span class="n">chartobject</span><span class="o">.</span><span class="n">Chart</span><span class="o">.</span><span class="n">ChartWizard</span><span class="o">(</span><span class="n">Source</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">range5</span><span class="o">,</span>
<span class="w">                                  </span><span class="n">Gallery</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nn">XlChartType</span><span class="p">.</span><span class="n">xl3DColumn</span><span class="o">,</span>
<span class="w">                                  </span><span class="n">PlotBy</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nn">XlRowCol</span><span class="p">.</span><span class="n">xlRows</span><span class="o">,</span>
<span class="w">                                  </span><span class="n">HasLegend</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">true</span><span class="o">,</span>
<span class="w">                                  </span><span class="n">Title</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;Sample Chart&quot;</span><span class="o">,</span>
<span class="w">                                  </span><span class="n">CategoryTitle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;Sample Category Type&quot;</span><span class="o">,</span>
<span class="w">                                  </span><span class="n">ValueTitle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;Sample Value Type&quot;</span><span class="o">)</span>
</code></pre></div>
<h3 id="8137-type-directed-conversions-at-member-invocations">8.13.7 Type-directed Conversions at Member Invocations</h3>
<p>As described in <em>Method Application Resolution</em> (see <a href="../inference-procedures/#144-method-application-resolution">§14.4</a>), three type-directed conversions are
applied at method invocations.</p>
<h4 id="81371-conversion-to-delegates">8.13.7.1 Conversion to Delegates</h4>
<p>The first type-directed conversion converts anonymous function expressions and other function-
valued arguments to delegate types. Given:</p>
<ul>
<li>A formal parameter of delegate type <code>D</code></li>
<li>An actual argument <code>farg</code> of known type <code>ty1 -&gt; ... -&gt; tyn -&gt; rty</code></li>
<li>Precisely <code>n</code> arguments to the <code>Invoke</code> method of delegate type <code>D</code></li>
</ul>
<p>Then:</p>
<ul>
<li>
<p>The parameter is interpreted as if it were written:</p>
<div class="highlight"><pre><span></span><code>new D (fun arg1 ... argn -&gt; farg arg1 ... argn)
</code></pre></div>
</li>
</ul>
<p>If the type of the formal parameter is a variable type, then F# uses the known inferred type of the
argument including instantiations to determine whether a formal parameter has delegate type. For
example, if an explicit type instantiation is given that instantiates a generic type parameter to a
delegate type, the following conversion can apply:</p>
<div class="highlight"><pre><span></span><code><span class="k">type</span><span class="w"> </span><span class="nc">GenericClass</span><span class="o">&lt;</span><span class="k">&#39;</span><span class="n">T</span><span class="o">&gt;</span><span class="bp">()</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="k">member</span><span class="w"> </span><span class="n">M</span><span class="o">(</span><span class="n">arg</span><span class="o">:</span><span class="w"> </span><span class="k">&#39;</span><span class="n">T</span><span class="o">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">()</span>

<span class="n">GenericClass</span><span class="o">&lt;</span><span class="nn">System</span><span class="p">.</span><span class="n">Action</span><span class="o">&gt;.</span><span class="n">M</span><span class="o">(</span><span class="k">fun</span><span class="w"> </span><span class="bp">()</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="bp">()</span><span class="o">)</span><span class="w"> </span><span class="c1">// allowed</span>
</code></pre></div>
<h4 id="81372-conversion-to-reference-cells">8.13.7.2 Conversion to Reference Cells</h4>
<p>The second type-directed conversion enables an F# reference cell to be passed where a <code>byref&lt;ty&gt;</code> is
expected. Given:</p>
<ul>
<li>A formal out parameter of type <code>byref&lt;ty&gt;</code></li>
<li>An actual argument that is not a byref type</li>
</ul>
<p>Then:</p>
<ul>
<li>The actual parameter is interpreted as if it had type <code>ref&lt;ty&gt;</code>.</li>
</ul>
<p>For example:</p>
<div class="highlight"><pre><span></span><code><span class="k">type</span><span class="w"> </span><span class="nc">C</span><span class="bp">()</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="k">member</span><span class="w"> </span><span class="n">M1</span><span class="o">(</span><span class="n">arg</span><span class="o">:</span><span class="w"> </span><span class="nn">System</span><span class="p">.</span><span class="n">Action</span><span class="o">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">()</span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="k">member</span><span class="w"> </span><span class="n">M2</span><span class="o">(</span><span class="n">arg</span><span class="o">:</span><span class="w"> </span><span class="n">byref</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">()</span>

<span class="nn">C</span><span class="p">.</span><span class="n">M1</span><span class="o">(</span><span class="k">fun</span><span class="w"> </span><span class="bp">()</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="bp">()</span><span class="o">)</span><span class="w"> </span><span class="c1">// allowed</span>
<span class="k">let</span><span class="w"> </span><span class="nv">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">(</span><span class="k">fun</span><span class="w"> </span><span class="bp">()</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="bp">()</span><span class="o">)</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="nn">C</span><span class="p">.</span><span class="n">M1</span><span class="o">(</span><span class="n">f</span><span class="o">)</span><span class="w"> </span><span class="c1">// not allowed</span>

<span class="k">let</span><span class="w"> </span><span class="nv">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ref</span><span class="w"> </span><span class="mi">0</span>
<span class="nn">C</span><span class="p">.</span><span class="n">M2</span><span class="o">(</span><span class="n">result</span><span class="o">)</span><span class="w"> </span><span class="c1">// allowed</span>
</code></pre></div>
<blockquote>
<p>Note: These type-directed conversions are primarily for interoperability with existing
member-based .NET libraries and do not apply at invocations of functions defined in
modules or bound locally in expressions.</p>
</blockquote>
<p>A value of type <code>ref&lt;ty&gt;</code> may be passed to a function that accepts a byref parameter. The interior
address of the heap-allocated cell that is associated with such a parameter is passed as the pointer
argument.</p>
<p>For example, consider the following C# code:</p>
<div class="highlight"><pre><span></span><code><span class="k">public</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">C</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="nf">IntegerOutParam</span><span class="p">(</span><span class="k">out</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="p">}</span>
<span class="k">public</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">D</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="nf">IntegerOutParam</span><span class="p">(</span><span class="k">out</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>This C# code can be called by the following F# code:</p>
<div class="highlight"><pre><span></span><code><span class="k">let</span><span class="w"> </span><span class="nv">res1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ref</span><span class="w"> </span><span class="mi">0</span>
<span class="nn">C</span><span class="p">.</span><span class="n">IntegerOutParam</span><span class="o">(</span><span class="n">res</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">)</span>
<span class="c1">// res1.contents now equals 3</span>
</code></pre></div>
<p>Likewise, the abstract signature can be implemented as follows:</p>
<div class="highlight"><pre><span></span><code><span class="k">let</span><span class="w"> </span><span class="nv">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">{</span><span class="k">new</span><span class="w"> </span><span class="n">D</span><span class="bp">()</span><span class="w"> </span><span class="k">with</span><span class="w"> </span><span class="n">IntegerOutParam</span><span class="o">(</span><span class="n">res</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">byref</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">res</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="mi">4</span><span class="o">}</span>
<span class="k">let</span><span class="w"> </span><span class="nv">res2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ref</span><span class="w"> </span><span class="mi">0</span>
<span class="n">x</span><span class="o">.</span><span class="n">IntegerOutParam</span><span class="o">(</span><span class="n">res2</span><span class="o">);</span>
<span class="c1">// res2.contents now equals 4</span>
</code></pre></div>
<h4 id="81373-conversion-to-quotation-values">8.13.7.3 Conversion to Quotation Values</h4>
<p>The third type-directed conversion enables an F# expression to be implicitly quoted at a member
call.</p>
<p>Conversion to a quotation value is driven by the ReflectedDefinition attribute to a method argument
of type FSharp.Quotations.Expr&lt;_&gt;:</p>
<div class="highlight"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="k">member</span><span class="w"> </span><span class="n">Plot</span><span class="o">([&lt;</span><span class="n">ReflectedDefinition</span><span class="o">&gt;]</span><span class="w"> </span><span class="n">values</span><span class="o">:</span><span class="n">Expr</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">(...)</span>
</code></pre></div>
<p>The intention is that this gives an implicit quotation from X --&gt; &lt;@ X @&gt; at the callsite. So for</p>
<div class="highlight"><pre><span></span><code><span class="nn">Chart</span><span class="p">.</span><span class="n">Plot</span><span class="o">(</span><span class="n">f</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">y</span><span class="o">)</span>
</code></pre></div>
<p>the caller becomes:</p>
<div class="highlight"><pre><span></span><code><span class="nn">Chart</span><span class="p">.</span><span class="n">Plot</span><span class="o">(&lt;@</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">@&gt;)</span>
</code></pre></div>
<p>Additionally, the method can declare that it wants both the quotation and the evaluation of the
expression, by giving <code>true</code> as the <code>includeValue</code> argument of the <code>ReflectedDefinitionAttribute</code>.</p>
<div class="highlight"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="k">member</span><span class="w"> </span><span class="n">Plot</span><span class="o">([&lt;</span><span class="n">ReflectedDefinition</span><span class="o">(</span><span class="k">true</span><span class="o">)&gt;]</span><span class="w"> </span><span class="n">values</span><span class="o">:</span><span class="n">Expr</span><span class="o">&lt;</span><span class="n">X</span><span class="o">&gt;)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">(...)</span>
</code></pre></div>
<p>So for</p>
<div class="highlight"><pre><span></span><code><span class="nn">Chart</span><span class="p">.</span><span class="n">Plot</span><span class="o">(</span><span class="n">f</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">y</span><span class="o">)</span>
</code></pre></div>
<p>the caller becomes:</p>
<div class="highlight"><pre><span></span><code><span class="nn">Chart</span><span class="p">.</span><span class="n">Plot</span><span class="o">(</span><span class="nn">Expr</span><span class="p">.</span><span class="n">WithValue</span><span class="o">(</span><span class="n">f</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">y</span><span class="o">,</span><span class="w"> </span><span class="o">&lt;@</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">@&gt;))</span>
</code></pre></div>
<p>and the quotation value <code>Q</code> received by <code>Chart.Plot</code> matches:</p>
<div class="highlight"><pre><span></span><code><span class="k">match</span><span class="w"> </span><span class="n">Q</span><span class="w"> </span><span class="k">with</span>
<span class="o">|</span><span class="w"> </span><span class="nn">Expr</span><span class="p">.</span><span class="n">WithValue</span><span class="o">(</span><span class="n">v</span><span class="o">,</span><span class="w"> </span><span class="n">ty</span><span class="o">)</span><span class="w"> </span><span class="o">--&gt;</span><span class="w"> </span><span class="c1">// v = f x + f y</span>
<span class="o">|</span><span class="w"> </span><span class="o">...</span>
</code></pre></div>
<blockquote>
<p>Note: Methods with ReflectedDefinition arguments may be used as first class values
(including pipelined uses), but it will not normally be useful to use them in this way. This
is because, in the above example, a first-class use of the method <code>Chart.Plot</code> is
considered shorthand for <code>(fun x -&gt; C.Plot(x))</code> for some compiler-generated local
name <code>x</code>, which will become <code>(fun x -&gt; C.Plot( &lt;@ x @&gt; ))</code>, so the implicit quotation
will just be a local value substitution. This means a pipelines use <code>expr |&gt; C.Plot</code> will not
capture a full quotation for <code>expr</code>, but rather just its value.
<br>
The same applies to auto conversions for LINQ expressions: if you pipeline a method
accepting Expression arguments. This is an intrinsic cost of having an auto-quotation
meta-programming facility. All uses of auto-quotation need careful use API designers.
<br>
Auto-quotation of arguments only applies at method calls, and not function calls.
<br>
The conversion only applies if the called-argument-type is type Expr for some type T, and
if the caller-argument type is not of the form Expr for any U.
<br>
The caller-argument-type is determined as normal, with the addition that a caller
argument of the form &lt;@ ... @&gt; is always considered to have a type of the form Expr&lt;&gt;,
in the same way that caller arguments of the form (fun x -&gt; ...) are always assumed to
have type of the form <code>-&gt; _</code> (i.e. a function type)</p>
</blockquote>
<h4 id="81374-conversion-to-linq-expressions">8.13.7.4 Conversion to LINQ Expressions</h4>
<p>The third type-directed conversion enables an F# expression to be implicitly converted to a LINQ
expression at a method call. Conversion is driven by an argument of type
<code>System.Linq.Expressions.Expression</code>.</p>
<div class="highlight"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="k">member</span><span class="w"> </span><span class="n">Plot</span><span class="o">(</span><span class="n">values</span><span class="o">:</span><span class="n">Expression</span><span class="o">&lt;</span><span class="n">Func</span><span class="o">&lt;</span><span class="n">int</span><span class="o">,</span><span class="n">int</span><span class="o">&gt;&gt;)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">(...)</span>
</code></pre></div>
<p>This attribute results in an implicit quotation from X --&gt; &lt;@ X @&gt; at the callsite and a call for a
helper function. So for</p>
<div class="highlight"><pre><span></span><code><span class="nn">Chart</span><span class="p">.</span><span class="n">Plot</span><span class="o">(</span><span class="n">f</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">y</span><span class="o">)</span>
</code></pre></div>
<p>the caller becomes:</p>
<div class="highlight"><pre><span></span><code><span class="nn">Chart</span><span class="p">.</span><span class="n">Plot</span><span class="o">(</span><span class="nn">FSharp</span><span class="p">.</span><span class="nn">Linq</span><span class="p">.</span><span class="nn">RuntimeHelpers</span><span class="p">.</span><span class="nn">LeafExpressionConverter</span><span class="p">.</span>
<span class="n">QuotationToLambdaExpression</span><span class="w"> </span><span class="o">&lt;@</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">@&gt;)</span>
</code></pre></div>
<h3 id="8138-overloading-of-methods">8.13.8 Overloading of Methods</h3>
<p>Multiple methods that have the same name may appear in the same type definition or extension.
For example:</p>
<div class="highlight"><pre><span></span><code><span class="k">type</span><span class="w"> </span><span class="nc">MyForm</span><span class="bp">()</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="k">inherit</span><span class="w"> </span><span class="nn">System</span><span class="p">.</span><span class="nn">Windows</span><span class="p">.</span><span class="nn">Forms</span><span class="p">.</span><span class="n">Form</span><span class="bp">()</span>

<span class="w">    </span><span class="k">member</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="nf">ChangeText</span><span class="o">(</span><span class="n">text</span><span class="o">:</span><span class="w"> </span><span class="kt">string</span><span class="o">)</span><span class="w"> </span><span class="o">=</span>
<span class="w">        </span><span class="n">x</span><span class="o">.</span><span class="n">Text</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">text</span>

<span class="w">    </span><span class="k">member</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="nf">ChangeText</span><span class="o">(</span><span class="n">text</span><span class="o">:</span><span class="w"> </span><span class="kt">string</span><span class="o">,</span><span class="w"> </span><span class="n">reason</span><span class="o">:</span><span class="w"> </span><span class="kt">string</span><span class="o">)</span><span class="w"> </span><span class="o">=</span>
<span class="w">        </span><span class="n">x</span><span class="o">.</span><span class="n">Text</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">text</span>
<span class="w">        </span><span class="nn">System</span><span class="p">.</span><span class="nn">Windows</span><span class="p">.</span><span class="nn">Forms</span><span class="p">.</span><span class="nn">MessageBox</span><span class="p">.</span><span class="n">Show</span><span class="w"> </span><span class="o">(</span><span class="s">&quot;changing text due to &quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">reason</span><span class="o">)</span>
</code></pre></div>
<p>Methods must be distinct based on their name and fully inferred types, after erasure of type
abbreviations and unit-of-measure annotations.</p>
<p>Methods that take curried arguments may not be overloaded.</p>
<h3 id="8139-naming-restrictions-for-members">8.13.9 Naming Restrictions for Members</h3>
<p>A member in a record type may not have the same name as a record field in that type.</p>
<p>A member may not have the same name and signature as another method in the type. This check
ignores return types except for members that are named <code>op_Implicit</code> or <code>op_Explicit</code>.</p>
<h3 id="81310-members-represented-as-events">8.13.10 Members Represented as Events</h3>
<p><em>Events</em> are the CLI notion of a “listening point”—that is, a configurable object that holds a set of
callbacks, which can be triggered, often by some external action such as a mouse click or timer tick.</p>
<p>In F#, events are first-class values; that is, they are objects that mediate the addition and removal of
listeners from a backing list of listeners. The F# library supports the type
<code>FSharp.Control.IEvent&lt;_,_&gt;</code> and the module <code>FSharp.Control.Event</code>, which contains operations to
map, fold, create, and compose events. The type is defined as follows:</p>
<div class="highlight"><pre><span></span><code><span class="k">type</span><span class="w"> </span><span class="nc">IDelegateEvent</span><span class="o">&lt;</span><span class="k">&#39;</span><span class="n">del</span><span class="w"> </span><span class="k">when</span><span class="w"> </span><span class="k">&#39;</span><span class="n">del</span><span class="w"> </span><span class="o">:&gt;</span><span class="w"> </span><span class="nn">System</span><span class="p">.</span><span class="n">Delegate</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="k">abstract</span><span class="w"> </span><span class="n">AddHandler</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">&#39;</span><span class="n">del</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">unit</span>
<span class="w">    </span><span class="k">abstract</span><span class="w"> </span><span class="n">RemoveHandler</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">&#39;</span><span class="n">del</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">unit</span>

<span class="k">type</span><span class="w"> </span><span class="nc">IEvent</span><span class="o">&lt;</span><span class="k">&#39;</span><span class="n">Del</span><span class="o">,</span><span class="k">&#39;</span><span class="n">T</span><span class="w"> </span><span class="k">when</span><span class="w"> </span><span class="k">&#39;</span><span class="n">Del</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">delegate</span><span class="o">&lt;</span><span class="k">&#39;</span><span class="n">T</span><span class="o">,</span><span class="kt">unit</span><span class="o">&gt;</span><span class="w"> </span><span class="ow">and</span><span class="w"> </span><span class="k">&#39;</span><span class="n">del</span><span class="w"> </span><span class="o">:&gt;</span><span class="w"> </span><span class="nn">System</span><span class="p">.</span><span class="n">Delegate</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="k">abstract</span><span class="w"> </span><span class="n">Add</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">event</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="o">(</span><span class="k">&#39;</span><span class="n">T</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">unit</span><span class="o">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">unit</span>
<span class="w">    </span><span class="k">inherit</span><span class="w"> </span><span class="n">IDelegateEvent</span><span class="o">&lt;</span><span class="k">&#39;</span><span class="n">del</span><span class="o">&gt;</span>

<span class="k">type</span><span class="w"> </span><span class="nc">Handler</span><span class="o">&lt;</span><span class="k">&#39;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">delegate</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="n">sender</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">obj</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">&#39;</span><span class="n">T</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">unit</span>

<span class="k">type</span><span class="w"> </span><span class="nc">IEvent</span><span class="o">&lt;</span><span class="k">&#39;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">IEvent</span><span class="o">&lt;</span><span class="n">Handler</span><span class="o">&lt;</span><span class="k">&#39;</span><span class="n">T</span><span class="o">&gt;,</span><span class="w"> </span><span class="k">&#39;</span><span class="n">T</span><span class="o">&gt;</span>
</code></pre></div>
<p>The following shows a sample use of events:</p>
<div class="highlight"><pre><span></span><code><span class="k">open</span><span class="w"> </span><span class="nn">System.Windows.Forms</span>

<span class="k">type</span><span class="w"> </span><span class="nc">MyCanvas</span><span class="bp">()</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="k">inherit</span><span class="w"> </span><span class="n">Form</span><span class="bp">()</span>
<span class="w">    </span><span class="k">let</span><span class="w"> </span><span class="nv">event</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Event</span><span class="o">&lt;</span><span class="n">PaintEventArgs</span><span class="o">&gt;</span><span class="bp">()</span>
<span class="w">    </span><span class="k">member</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="nf">Redraw</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">event</span><span class="o">.</span><span class="n">Publish</span>
<span class="w">    </span><span class="k">override</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="nf">OnPaint</span><span class="o">(</span><span class="n">args</span><span class="o">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">event</span><span class="o">.</span><span class="n">Trigger</span><span class="o">(</span><span class="n">args</span><span class="o">)</span>

<span class="k">let</span><span class="w"> </span><span class="nv">form</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">MyCanvas</span><span class="bp">()</span>
<span class="n">form</span><span class="o">.</span><span class="n">Redraw</span><span class="o">.</span><span class="n">Add</span><span class="o">(</span><span class="k">fun</span><span class="w"> </span><span class="n">args</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">printfn</span><span class="w"> </span><span class="s">&quot;OnRedraw&quot;</span><span class="o">)</span>
<span class="n">form</span><span class="o">.</span><span class="n">Activate</span><span class="bp">()</span>
<span class="nn">Application</span><span class="p">.</span><span class="n">Run</span><span class="o">(</span><span class="n">form</span><span class="o">)</span>
</code></pre></div>
<p>Events from CLI languages are revealed as object properties of type
<code>FSharp.Control.IEvent&lt;tydelegate, tyargs&gt;</code>. The F# compiler determines the type arguments, which
are derived from the CLI delegate type that is associated with the event.</p>
<p>Event declarations are not built into the F# language, and <code>event</code> is not a keyword. However, property
members that are marked with the <code>CLIEvent</code> attribute and whose type coerces to
<code>FSharp.Control.IDelegateEvent&lt;tydelegate&gt;</code> are compiled to include extra CLI metadata and methods
that mark the property name as a CLI event. For example, in the following code, the
<code>ChannelChanged</code> property is currently compiled as a CLI event:</p>
<div class="highlight"><pre><span></span><code><span class="k">type</span><span class="w"> </span><span class="nc">ChannelChangedHandler</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">delegate</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="kt">obj</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">int</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">unit</span>

<span class="k">type</span><span class="w"> </span><span class="nc">C</span><span class="bp">()</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="k">let</span><span class="w"> </span><span class="nv">channelChanged</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Event</span><span class="o">&lt;</span><span class="n">ChannelChangedHandler</span><span class="o">,_&gt;</span><span class="bp">()</span>
<span class="w">    </span><span class="o">[&lt;</span><span class="n">CLIEvent</span><span class="o">&gt;]</span>
<span class="w">    </span><span class="k">member</span><span class="w"> </span><span class="n">self</span><span class="p">.</span><span class="nf">ChannelChanged</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">channelChanged</span><span class="o">.</span><span class="n">Publish</span>
</code></pre></div>
<p>Similarly, the following shows the definition and implementation of an abstract event:</p>
<div class="highlight"><pre><span></span><code><span class="k">type</span><span class="w"> </span><span class="nc">I</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="o">[&lt;</span><span class="n">CLIEvent</span><span class="o">&gt;]</span>
<span class="w">    </span><span class="k">abstract</span><span class="w"> </span><span class="n">ChannelChanged</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">IEvent</span><span class="o">&lt;</span><span class="n">ChannelChanged</span><span class="o">,</span><span class="n">int</span><span class="o">&gt;</span>

<span class="k">type</span><span class="w"> </span><span class="nc">ImplI</span><span class="bp">()</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="k">let</span><span class="w"> </span><span class="nv">channelChanged</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Event</span><span class="o">&lt;</span><span class="n">ChannelChanged</span><span class="o">,_&gt;</span><span class="bp">()</span>
<span class="w">    </span><span class="k">interface</span><span class="w"> </span><span class="n">I</span><span class="w"> </span><span class="k">with</span>
<span class="w">        </span><span class="o">[&lt;</span><span class="n">CLIEvent</span><span class="o">&gt;]</span>
<span class="w">        </span><span class="k">member</span><span class="w"> </span><span class="n">self</span><span class="p">.</span><span class="nf">ChannelChanged</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">channelChanged</span><span class="o">.</span><span class="n">Publish</span>
</code></pre></div>
<h3 id="81311-members-represented-as-static-members">8.13.11 Members Represented as Static Members</h3>
<p>Most members are represented as their corresponding CLI method or property. However, in certain
situations an instance member may be compiled as a static method. This happens when either of the
following is true:</p>
<ul>
<li>
<p>The type definition uses <code>null</code> as a representation by placing the
    <code>CompilationRepresentation(CompilationRepresentationFlags.UseNullAsTrueValue)</code> attribute on
    the type that declares the member.</p>
</li>
<li>
<p>The member is an extension member.</p>
</li>
</ul>
<p>Compilation of an instance member as a static method can affect the view of the type when seen
from other languages or from <code>System.Reflection</code>. A member that might otherwise have a static
representation can be reverted to an instance member representation by placing the attribute
<code>CompilationRepresentation(CompilationRepresentationFlags.Instance)</code> on the member.</p>
<p>For example, consider the following type:</p>
<div class="highlight"><pre><span></span><code><span class="o">[&lt;</span><span class="n">CompilationRepresentation</span><span class="o">(</span><span class="nn">CompilationRepresentationFlags</span><span class="p">.</span><span class="n">UseNullAsTrueValue</span><span class="o">)&gt;]</span>
<span class="k">type</span><span class="w"> </span><span class="nc">option</span><span class="o">&lt;</span><span class="k">&#39;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="o">|</span><span class="w"> </span><span class="n">None</span>
<span class="w">    </span><span class="o">|</span><span class="w"> </span><span class="n">Some</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="k">&#39;</span><span class="n">T</span>

<span class="w">    </span><span class="k">member</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="nf">IsNone</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">match</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="k">with</span><span class="w"> </span><span class="n">None</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="k">true</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="o">_</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="k">false</span>
<span class="w">    </span><span class="k">member</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="nf">IsSome</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">match</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="k">with</span><span class="w"> </span><span class="n">Some</span><span class="w"> </span><span class="o">_</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="k">true</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="o">_</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="k">false</span>

<span class="w">    </span><span class="o">[&lt;</span><span class="n">CompilationRepresentation</span><span class="o">(</span><span class="nn">CompilationRepresentationFlags</span><span class="p">.</span><span class="n">Instance</span><span class="o">)&gt;]</span>
<span class="w">    </span><span class="k">member</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="nf">Item</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="k">with</span>
<span class="w">        </span><span class="o">|</span><span class="w"> </span><span class="n">Some</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">x</span>
<span class="w">        </span><span class="o">|</span><span class="w"> </span><span class="n">None</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">failwith</span><span class="w"> </span><span class="s">&quot;Option.Item&quot;</span>
</code></pre></div>
<p>The <code>IsNone</code> and <code>IsSome</code> properties are represented as CLI static methods. The <code>Item</code> property is
represented as an instance property.</p>
<h2 id="814-abstract-members-and-interface-implementations">8.14 Abstract Members and Interface Implementations</h2>
<p>Abstract member definitions and interface declarations in a type definition represent promises that
an object will provide an implementation for a corresponding contract.</p>
<h3 id="8141-abstract-members">8.14.1 Abstract Members</h3>
<p>An <em>abstract member definition</em> in a type definition represents a promise that an object will provide
an implementation for a dispatch slot. For example:</p>
<div class="highlight"><pre><span></span><code><span class="k">type</span><span class="w"> </span><span class="nc">IX</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="k">abstract</span><span class="w"> </span><span class="n">M</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">int</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">int</span>
</code></pre></div>
<p>The abstract member <code>M</code> indicates that an object of type <code>IX</code> will implement a displatch slot for a
member that returns an <code>int</code>.</p>
<p>A class definition may contain abstract member definitions, but the definition must be labeled with
the <code>AbstractClass</code> attribute:</p>
<div class="highlight"><pre><span></span><code><span class="o">[&lt;</span><span class="n">AbstractClass</span><span class="o">&gt;]</span>
<span class="k">type</span><span class="w"> </span><span class="nc">X</span><span class="bp">()</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="k">abstract</span><span class="w"> </span><span class="n">M</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">int</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">int</span>
</code></pre></div>
<p>An abstract member definition has the form</p>
<div class="highlight"><pre><span></span><code>abstract access~opt member-sig
</code></pre></div>
<p>where a member signature has one of the following forms</p>
<div class="highlight"><pre><span></span><code>ident typar-defns~opt : curried-sig
ident typar-defns~opt : curried-sig with get
ident typar-defns~opt : curried-sig with set
ident typar-defns~opt : curried-sig with get, set
ident typar-defns~opt : curried-sig with set, get
</code></pre></div>
<p>and the curried signature has the form</p>
<div class="highlight"><pre><span></span><code>args-spec1 -&gt; ... -&gt; args-specn -&gt; type
</code></pre></div>
<p>If <code>n</code> ≥ 2, then <code>args-spec2 ... args-specn</code> must all be patterns without attribute or optional argument
specifications.</p>
<p>If <code>get</code> or <code>set</code> is specified, the abstract member is a <em>property member</em>. If both <code>get</code> and <code>set</code> are
specified, the abstract member is equivalent to two abstract members, one with <code>get</code> and one with
<code>set</code>.</p>
<h3 id="8142-members-that-implement-abstract-members">8.14.2 Members that Implement Abstract Members</h3>
<p>An <em>implementation member</em> has the form:</p>
<div class="highlight"><pre><span></span><code>override ident. ident pat 1 ... patn = expr
default ident. ident pat 1 ... patn = expr
</code></pre></div>
<p>Implementation members implement dispatch slots. For example:</p>
<div class="highlight"><pre><span></span><code><span class="o">[&lt;</span><span class="n">AbstractClass</span><span class="o">&gt;]</span>
<span class="k">type</span><span class="w"> </span><span class="nc">BaseClass</span><span class="bp">()</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="k">abstract</span><span class="w"> </span><span class="n">AbstractMethod</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">int</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">int</span>

<span class="k">type</span><span class="w"> </span><span class="nc">SubClass</span><span class="o">(</span><span class="n">x</span><span class="o">:</span><span class="w"> </span><span class="n">int</span><span class="o">)</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="k">inherit</span><span class="w"> </span><span class="n">BaseClass</span><span class="bp">()</span>
<span class="w">    </span><span class="k">override</span><span class="w"> </span><span class="n">obj</span><span class="p">.</span><span class="nf">AbstractMethod</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">x</span>

<span class="k">let</span><span class="w"> </span><span class="nv">v1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">BaseClass</span><span class="bp">()</span><span class="w"> </span><span class="c1">// not allowed – BaseClass is abstract</span>
<span class="k">let</span><span class="w"> </span><span class="nv">v2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">(</span><span class="n">SubClass</span><span class="o">(</span><span class="mi">7</span><span class="o">)</span><span class="w"> </span><span class="o">:&gt;</span><span class="w"> </span><span class="n">BaseClass</span><span class="o">)</span>

<span class="n">v2</span><span class="o">.</span><span class="n">AbstractMethod</span><span class="w"> </span><span class="mi">6</span><span class="w"> </span><span class="c1">// evaluates to 13</span>
</code></pre></div>
<p>In this example, <code>BaseClass()</code> declares the abstract slot <code>AbstractMethod</code> and the <code>SubClass</code> type
supplies an implementation member <code>obj.AbstractMethod</code>, which takes an argument <code>n</code> and returns
the sum of <code>n</code> and the argument that was passed in the instantiation of <code>SubClass</code>. The <code>v2</code> object
instantiates <code>SubClass</code> with the value <code>7</code>, so <code>v2.AbstractMethod 6</code> evaluates to <code>13</code>.</p>
<p>The combination of an abstract slot declaration and a default implementation of that slot create the
F# equivalent of a “virtual” method in some other languages—that is, an abstract member that is
guaranteed to have an implementation. For example:</p>
<div class="highlight"><pre><span></span><code><span class="k">type</span><span class="w"> </span><span class="nc">BaseClass</span><span class="bp">()</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="k">abstract</span><span class="w"> </span><span class="n">AbstractMethodWithDefaultImplementation</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">int</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">int</span>
<span class="w">    </span><span class="k">default</span><span class="w"> </span><span class="kt">obj</span><span class="o">.</span><span class="n">AbstractMethodWithDefaultImplementation</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">n</span>

<span class="k">type</span><span class="w"> </span><span class="nc">SubClass1</span><span class="o">(</span><span class="n">x</span><span class="o">:</span><span class="w"> </span><span class="n">int</span><span class="o">)</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="k">inherit</span><span class="w"> </span><span class="n">BaseClass</span><span class="bp">()</span>
<span class="w">    </span><span class="k">override</span><span class="w"> </span><span class="n">obj</span><span class="p">.</span><span class="nf">AbstractMethodWithDefaultImplementation</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">x</span>

<span class="k">type</span><span class="w"> </span><span class="nc">SubClass2</span><span class="bp">()</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="k">inherit</span><span class="w"> </span><span class="n">BaseClass</span><span class="bp">()</span>

<span class="k">let</span><span class="w"> </span><span class="nv">v1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">BaseClass</span><span class="bp">()</span><span class="w"> </span><span class="c1">// allowed -- BaseClass contains a default implementation</span>
<span class="k">let</span><span class="w"> </span><span class="nv">v2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">(</span><span class="n">SubClass1</span><span class="o">(</span><span class="mi">7</span><span class="o">)</span><span class="w"> </span><span class="o">:&gt;</span><span class="w"> </span><span class="n">BaseClass</span><span class="o">)</span>
<span class="k">let</span><span class="w"> </span><span class="nv">v3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">(</span><span class="n">SubClass2</span><span class="bp">()</span><span class="w"> </span><span class="o">:&gt;</span><span class="w"> </span><span class="n">BaseClass</span><span class="o">)</span>

<span class="n">v1</span><span class="o">.</span><span class="n">AbstractMethodWithDefaultImplementation</span><span class="w"> </span><span class="mi">6</span><span class="w"> </span><span class="c1">// evaluates to 6</span>
<span class="n">v2</span><span class="o">.</span><span class="n">AbstractMethodWithDefaultImplementation</span><span class="w"> </span><span class="mi">6</span><span class="w"> </span><span class="c1">// evaluates to 13</span>
<span class="n">v3</span><span class="o">.</span><span class="n">AbstractMethodWithDefaultImplementation</span><span class="w"> </span><span class="mi">6</span><span class="w"> </span><span class="c1">// evaluates to 6</span>
</code></pre></div>
<p>Here, the <code>BaseClass</code> type contains a default implementation, so F# allows the instantiation of <code>v1</code>. The
instantiation of <code>v2</code> is the same as in the previous example. The instantiation of <code>v3</code> is similar to that of
<code>v1</code>, because <code>SubClass2</code> inherits directly from <code>BaseClass</code> and does not override the <code>default</code> method.</p>
<blockquote>
<p>Note: The keywords <code>override</code> and <code>default</code> are synonyms. However, it is recommended
that <code>default</code> be used only when the implementation is in the same class as the
corresponding abstract definition; <code>override</code> should be used in other cases. This records
the intended role of the member implementation.</p>
</blockquote>
<p>Implementations may override methods from System.Object:</p>
<div class="highlight"><pre><span></span><code><span class="k">type</span><span class="w"> </span><span class="nc">BaseClass</span><span class="bp">()</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="k">override</span><span class="w"> </span><span class="n">obj</span><span class="p">.</span><span class="nf">ToString</span><span class="bp">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;I&#39;m an instance of BaseClass&quot;</span>

<span class="k">type</span><span class="w"> </span><span class="nc">SubClass</span><span class="o">(</span><span class="n">x</span><span class="o">:</span><span class="w"> </span><span class="n">int</span><span class="o">)</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="k">inherit</span><span class="w"> </span><span class="n">BaseClass</span><span class="bp">()</span>
<span class="w">    </span><span class="k">override</span><span class="w"> </span><span class="n">obj</span><span class="p">.</span><span class="nf">ToString</span><span class="bp">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;I&#39;m an instance of SubClass&quot;</span>
</code></pre></div>
<p>In this example, <code>BaseClass</code> inherits from <code>System.Object</code> and overrides the <code>ToString</code> method from
that class. The <code>SubClass</code>, in turn, inherits from <code>BaseClass</code> and overrides its version of the <code>ToString</code>
method.</p>
<p>Implementations may include abstract property members:</p>
<div class="highlight"><pre><span></span><code><span class="o">[&lt;</span><span class="n">AbstractClass</span><span class="o">&gt;]</span>
<span class="k">type</span><span class="w"> </span><span class="nc">BaseClass</span><span class="bp">()</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="k">let</span><span class="w"> </span><span class="nv">mutable</span><span class="w"> </span><span class="n">data1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span>
<span class="w">    </span><span class="k">let</span><span class="w"> </span><span class="nv">mutable</span><span class="w"> </span><span class="n">data2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span>
<span class="w">    </span><span class="k">abstract</span><span class="w"> </span><span class="n">AbstractProperty</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">int</span>
<span class="w">    </span><span class="k">abstract</span><span class="w"> </span><span class="n">AbstractSettableProperty</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">int</span><span class="w"> </span><span class="k">with</span><span class="w"> </span><span class="n">get</span><span class="o">,</span><span class="w"> </span><span class="n">set</span>

<span class="w">    </span><span class="k">abstract</span><span class="w"> </span><span class="n">AbstractPropertyWithDefaultImplementation</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">int</span>
<span class="w">    </span><span class="k">default</span><span class="w"> </span><span class="kt">obj</span><span class="o">.</span><span class="n">AbstractPropertyWithDefaultImplementation</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span>

<span class="w">    </span><span class="k">abstract</span><span class="w"> </span><span class="n">AbstractSettablePropertyWithDefaultImplementation</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">int</span><span class="w"> </span><span class="k">with</span><span class="w"> </span><span class="n">get</span><span class="o">,</span><span class="w"> </span><span class="n">set</span>
<span class="w">    </span><span class="k">default</span><span class="w"> </span><span class="kt">obj</span><span class="o">.</span><span class="n">AbstractSettablePropertyWithDefaultImplementation</span>
<span class="w">        </span><span class="k">with</span><span class="w"> </span><span class="n">get</span><span class="bp">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data2</span>
<span class="w">        </span><span class="ow">and</span><span class="w"> </span><span class="n">set</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data2</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">v</span>

<span class="k">type</span><span class="w"> </span><span class="nc">SubClass</span><span class="o">(</span><span class="n">x</span><span class="o">:</span><span class="w"> </span><span class="n">int</span><span class="o">)</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="k">inherit</span><span class="w"> </span><span class="n">BaseClass</span><span class="bp">()</span>
<span class="w">    </span><span class="k">let</span><span class="w"> </span><span class="nv">mutable</span><span class="w"> </span><span class="n">data1b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span>
<span class="w">    </span><span class="k">let</span><span class="w"> </span><span class="nv">mutable</span><span class="w"> </span><span class="n">data2b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span>
<span class="w">    </span><span class="k">override</span><span class="w"> </span><span class="n">obj</span><span class="p">.</span><span class="nf">AbstractProperty</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">x</span>
<span class="w">    </span><span class="k">override</span><span class="w"> </span><span class="n">obj</span><span class="p">.</span><span class="nf">AbstractSettableProperty</span>
<span class="w">        </span><span class="k">with</span><span class="w"> </span><span class="n">get</span><span class="bp">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data1b</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">x</span>
<span class="w">        </span><span class="ow">and</span><span class="w"> </span><span class="n">set</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data1b</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">x</span>
<span class="w">    </span><span class="k">override</span><span class="w"> </span><span class="n">obj</span><span class="p">.</span><span class="nf">AbstractPropertyWithDefaultImplementation</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">6</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">x</span>
<span class="w">    </span><span class="k">override</span><span class="w"> </span><span class="n">obj</span><span class="p">.</span><span class="nf">AbstractSettablePropertyWithDefaultImplementation</span>
<span class="w">        </span><span class="k">with</span><span class="w"> </span><span class="n">get</span><span class="bp">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data2b</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">x</span>
<span class="w">        </span><span class="ow">and</span><span class="w"> </span><span class="n">set</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data2b</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">x</span>
</code></pre></div>
<p>The same rules apply to both property members and method members. In the preceding example,
<code>BaseClass</code> includes abstract properties named <code>AbstractProperty</code>, <code>AbstractSettableProperty</code>,
<code>AbstractPropertyWithDefaultImplementation</code>, and
<code>AbstractSettablePropertyWithDefaultImplementation</code> and provides default implementations for the
latter two. <code>SubClass</code> provides implementations for <code>AbstractProperty</code> and <code>AbstractSettableProperty</code>,
and overrides the default implementations for <code>AbstractPropertyWithDefaultImplementation</code> and
<code>AbstractSettablePropertyWithDefaultImplementation</code>.</p>
<p>Implementation members may also implement CLI events (<a href="./#81310-members-represented-as-events">§8.13.10</a>). In this case, the member
should be marked with the <code>CLIEvent</code> attribute. For example:</p>
<div class="highlight"><pre><span></span><code><span class="k">type</span><span class="w"> </span><span class="nc">ChannelChangedHandler</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">delegate</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="kt">obj</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">int</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">unit</span>

<span class="o">[&lt;</span><span class="n">AbstractClass</span><span class="o">&gt;]</span>
<span class="k">type</span><span class="w"> </span><span class="nc">BaseClass</span><span class="bp">()</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="o">[&lt;</span><span class="n">CLIEvent</span><span class="o">&gt;]</span>
<span class="w">    </span><span class="k">abstract</span><span class="w"> </span><span class="n">ChannelChanged</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">IEvent</span><span class="o">&lt;</span><span class="n">ChannelChangedHandler</span><span class="o">,</span><span class="w"> </span><span class="n">int</span><span class="o">&gt;</span>

<span class="k">type</span><span class="w"> </span><span class="nc">SubClass</span><span class="bp">()</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="k">inherit</span><span class="w"> </span><span class="n">BaseClass</span><span class="bp">()</span>
<span class="w">    </span><span class="k">let</span><span class="w"> </span><span class="nv">mutable</span><span class="w"> </span><span class="n">channel</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">7</span>
<span class="w">    </span><span class="k">let</span><span class="w"> </span><span class="nv">channelChanged</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Event</span><span class="o">&lt;</span><span class="n">ChannelChangedHandler</span><span class="o">,</span><span class="w"> </span><span class="n">int</span><span class="o">&gt;</span><span class="bp">()</span>

<span class="w">    </span><span class="o">[&lt;</span><span class="n">CLIEvent</span><span class="o">&gt;]</span>
<span class="w">    </span><span class="k">override</span><span class="w"> </span><span class="n">self</span><span class="p">.</span><span class="nf">ChannelChanged</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">channelChanged</span><span class="o">.</span><span class="n">Publish</span>
<span class="w">    </span><span class="k">member</span><span class="w"> </span><span class="n">self</span><span class="p">.</span><span class="nf">Channel</span>
<span class="w">        </span><span class="k">with</span><span class="w"> </span><span class="n">get</span><span class="w"> </span><span class="bp">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">channel</span>
<span class="w">        </span><span class="ow">and</span><span class="w"> </span><span class="n">set</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">channel</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">v</span><span class="o">;</span><span class="w"> </span><span class="n">channelChanged</span><span class="o">.</span><span class="n">Trigger</span><span class="o">(</span><span class="n">self</span><span class="o">,</span><span class="w"> </span><span class="n">channel</span><span class="o">)</span>
</code></pre></div>
<p><code>BaseClass</code> implements the CLI event <code>IEvent</code>, so the abstract member <code>ChannelChanged</code> is marked with
<code>[&lt;CLIEvent&gt;]</code> as described earlier in §8.13.10. SubClass provides an implementation of the abstract
member, so the [<CLIEvent>] attribute must also precede the <code>override</code> declaration in <code>SubClass</code>.</p>
<h3 id="8143-interface-implementations">8.14.3 Interface Implementations</h3>
<p>An <em>interface implementation</em> specifies how objects of a given type support a particular interface. An
interface in a type definition indicates that objects of the defined type support the interface. For
example:</p>
<div class="highlight"><pre><span></span><code><span class="k">type</span><span class="w"> </span><span class="nc">IIncrement</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="k">abstract</span><span class="w"> </span><span class="n">M</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">int</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">int</span>

<span class="k">type</span><span class="w"> </span><span class="nc">IDecrement</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="k">abstract</span><span class="w"> </span><span class="n">M</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">int</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">int</span>

<span class="k">type</span><span class="w"> </span><span class="nc">C</span><span class="bp">()</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="k">interface</span><span class="w"> </span><span class="n">IIncrement</span><span class="w"> </span><span class="k">with</span>
<span class="w">        </span><span class="k">member</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="nf">M</span><span class="o">(</span><span class="n">n</span><span class="o">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span>
<span class="w">    </span><span class="k">interface</span><span class="w"> </span><span class="n">IDecrement</span><span class="w"> </span><span class="k">with</span>
<span class="w">        </span><span class="k">member</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="nf">M</span><span class="o">(</span><span class="n">n</span><span class="o">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span>
</code></pre></div>
<p>The first two definitions in the example are implementations of the interfaces <code>IIncrement</code> and
<code>IDecrement</code>. In the last definition,the type <code>C</code> supports these two interfaces.</p>
<p>No type may implement multiple different instantiations of a generic interface, either directly or
through inheritance. For example, the following is not permitted:</p>
<div class="highlight"><pre><span></span><code><span class="c1">// This type definition is not permitted because it implements two instantiations</span>
<span class="c1">// of the same generic interface</span>
<span class="k">type</span><span class="w"> </span><span class="nc">ClassThatTriesToImplemenTwoInstantiations</span><span class="bp">()</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="k">interface</span><span class="w"> </span><span class="nn">System</span><span class="p">.</span><span class="n">IComparable</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;</span><span class="w"> </span><span class="k">with</span>
<span class="w">        </span><span class="k">member</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="nf">CompareTo</span><span class="o">(</span><span class="n">n</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">int</span><span class="o">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span>
<span class="w">    </span><span class="k">interface</span><span class="w"> </span><span class="nn">System</span><span class="p">.</span><span class="n">IComparable</span><span class="o">&lt;</span><span class="kt">string</span><span class="o">&gt;</span><span class="w"> </span><span class="k">with</span>
<span class="w">        </span><span class="k">member</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="nf">CompareTo</span><span class="o">(</span><span class="n">n</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">string</span><span class="o">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span>
</code></pre></div>
<p>Each member of an interface implementation is checked as follows:</p>
<ul>
<li>The member must be an instance member definition.</li>
<li><em>Dispatch Slot Inference</em> (<a href="../inference-procedures/#147-dispatch-slot-inference">§14.7</a>) is applied.</li>
<li>The member is checked under the assumption that the “this” variable has the enclosing type.</li>
</ul>
<p>In the following example, the value <code>x</code> has type <code>C</code>.</p>
<div class="highlight"><pre><span></span><code><span class="k">type</span><span class="w"> </span><span class="nc">C</span><span class="bp">()</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="k">interface</span><span class="w"> </span><span class="n">IIncrement</span><span class="w"> </span><span class="k">with</span>
<span class="w">        </span><span class="k">member</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="nf">M</span><span class="o">(</span><span class="n">n</span><span class="o">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span>
<span class="w">    </span><span class="k">interface</span><span class="w"> </span><span class="n">IDecrement</span><span class="w"> </span><span class="k">with</span>
<span class="w">        </span><span class="k">member</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="nf">M</span><span class="o">(</span><span class="n">n</span><span class="o">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span>
</code></pre></div>
<p>All interface implementations are made explicit. In its first implementation, every interface must be
completely implemented, even in an abstract class. However, interface implementations may be
inherited from a base class. In particular, if a class <code>C</code> implements interface <code>I</code>, and a base class of <code>C</code>
implements interface <code>I</code>, then <code>C</code> is not required to implement all the methods of <code>I</code>; it can implement
all, some, or none of the methods instead. For example:</p>
<div class="highlight"><pre><span></span><code><span class="k">type</span><span class="w"> </span><span class="nc">I1</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="k">abstract</span><span class="w"> </span><span class="n">V1</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">string</span>
<span class="w">    </span><span class="k">abstract</span><span class="w"> </span><span class="n">V2</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">string</span>

<span class="k">type</span><span class="w"> </span><span class="nc">I2</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="k">inherit</span><span class="w"> </span><span class="n">I1</span>
<span class="w">    </span><span class="k">abstract</span><span class="w"> </span><span class="n">V3</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">string</span>

<span class="k">type</span><span class="w"> </span><span class="nc">C1</span><span class="bp">()</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="k">interface</span><span class="w"> </span><span class="n">I1</span><span class="w"> </span><span class="k">with</span>
<span class="w">        </span><span class="k">member</span><span class="w"> </span><span class="n">this</span><span class="p">.</span><span class="nf">V1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;C1&quot;</span>
<span class="w">        </span><span class="k">member</span><span class="w"> </span><span class="n">this</span><span class="p">.</span><span class="nf">V2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;C2&quot;</span>
<span class="c1">// This is OK</span>
<span class="k">type</span><span class="w"> </span><span class="nc">C2</span><span class="bp">()</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="k">inherit</span><span class="w"> </span><span class="n">C1</span><span class="bp">()</span>

<span class="c1">// This is also OK; C3 implements I2 but not I1.</span>
<span class="k">type</span><span class="w"> </span><span class="nc">C3</span><span class="bp">()</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="k">inherit</span><span class="w"> </span><span class="n">C1</span><span class="bp">()</span>
<span class="w">    </span><span class="k">interface</span><span class="w"> </span><span class="n">I2</span><span class="w"> </span><span class="k">with</span>
<span class="w">        </span><span class="k">member</span><span class="w"> </span><span class="n">this</span><span class="p">.</span><span class="nf">V3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;C3&quot;</span>

<span class="c1">// This is also OK; C4 implements one method in I1.</span>
<span class="k">type</span><span class="w"> </span><span class="nc">C4</span><span class="bp">()</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="k">inherit</span><span class="w"> </span><span class="n">C1</span><span class="bp">()</span>
<span class="w">    </span><span class="k">interface</span><span class="w"> </span><span class="n">I1</span><span class="w"> </span><span class="k">with</span>
<span class="w">        </span><span class="k">member</span><span class="w"> </span><span class="n">this</span><span class="p">.</span><span class="nf">V2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;C2b&quot;</span>
</code></pre></div>
<h2 id="815-equality-hashing-and-comparison">8.15 Equality, Hashing, and Comparison</h2>
<p>Functional programming in F# frequently involves the use of structural equality, structural hashing,
and structural comparison. For example, the following expression evaluates to <code>true</code>, because tuple
types support structural equality:</p>
<div class="highlight"><pre><span></span><code><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="o">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="mi">2</span><span class="o">)</span>
</code></pre></div>
<p>Likewise, these two function calls return identical values:</p>
<div class="highlight"><pre><span></span><code><span class="n">hash</span><span class="w"> </span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">+</span><span class="mi">1</span><span class="w"> </span><span class="o">)</span>
<span class="n">hash</span><span class="w"> </span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">)</span>
</code></pre></div>
<p>Similarly, an ordering on constituent parts of a tuple induces an ordering on tuples themselves, so all
the following evaluate to <code>true</code>:</p>
<div class="highlight"><pre><span></span><code><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="mi">2</span><span class="o">)</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="mi">3</span><span class="o">)</span>
<span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="mi">2</span><span class="o">)</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="o">(</span><span class="mi">2</span><span class="o">,</span><span class="w"> </span><span class="mi">3</span><span class="o">)</span>
<span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="mi">2</span><span class="o">)</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="o">(</span><span class="mi">2</span><span class="o">,</span><span class="w"> </span><span class="mi">1</span><span class="o">)</span>
<span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="mi">2</span><span class="o">)</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="mi">0</span><span class="o">)</span>
</code></pre></div>
<p>The same applies to lists, options, arrays, and user-defined record, union, and struct types whose
constituent field types permit structural equality, hashing, and comparison. For example, given:</p>
<div class="highlight"><pre><span></span><code><span class="k">type</span><span class="w"> </span><span class="nc">R</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">R</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="n">int</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">int</span>
</code></pre></div>
<p>then all of the following also evaluate to <code>true</code>:</p>
<div class="highlight"><pre><span></span><code><span class="n">R</span><span class="w"> </span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="o">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">R</span><span class="w"> </span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="mi">2</span><span class="o">)</span>

<span class="n">R</span><span class="w"> </span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="mi">3</span><span class="o">)</span><span class="w"> </span><span class="o">&lt;&gt;</span><span class="w"> </span><span class="n">R</span><span class="w"> </span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="mi">2</span><span class="o">)</span>

<span class="n">hash</span><span class="w"> </span><span class="o">(</span><span class="n">R</span><span class="w"> </span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="o">))</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">hash</span><span class="w"> </span><span class="o">(</span><span class="n">R</span><span class="w"> </span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="mi">2</span><span class="o">))</span>

<span class="n">R</span><span class="w"> </span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="mi">2</span><span class="o">)</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">R</span><span class="w"> </span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="mi">3</span><span class="o">)</span>
<span class="n">R</span><span class="w"> </span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="mi">2</span><span class="o">)</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">R</span><span class="w"> </span><span class="o">(</span><span class="mi">2</span><span class="o">,</span><span class="w"> </span><span class="mi">3</span><span class="o">)</span>
<span class="n">R</span><span class="w"> </span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="mi">2</span><span class="o">)</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">R</span><span class="w"> </span><span class="o">(</span><span class="mi">2</span><span class="o">,</span><span class="w"> </span><span class="mi">1</span><span class="o">)</span>
<span class="n">R</span><span class="w"> </span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="mi">2</span><span class="o">)</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">R</span><span class="w"> </span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="mi">0</span><span class="o">)</span>
</code></pre></div>
<p>To facilitate this, by default, record, union, and struct type definitions—called <em>structural types</em> —
implicitly include compiler-generated declarations for structural equality, hashing, and comparison.
These implicit declarations consist of the following for structural equality and hashing:</p>
<div class="highlight"><pre><span></span><code><span class="k">override</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="nf">GetHashCode</span><span class="bp">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">...</span>
<span class="k">override</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="nf">Equals</span><span class="o">(</span><span class="n">y</span><span class="o">:</span><span class="kt">obj</span><span class="o">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">...</span>
<span class="w">    </span><span class="k">interface</span><span class="w"> </span><span class="nn">System</span><span class="p">.</span><span class="nn">Collections</span><span class="p">.</span><span class="n">IStructuralEquatable</span><span class="w"> </span><span class="k">with</span>
<span class="w">    </span><span class="k">member</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="nf">Equals</span><span class="o">(</span><span class="n">yobj</span><span class="o">:</span><span class="w"> </span><span class="kt">obj</span><span class="o">,</span><span class="w"> </span><span class="n">comparer</span><span class="o">:</span><span class="w"> </span><span class="nn">System</span><span class="p">.</span><span class="nn">Collections</span><span class="p">.</span><span class="n">IEqualityComparer</span><span class="o">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">...</span>
<span class="w">    </span><span class="k">member</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="nf">GetHashCode</span><span class="o">(</span><span class="n">comparer</span><span class="o">:</span><span class="w"> </span><span class="nn">System</span><span class="p">.</span><span class="n">IEqualityComparer</span><span class="o">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">...</span>
</code></pre></div>
<p>The following declarations enable structural comparison:</p>
<div class="highlight"><pre><span></span><code><span class="k">interface</span><span class="w"> </span><span class="nn">System</span><span class="p">.</span><span class="n">IComparable</span><span class="w"> </span><span class="k">with</span>
<span class="w">    </span><span class="k">member</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="nf">CompareTo</span><span class="o">(</span><span class="n">y</span><span class="o">:</span><span class="kt">obj</span><span class="o">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">...</span>
<span class="k">interface</span><span class="w"> </span><span class="nn">System</span><span class="p">.</span><span class="nn">Collections</span><span class="p">.</span><span class="n">IStructuralComparable</span><span class="w"> </span><span class="k">with</span>
<span class="w">    </span><span class="k">member</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="nf">CompareTo</span><span class="o">(</span><span class="n">yobj</span><span class="o">:</span><span class="w"> </span><span class="kt">obj</span><span class="o">,</span><span class="w"> </span><span class="n">comparer</span><span class="o">:</span><span class="w"> </span><span class="nn">System</span><span class="p">.</span><span class="nn">Collections</span><span class="p">.</span><span class="n">IComparer</span><span class="o">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">...</span>
</code></pre></div>
<p>For exception types, implicit declarations for structural equality and hashings are generated, but
declarations for structural comparison are not generated. Implicit declarations are never generated
for interface, delegate, class, or enum types. Enum types implicitly derive support for equality,
hashing, and comparison through their underlying representation as integers.</p>
<h3 id="8151-equality-attributes">8.15.1 Equality Attributes</h3>
<p>Several attributes affect the equality behavior of types:</p>
<div class="highlight"><pre><span></span><code><span class="nn">FSharp</span><span class="p">.</span><span class="nn">Core</span><span class="p">.</span><span class="n">NoEquality</span>
<span class="nn">FSharp</span><span class="p">.</span><span class="nn">Core</span><span class="p">.</span><span class="n">ReferenceEquality</span>
<span class="nn">FSharp</span><span class="p">.</span><span class="nn">Core</span><span class="p">.</span><span class="n">StructuralEquality</span>
<span class="nn">FSharp</span><span class="p">.</span><span class="nn">Core</span><span class="p">.</span><span class="n">CustomEquality</span>
</code></pre></div>
<p>The following table lists the effects of each attribute on a type:</p>
<table>
<thead>
<tr>
<th>Attrribute</th>
<th>Effect</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>NoEquality</code></td>
<td>▪ No equality or hashing is generated for the type.<br>▪ The type does not satisfy the <code>ty : equality</code> constraint.</td>
</tr>
<tr>
<td><code>ReferenceEquality</code></td>
<td>▪ No equality or hashing is generated for the type.<br> ▪ The defaults for <code>System.Object</code> will implicitly be used.</td>
</tr>
<tr>
<td><code>StructuralEquality</code></td>
<td>▪ The type must be a structural type.<br>▪ All structural field types <code>ty</code> must satisfy <code>ty : equality</code>.</td>
</tr>
<tr>
<td><code>CustomEquality</code></td>
<td>▪ The type must have an explicit implementation of <code>override Equals(obj: obj)</code></td>
</tr>
<tr>
<td>None</td>
<td>▪ For a non-structural type, the default is <code>ReferenceEquality</code>.<br>▪ For a structural type:<br>The default is <code>NoEquality</code> if any structural field type <code>F</code> fails <code>F : equality</code>.<br>The default is <code>StructuralEquality</code> if all structural field types <code>F</code> satisfy <code>F : equality</code>.</td>
</tr>
</tbody>
</table>
<p>Equality inference also determines the <em>constraint dependencies</em> of a generic structural type. That is:</p>
<ul>
<li>If a structural type has a generic parameter <code>'T</code> and <code>T : equality</code> is necessary to make the type
    default to <code>StructuralEquality</code>, then the <code>EqualityConditionalOn</code> constraint dependency is
    inferred for <code>'T</code>.</li>
</ul>
<h3 id="8152-comparison-attributes">8.15.2 Comparison Attributes</h3>
<p>The comparison behavior of types can be affected by the following attributes:</p>
<div class="highlight"><pre><span></span><code><span class="nn">FSharp</span><span class="p">.</span><span class="nn">Core</span><span class="p">.</span><span class="n">NoComparison</span>
<span class="nn">FSharp</span><span class="p">.</span><span class="nn">Core</span><span class="p">.</span><span class="n">StructuralComparison</span>
<span class="nn">FSharp</span><span class="p">.</span><span class="nn">Core</span><span class="p">.</span><span class="n">CustomComparison</span>
</code></pre></div>
<p>The following table lists the effects of each attribute on a type.</p>
<table>
<thead>
<tr>
<th>Attribute</th>
<th>Effect</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>NoComparison</code></td>
<td>▪ No comparisons are generated for the type.<br>▪ The type does not satisfy the <code>ty : comparison</code> constraint.</td>
</tr>
<tr>
<td><code>StructuralComparison</code></td>
<td>▪ The type must be a structural type other than an exception type.<br>▪ All structural field types <code>ty</code> must satisfy <code>ty : comparison</code>.<br>▪ An exception type may not have the <code>StructuralComparison</code> attribute.</td>
</tr>
<tr>
<td><code>CustomComparison</code></td>
<td>▪ The type must have an explicit implementation of one or both of the following:<br><code>interface System.IComparable</code><br><code>interface System.Collections.IStructuralComparable</code><br>▪ A structural type that has an explicit implementation of one or both of these contracts must specify the <code>CustomComparison</code> attribute.</td>
</tr>
<tr>
<td>None</td>
<td>▪ For a non-structural or exception type, the default is <code>NoComparison</code>.<br>▪ For any other structural type:<br>The default is <code>NoComparison</code> if any structural field type <code>F</code> fails <code>F : comparison</code>.<br>The default is <code>StructuralComparison</code> if all structural field types <code>F</code> satisfy <code>F : comparison</code>.</td>
</tr>
</tbody>
</table>
<p>This check also determines the <em>constraint dependencies</em> of a generic structural type. That is:</p>
<ul>
<li>If a structural type has a generic parameter <code>'T</code> and <code>T</code> : comparison is necessary to make the type
    default to <code>StructuralComparison</code>, then the <code>ComparisonConditionalOn</code> constraint dependency is
    inferred for <code>'T</code>.</li>
</ul>
<p>For example:</p>
<div class="highlight"><pre><span></span><code><span class="o">[&lt;</span><span class="n">StructuralEquality</span><span class="o">;</span><span class="w"> </span><span class="n">StructuralComparison</span><span class="o">&gt;]</span>
<span class="k">type</span><span class="w"> </span><span class="nc">X</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">X</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="o">(</span><span class="n">int</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">int</span><span class="o">)</span>
</code></pre></div>
<p>results in the following message:</p>
<div class="highlight"><pre><span></span><code>The struct, record or union type &#39;X&#39; has the &#39;StructuralEquality&#39; attribute
but the component type &#39;(int -&gt; int)&#39; does not satisfy the &#39;equality&#39; constraint
</code></pre></div>
<p>For example, given</p>
<div class="highlight"><pre><span></span><code><span class="k">type</span><span class="w"> </span><span class="nc">R1</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="o">{</span><span class="w"> </span><span class="n">myData</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">int</span><span class="w"> </span><span class="o">}</span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="k">member</span><span class="w"> </span><span class="n">Create</span><span class="bp">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="n">myData</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">}</span>

<span class="o">[&lt;</span><span class="n">ReferenceEquality</span><span class="o">&gt;]</span>
<span class="k">type</span><span class="w"> </span><span class="nc">R2</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="o">{</span><span class="w"> </span><span class="k">mutable</span><span class="w"> </span><span class="n">myState</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">int</span><span class="w"> </span><span class="o">}</span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="k">member</span><span class="w"> </span><span class="n">Fresh</span><span class="bp">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="n">myState</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">}</span>

<span class="o">[&lt;</span><span class="n">StructuralEquality</span><span class="o">;</span><span class="w"> </span><span class="n">NoComparison</span><span class="w"> </span><span class="o">&gt;]</span>
<span class="k">type</span><span class="w"> </span><span class="nc">R3</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="o">{</span><span class="w"> </span><span class="n">someType</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="nn">System</span><span class="p">.</span><span class="n">Type</span><span class="w"> </span><span class="o">}</span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="k">member</span><span class="w"> </span><span class="n">Make</span><span class="bp">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="n">someType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">typeof</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;</span><span class="w"> </span><span class="o">}</span>
</code></pre></div>
<p>then the following expressions all evaluate to <code>true</code>:</p>
<div class="highlight"><pre><span></span><code><span class="nn">R1</span><span class="p">.</span><span class="n">Create</span><span class="bp">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nn">R1</span><span class="p">.</span><span class="n">Create</span><span class="bp">()</span>
<span class="ow">not</span><span class="w"> </span><span class="o">(</span><span class="nn">R2</span><span class="p">.</span><span class="n">Fresh</span><span class="bp">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nn">R2</span><span class="p">.</span><span class="n">Fresh</span><span class="bp">()</span><span class="o">)</span>
<span class="nn">R3</span><span class="p">.</span><span class="n">Make</span><span class="bp">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nn">R3</span><span class="p">.</span><span class="n">Make</span><span class="bp">()</span>
</code></pre></div>
<p>Combinations of <code>equality</code> and <code>comparion</code> attributes are restricted. If any of the following attributes
are present, they may be used only in the following combinations:</p>
<ul>
<li>No attributes</li>
<li><code>[&lt;NoComparison&gt;]</code> on any type</li>
<li><code>[&lt;NoEquality; NoComparison&gt;]</code> on any type</li>
<li><code>[&lt;CustomEquality; NoComparison&gt;]</code> on a structural type</li>
<li><code>[&lt;ReferenceEquality&gt;]</code> on a non-struct structural type</li>
<li><code>[&lt;ReferenceEquality; NoComparison&gt;]</code> on a non-struct structural type</li>
<li><code>[&lt;StructuralEquality; NoComparison&gt;]</code> on a structural type</li>
<li><code>[&lt;CustomEquality; CustomComparison&gt;]</code> on a structural type</li>
<li><code>[&lt;StructuralEquality; CustomComparison&gt;]</code> on a structural type</li>
<li><code>[&lt;StructuralEquality; StructuralComparison&gt;]</code> on a structural type</li>
</ul>
<h3 id="8153-behavior-of-the-generated-objectequals-implementation">8.15.3 Behavior of the Generated Object.Equals Implementation</h3>
<p>For a type definition <code>T</code>, the behavior of the generated <code>override x.Equals(y:obj) = ...</code>
implementation is as follows.</p>
<ol>
<li>
<p>If the interface <code>System.IComparable</code> has an explicit implementation, then just call
    <code>System.IComparable.CompareTo</code>:</p>
<div class="highlight"><pre><span></span><code><span class="k">override</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="nf">Equals</span><span class="o">(</span><span class="n">y</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">obj</span><span class="o">)</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="o">((</span><span class="n">x</span><span class="w"> </span><span class="o">:&gt;</span><span class="w"> </span><span class="nn">System</span><span class="p">.</span><span class="n">IComparable</span><span class="o">).</span><span class="n">CompareTo</span><span class="o">(</span><span class="n">y</span><span class="o">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="o">)</span>
</code></pre></div>
</li>
<li>
<p>Otherwise:</p>
<ul>
<li>Convert the <code>y</code> argument to type <code>T</code>. If the conversion fails, return <code>false</code>.</li>
<li>Return <code>false</code> if <code>T</code> is a reference type and <code>y</code> is null.</li>
<li>If <code>T</code> is a struct or record type, invoke <code>FSharp.Core.Operators.(=)</code> on each corresponding pair
   of fields of <code>x</code> and <code>y</code> in declaration order. This method stops at the first <code>false</code> result and
   returns <code>false</code>.</li>
<li>If <code>T</code> is a union type, invoke <code>FSharp.Core.Operators.(=)</code> first on the index of the union cases
   for the two values, then on each corresponding field pair of <code>x</code> and <code>y</code> for the data carried by
   the union case. This method stops at the first <code>false</code> result and returns <code>false</code>.</li>
<li>If <code>T</code> is an exception type, invoke <code>FSharp.Core.Operators.(=)</code> on the index of the tags for the
   two values, then on each corresponding field pair for the data carried by the exception. This
   method stops at the first <code>false</code> result and returns <code>false</code>.</li>
</ul>
</li>
</ol>
<h3 id="8154-behavior-of-the-generated-compareto-implementations">8.15.4 Behavior of the Generated CompareTo Implementations</h3>
<p>For a type <code>T</code>, the behavior of the generated <code>System.IComparable.CompareTo</code> implementation is as
follows:</p>
<ul>
<li>Convert the <code>y</code> argument to type <code>T</code>. If the conversion fails, raise the <code>InvalidCastException</code>.</li>
<li>If <code>T</code> is a reference type and <code>y</code> is <code>null</code>, return <code>1</code>.</li>
<li>If <code>T</code> is a struct or record type, invoke <code>FSharp.Core.Operators.compare</code> on each corresponding pair
    of fields of <code>x</code> and <code>y</code> in declaration order, and return the first non-zero result.</li>
<li>If <code>T</code> is a union type, invoke <code>FSharp.Core.Operators.compare</code> first on the index of the union cases
    for the two values, and then on each corresponding field pair of <code>x</code> and <code>y</code> for the data carried by
    the union case. Return the first non-zero result.</li>
</ul>
<p>The first few lines of this code can be written:</p>
<div class="highlight"><pre><span></span><code><span class="k">interface</span><span class="w"> </span><span class="nn">System</span><span class="p">.</span><span class="n">IComparable</span><span class="w"> </span><span class="k">with</span>
<span class="w">    </span><span class="k">member</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="nf">CompareTo</span><span class="o">(</span><span class="n">y</span><span class="o">:</span><span class="kt">obj</span><span class="o">)</span><span class="w"> </span><span class="o">=</span>
<span class="w">        </span><span class="k">let</span><span class="w"> </span><span class="nv">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">(</span><span class="kt">obj</span><span class="w"> </span><span class="o">:?&gt;</span><span class="w"> </span><span class="n">T</span><span class="o">)</span><span class="w"> </span><span class="k">in</span>
<span class="w">            </span><span class="k">match</span><span class="w"> </span><span class="kt">obj</span><span class="w"> </span><span class="k">with</span>
<span class="w">            </span><span class="o">|</span><span class="w"> </span><span class="k">null</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="mi">1</span>
<span class="w">            </span><span class="o">|</span><span class="w"> </span><span class="o">_</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="o">...</span>
</code></pre></div>
<h3 id="8155-behavior-of-the-generated-gethashcode-implementations">8.15.5 Behavior of the Generated GetHashCode Implementations</h3>
<p>For a type <code>T</code>, the generated <code>System.Object.GetHashCode()</code> override implements a combination hash
of the structural elements of a structural type.</p>
<h3 id="8156-behavior-of-hash-and-compare">8.15.6 Behavior of Hash, =, and Compare</h3>
<p>The generated equality, hashing, and comparison declarations that are described in sections <a href="./#8153-behavior-of-the-generated-objectequals-implementation">§8.15.3</a>,
<a href="./#8154-behavior-of-the-generated-compareto-implementations">§8.15.4</a>, and <a href="./#8155-behavior-of-the-generated-gethashcode-implementations">§8.15.5</a> use the <code>hash</code>, <code>=</code> and <code>compare</code> functions from the F# library. The behavior of these
library functions is defined by the pseudocode later in this section. This code ensures:</p>
<ul>
<li>Ordinal comparison for strings</li>
<li>Structural comparison for arrays</li>
<li>Natural ordering for native integers (which do not support <code>System.IComparable</code>)</li>
</ul>
<h4 id="81561-pseudocode-for-fsharpcoreoperatorscompare">8.15.6.1 Pseudocode for FSharp.Core.Operators.compare</h4>
<blockquote>
<p>Note: In practice, fast (but semantically equivalent) code is emitted for direct calls to
(=), compare, and hash for all base types, and faster paths are used for comparing most
arrays.</p>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">open</span><span class="w"> </span><span class="nn">System</span>

<span class="sd">/// Pseudo code for code implementation of generic comparison.</span>
<span class="k">let</span><span class="w"> </span><span class="nv">rec</span><span class="w"> </span><span class="n">compare</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="k">let</span><span class="w"> </span><span class="nv">xobj</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">box</span><span class="w"> </span><span class="n">x</span>
<span class="w">    </span><span class="k">let</span><span class="w"> </span><span class="nv">yobj</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">box</span><span class="w"> </span><span class="n">y</span>
<span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="n">xobj</span><span class="o">,</span><span class="w"> </span><span class="n">yobj</span><span class="w"> </span><span class="k">with</span>
<span class="w">    </span><span class="o">|</span><span class="w"> </span><span class="k">null</span><span class="o">,</span><span class="w"> </span><span class="k">null</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="mi">0</span>
<span class="w">    </span><span class="o">|</span><span class="w"> </span><span class="k">null</span><span class="o">,</span><span class="w"> </span><span class="o">_</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span>
<span class="w">    </span><span class="o">|</span><span class="w"> </span><span class="o">_,</span><span class="w"> </span><span class="k">null</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="mi">1</span>

<span class="w">    </span><span class="c1">// Use Ordinal comparison for strings</span>
<span class="w">    </span><span class="o">|</span><span class="w"> </span><span class="o">(:?</span><span class="w"> </span><span class="kt">string</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">x</span><span class="o">),(:?</span><span class="w"> </span><span class="kt">string</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">y</span><span class="o">)</span><span class="w"> </span><span class="o">-&gt;</span>
<span class="w">        </span><span class="nn">String</span><span class="p">.</span><span class="n">CompareOrdinal</span><span class="o">(</span><span class="n">x</span><span class="o">,</span><span class="w"> </span><span class="n">y</span><span class="o">)</span>

<span class="w">    </span><span class="c1">// Special types not supporting IComparable</span>
<span class="w">    </span><span class="o">|</span><span class="w"> </span><span class="o">(:?</span><span class="w"> </span><span class="n">Array</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">arr1</span><span class="o">),</span><span class="w"> </span><span class="o">(:?</span><span class="w"> </span><span class="n">Array</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">arr2</span><span class="o">)</span><span class="w"> </span><span class="o">-&gt;</span>
<span class="w">        </span><span class="o">...</span><span class="w"> </span><span class="n">compare</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">arrays</span><span class="w"> </span><span class="n">by</span><span class="w"> </span><span class="n">rank</span><span class="o">,</span><span class="w"> </span><span class="n">lengths</span><span class="w"> </span><span class="ow">and</span><span class="w"> </span><span class="n">elements</span><span class="w"> </span><span class="o">...</span>
<span class="w">    </span><span class="o">|</span><span class="w"> </span><span class="o">(:?</span><span class="w"> </span><span class="kt">nativeint</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">x</span><span class="o">),(:?</span><span class="w"> </span><span class="kt">nativeint</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">y</span><span class="o">)</span><span class="w"> </span><span class="o">-&gt;</span>
<span class="w">        </span><span class="o">...</span><span class="w"> </span><span class="n">compare</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">native</span><span class="w"> </span><span class="n">integers</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">and</span><span class="w"> </span><span class="n">y</span><span class="o">....</span>
<span class="w">    </span><span class="o">|</span><span class="w"> </span><span class="o">(:?</span><span class="w"> </span><span class="kt">unativeint</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">x</span><span class="o">),(:?</span><span class="w"> </span><span class="kt">unativeint</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">y</span><span class="o">)</span><span class="w"> </span><span class="o">-&gt;</span>
<span class="w">        </span><span class="o">...</span><span class="w"> </span><span class="n">compare</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">unsigned</span><span class="w"> </span><span class="n">integers</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">and</span><span class="w"> </span><span class="n">y</span><span class="o">....</span>

<span class="w">    </span><span class="c1">// Check for IComparable</span>
<span class="w">    </span><span class="o">|</span><span class="w"> </span><span class="o">(:?</span><span class="w"> </span><span class="n">IComparable</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">x</span><span class="o">),_</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">x</span><span class="o">.</span><span class="n">CompareTo</span><span class="o">(</span><span class="n">yobj</span><span class="o">)</span>
<span class="w">    </span><span class="o">|</span><span class="w"> </span><span class="o">_,(:?</span><span class="w"> </span><span class="n">IComparable</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">yc</span><span class="o">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="o">-(</span><span class="n">sign</span><span class="o">(</span><span class="n">yc</span><span class="o">.</span><span class="n">CompareTo</span><span class="o">(</span><span class="n">xobj</span><span class="o">)))</span>

<span class="w">    </span><span class="c1">// Otherwise raise a runtime error</span>
<span class="w">    </span><span class="o">|</span><span class="w"> </span><span class="o">_</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">raise</span><span class="w"> </span><span class="o">(</span><span class="k">new</span><span class="w"> </span><span class="n">ArgumentException</span><span class="o">(...))</span>
</code></pre></div>
<h4 id="81562-pseudo-code-for-fsharpcoreoperators">8.15.6.2 Pseudo code for FSharp.Core.Operators.(=)</h4>
<blockquote>
<p>Note: In practice, fast (but semantically equivalent) code is emitted for direct calls to
(=), compare, and hash for all base types, and faster paths are used for comparing most
arrays</p>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">open</span><span class="w"> </span><span class="nn">System</span>
<span class="sd">/// Pseudo code for core implementation of generic equality.</span>
<span class="k">let</span><span class="w"> </span><span class="nv">rec</span><span class="w"> </span><span class="o">(=)</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="k">let</span><span class="w"> </span><span class="nv">xobj</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">box</span><span class="w"> </span><span class="n">x</span>
<span class="w">    </span><span class="k">let</span><span class="w"> </span><span class="nv">yobj</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">box</span><span class="w"> </span><span class="n">y</span>
<span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="n">xobj</span><span class="o">,</span><span class="n">yobj</span><span class="w"> </span><span class="k">with</span>
<span class="w">    </span><span class="o">|</span><span class="w"> </span><span class="k">null</span><span class="o">,</span><span class="k">null</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="k">true</span>
<span class="w">    </span><span class="o">|</span><span class="w"> </span><span class="k">null</span><span class="o">,_</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="k">false</span>
<span class="w">    </span><span class="o">|</span><span class="w"> </span><span class="o">_,</span><span class="k">null</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="k">false</span>

<span class="w">    </span><span class="c1">// Special types not supporting IComparable</span>
<span class="w">    </span><span class="o">|</span><span class="w"> </span><span class="o">(:?</span><span class="w"> </span><span class="n">Array</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">arr1</span><span class="o">),</span><span class="w"> </span><span class="o">(:?</span><span class="w"> </span><span class="n">Array</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">arr2</span><span class="o">)</span><span class="w"> </span><span class="o">-&gt;</span>
<span class="w">        </span><span class="o">...</span><span class="w"> </span><span class="n">compare</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">arrays</span><span class="w"> </span><span class="n">by</span><span class="w"> </span><span class="n">rank</span><span class="o">,</span><span class="w"> </span><span class="n">lengths</span><span class="w"> </span><span class="ow">and</span><span class="w"> </span><span class="n">elements</span><span class="w"> </span><span class="o">...</span>

<span class="w">    </span><span class="c1">// Ensure NaN semantics on recursive calls</span>
<span class="w">    </span><span class="o">|</span><span class="w"> </span><span class="o">(:?</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">f1</span><span class="o">),</span><span class="w"> </span><span class="o">(:?</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">f2</span><span class="o">)</span><span class="w"> </span><span class="o">-&gt;</span>
<span class="w">        </span><span class="o">...</span><span class="w"> </span><span class="n">IEEE</span><span class="w"> </span><span class="n">equality</span><span class="w"> </span><span class="n">on</span><span class="w"> </span><span class="n">f1</span><span class="w"> </span><span class="ow">and</span><span class="w"> </span><span class="n">f2</span><span class="o">...</span>
<span class="w">    </span><span class="o">|</span><span class="w"> </span><span class="o">(:?</span><span class="w"> </span><span class="kt">float32</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">f1</span><span class="o">),</span><span class="w"> </span><span class="o">(:?</span><span class="w"> </span><span class="kt">float32</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">f2</span><span class="o">)</span><span class="w"> </span><span class="o">-&gt;</span>
<span class="w">        </span><span class="o">...</span><span class="w"> </span><span class="n">IEEE</span><span class="w"> </span><span class="n">equality</span><span class="w"> </span><span class="n">on</span><span class="w"> </span><span class="n">f1</span><span class="w"> </span><span class="ow">and</span><span class="w"> </span><span class="n">f2</span><span class="o">...</span>

<span class="w">    </span><span class="c1">// Otherwise use Object.Equals. This is reference equality</span>
<span class="w">    </span><span class="c1">// for reference types unless an override is provided (implicitly</span>
<span class="w">    </span><span class="c1">// or explicitly).</span>
<span class="w">    </span><span class="o">|</span><span class="w"> </span><span class="o">_</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">xobj</span><span class="o">.</span><span class="n">Equals</span><span class="o">(</span><span class="n">yobj</span><span class="o">)</span>
</code></pre></div>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
    <div class="md-copyright__highlight">
      Copyright © 2005-2025 F# contributors. Made available under the <a href='https://creativecommons.org/licenses/by/4.0/'>Creative Commons CC-by 4.0</a> licence.
    </div>
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    
      
      <script id="__config" type="application/json">{"base": "..", "features": [], "search": "../assets/javascripts/workers/search.973d3a69.min.js", "tags": null, "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}, "version": null}</script>
    
    
      <script src="../assets/javascripts/bundle.f55a23d4.min.js"></script>
      
    
  </body>
</html>