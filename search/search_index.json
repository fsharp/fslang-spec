{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Front Matter","text":"<p>This documentation is work-in-progress, aiming at a F# 10 specification.</p> <p>Historically, a F# spec was maintained as a Word document until about 2018, when some of the then new F# 4.1 features were added. Since then, changes to the language were documented in RFC documents in the language design repo.</p> <p>This site is the output of an ongoing effort to make the spec complete and to make it more accessible and community-maintainable. The starting point was the F# 4.1 spec that was converted to markdown and cleaned. The RFCs are now one by one added. Their status is listed here. Check the source repo for ways to contribute.</p>"},{"location":"#notices","title":"Notices","text":"<p>Authors of the original F# spec:   Don Syme, with assistance from Anar Alimov, Keith Battocchi, Jomo Fisher, Michael Hale, Jack Hu, Luke Hoban, Tao Liu, Dmitry Lomov,  James Margetson, Brian McNamara, Joe Pamer, Penny Orwick, Daniel Quirk, Kevin Ransom, Chris Smith, Matteo Taveggia, Donna Malayeri, Wonseok Chae, Uladzimir Matsveyeu, Lincoln Atkinson, and others.For contributors to the later versions, see the github history / insights.</p> <p>\u00a9 2005 - 2025 various contributors. Made available under the Creative Commons CC-by 4.0 licence.</p> <p>Product and company names mentioned herein may be the trademarks of their respective owners.</p> <p>The sources for this content can be found on github.</p> <p>This version was created from sources on 12/01/2025 21:06:43</p>"},{"location":"basic-grammar-elements/","title":"4. Basic Grammar Elements","text":"<p>This section defines grammar elements that are used repeatedly in later sections.</p>"},{"location":"basic-grammar-elements/#41-operator-names","title":"4.1 Operator Names","text":"<p>Several places in the grammar refer to an <code>ident-or-op</code> rather than an <code>ident</code> :</p> <pre><code>ident-or-op :=\n    | ident\n    | ( op-name )\n    | (*)\nop-name :=\n    | symbolic-op\n    | range-op-name\n    | active-pattern-op-name\nrange-op-name :=\n    | ..\n    | .. ..\nactive-pattern-op-name :=\n    | | ident | ... | ident |\n    | | ident | ... | ident | _ |\n</code></pre> <p>In operator definitions, the operator name is placed in parentheses. For example:</p> <pre><code>let (+++) x y = (x, y)\n</code></pre> <p>This example defines the binary operator <code>+++</code>. The text <code>(+++)</code> is an <code>ident-or-op</code> that acts as an identifier with associated text <code>+++</code>. Likewise, for active pattern definitions (\u00a7 7), the active pattern case names are placed in parentheses, as in the following example:</p> <pre><code>let (|A|B|C|) x = if x &lt; 0 then A elif x = 0 then B else C\n</code></pre> <p>Because an <code>ident-or-op</code> acts as an identifier, such names can be used in expressions. For example:</p> <pre><code>List.map ((+) 1) [ 1; 2; 3 ]\n</code></pre> <p>The three character token <code>(*)</code> defines the <code>*</code> operator:</p> <pre><code>let (*) x y = (x + y)\n</code></pre> <p>To define other operators that begin with <code>*</code>, whitespace must follow the opening parenthesis; otherwise <code>(*</code> is interpreted as the start of a comment:</p> <pre><code>let ( *+* ) x y = (x + y)\n</code></pre> <p>Symbolic operators and some symbolic keywords have a compiled name that is visible in the compiled form of F# programs. The compiled names are shown below.</p> <pre><code>[]    op_Nil\n::    op_ColonColon\n+     op_Addition\n-     op_Subtraction\n*     op_Multiply\n/     op_Division\n**    op_Exponentiation\n@     op_Append\n^     op_Concatenate\n%     op_Modulus\n&amp;&amp;&amp;   op_BitwiseAnd\n|||   op_BitwiseOr\n^^^   op_ExclusiveOr\n&lt;&lt;&lt;   op_LeftShift\n~~~   op_LogicalNot\n&gt;&gt;&gt;   op_RightShift\n~+    op_UnaryPlus\n~-    op_UnaryNegation\n=     op_Equality\n&lt;&gt;    op_Inequality\n&lt;=    op_LessThanOrEqual\n&gt;=    op_GreaterThanOrEqual\n&lt;     op_LessThan\n&gt;     op_GreaterThan\n?     op_Dynamic\n?&lt;-   op_DynamicAssignment\n|&gt;    op_PipeRight\n||&gt;   op_PipeRight2\n|||&gt;  op_PipeRight3\n&lt;|    op_PipeLeft\n&lt;||   op_PipeLeft2\n&lt;|||  op_PipeLeft3\n!     op_Dereference\n&gt;&gt;    op_ComposeRight\n&lt;&lt;    op_ComposeLeft\n&lt;@ @&gt; op_Quotation\n&lt;@@ @@&gt; op_QuotationUntyped\n~%    op_Splice\n~%%   op_SpliceUntyped\n~&amp;    op_AddressOf\n~&amp;&amp;   op_IntegerAddressOf\n||    op_BooleanOr\n&amp;&amp;    op_BooleanAnd\n+=    op_AdditionAssignment\n- =   op_SubtractionAssignment\n*=    op_MultiplyAssignment\n/=    op_DivisionAssignment\n..    op_Range\n.. .. op_RangeStep\n</code></pre> <p>Compiled names for other symbolic operators are <code>op_N1</code> ... <code>Nn</code> where <code>N1</code> to <code>Nn</code> are the names for the characters as shown in the table below. For example, the symbolic identifier <code>&lt;*</code> has the compiled name <code>op_LessMultiply</code>:</p> <pre><code>&gt;   Greater\n&lt;   Less\n+   Plus\n-   Minus\n*   Multiply\n=   Equals\n~   Twiddle\n%   Percent\n.   Dot\n&amp;   Amp\n|   Bar\n@   At\n#   Hash\n^   Hat\n!   Bang\n?   Qmark\n/   Divide\n.   Dot\n:   Colon\n(   LParen\n,   Comma\n)   RParen\n[   LBrack\n]   RBrack\n</code></pre>"},{"location":"basic-grammar-elements/#42-long-identifiers","title":"4.2 Long Identifiers","text":"<p>Long identifiers <code>long-ident</code> are sequences of identifiers that are separated by \u2018<code>.</code>\u2019 and optional whitespace. Long identifiers <code>long-ident-or-op</code> are long identifiers that may terminate with an operator name.</p> <pre><code>long-ident := ident '.' ... '.' ident\nlong-ident-or-op :=\n    | long-ident '.' ident-or-op\n    | ident-or-op\n</code></pre>"},{"location":"basic-grammar-elements/#43-constants","title":"4.3 Constants","text":"<p>The constants in the following table may be used in patterns and expressions. The individual lexical formats for the different constants are defined in \u00a73.</p> <pre><code>const :=\n    | sbyte\n    | int16\n    | int32\n    | int64                 -- 8, 16, 32 and 64-bit signed integers\n    | byte\n    | uint16\n    | uint32\n    | int                   -- 32 - bit signed integer\n    | uint64                -- 8, 16, 32 and 64-bit unsigned integers\n    | ieee32                -- 32 - bit number of type \"float32\"\n    | ieee64                -- 64 - bit number of type \"float\"\n    | bignum                -- User or library-defined integral literal type\n    | char                  -- Unicode character of type \"char\"\n    | string v              -- String of type \"string\" (System.String)\n    | verbatim-string       -- String of type \"string\" (System.String)\n    | triple-quoted-string  -- String of type \"string\" (System.String)\n    | bytestring            -- String of type \"byte[]\"\n    | verbatim-bytearray    -- String of type \"byte[]\"\n    | bytechar              -- Char of type \"byte\"\n    | false | true          -- Boolean constant of type \"bool\"\n    | '(' ')'               -- unit constant of type \"unit\"\n</code></pre>"},{"location":"basic-grammar-elements/#44-operators-and-precedence","title":"4.4 Operators and Precedence","text":""},{"location":"basic-grammar-elements/#441-categorization-of-symbolic-operators","title":"4.4.1 Categorization of Symbolic Operators","text":"<p>The following <code>symbolic-op</code> tokens can be used to form prefix and infix expressions. The marker <code>OP</code> represents all <code>symbolic-op</code> tokens that begin with the indicated prefix, except for tokens that appear elsewhere in the table.</p> <pre><code>infix-or-prefix-op :=\n    +, -, +., -., %, %%, &amp;, &amp;&amp;, ?+, ?-\nprefix-op :=\n    infix-or-prefix-op\n    ~ ~~ ~~~    (and any repetitions of ~)\n    !OP         (except !=)\ninfix-op :=\n    infix-or-prefix-op\n    -OP +OP |OP &lt;OP &gt;OP =OP &amp;OP ^OP *OP /OP %OP @OP !=OP\n                (or any of these preceded by one or more '.' or '?')\n    :=\n    ::\n    $\n    or\n    ?\n</code></pre> <p>The operators <code>+</code>, <code>-</code>, <code>+.</code>, <code>-.</code>, <code>%</code>, <code>%%</code>, <code>&amp;</code>, <code>&amp;&amp;</code>, <code>?+</code>, <code>?-</code> can be used as both prefix and infix operators. When these operators are used as prefix operators, the tilde character is prepended internally to generate the operator name so that the parser can distinguish such usage from an infix use of the operator. For example, <code>-x</code> is parsed as an application of the operator <code>~-</code> to the identifier <code>x</code>. This generated name is also used in definitions for these prefix operators. Consequently, the definitions of the following prefix operators include the <code>~</code> character:</p> <pre><code>// To completely redefine the prefix + operator:\nlet (~+) x = x\n</code></pre> <pre><code>// To completely redefine the infix + operator to be addition modulo- 7\nlet (+) a b = (a + b) % 7\n</code></pre> <pre><code>// To define the operator on a type:\ntype C(n:int) =\nlet n = n % 7\n    member x.N = n\n    static member (~+) (x:C) = x\n    static member (~-) (x:C) = C(-n)\n    static member (+) (x1:C,x2:C) = C(x1.N+x2.N)\n    static member (-) (x1:C,x2:C) = C(x1.N-x2.N)\n</code></pre> <p>The <code>::</code> operator is special. It represents the union case for the addition of an element to the head of an immutable linked list, and cannot be redefined, although it may be used to form infix expressions. It always accepts arguments in tupled form \u2014 as do all union cases \u2014 rather than in curried form.</p>"},{"location":"basic-grammar-elements/#442-precedence-of-symbolic-operators-and-patternexpression-constructs","title":"4.4.2 Precedence of Symbolic Operators and Pattern/Expression Constructs","text":"<p>Rules of precedence control the order of evaluation for ambiguous expression and pattern constructs. Higher precedence items are evaluated before lower precedence items.</p> <p>The following table shows the order of precedence, from highest to lowest, and indicates whether the operator or expression is associated with the token to its left or right. The <code>OP</code> marker represents the <code>symbolic-op</code> tokens that begin with the specified prefix, except those listed elsewhere in the table. For example, <code>+OP</code> represents any token that begins with a plus sign, unless the token appears elsewhere in the table.</p> Operator or expression Associativity Comments <code>f&lt;types&gt;</code> Left High-precedence type application; see \u00a715.3 <code>f(x)</code> Left High-precedence application; see \u00a715.2 <code>.</code> <code>?</code> Left prefix-op Left Applies to prefix uses of these symbols <code>\\| rule</code> Right Pattern matching rules <code>f x</code> <code>lazy x</code> <code>assert x</code> Left <code>**OP</code> Right <code>*OP</code> <code>/OP</code> <code>%OP</code> Left <code>-OP</code> <code>+OP</code> Left Applies to infix uses of these symbols <code>:?</code> Not associative <code>::</code> Right <code>^OP</code> <code>@OP</code> Right <code>!=OP</code> <code>&lt;OP</code> <code>&gt;OP</code> <code>=OP</code> <code>\\|OP</code> <code>&amp;OP</code> <code>$</code> Left <code>:&gt;</code> <code>:?&gt;</code> Right <code>&amp;</code> <code>&amp;&amp;</code> Left <code>or</code> <code>\\|\\|</code> Left <code>,</code> Not associative <code>:=</code> Right <code>-&gt;</code> Right <code>if</code> Not associative <code>function</code>, <code>fun</code>, <code>match</code>, <code>try</code> Not associative <code>let</code> Not associative <code>;</code> Right <code>\\|</code> Left <code>when</code> Right <code>as</code> Right <p>If ambiguous grammar rules (such as the rules from \u00a76) involve tokens in the table, a construct that appears earlier in the table has higher precedence than a construct that appears later in the table.</p> <p>The associativity indicates whether the operator or construct applies to the item to the left or the right of the operator.</p> <p>For example, consider the following token stream:</p> <pre><code>a + b * c\n</code></pre> <p>In this expression, the <code>expr infix-op expr</code> rule for <code>b * c</code> takes precedence over the <code>expr infix-op expr</code> rule for <code>a + b</code>, because the <code>*</code> operator has higher precedence than the <code>+</code> operator. Thus, this expression can be pictured as follows:</p> <pre><code>   a + b * c\n// _________\n//     _____\n</code></pre> <p>rather than</p> <pre><code>   a + b * c\n// _________\n// _____\n</code></pre> <p>Likewise, given the tokens</p> <pre><code>a * b * c\n</code></pre> <p>the left associativity of <code>*</code> means we can picture the resolution of the ambiguity as:</p> <pre><code>   a * b * c\n// _____\n</code></pre> <p>In the preceding table, leading <code>.</code> characters are ignored when determining precedence for infix operators. For example, <code>.*</code> has the same precedence as <code>*.</code> This rule ensures that operators such as <code>.*</code>, which is frequently used for pointwise-operation on matrices, have the expected precedence.</p> <p>The table entries marked as \u201cHigh-precedence application\u201d and \u201cHigh-precedence type application\u201d are the result of the augmentation of the lexical token stream, as described in \u00a715.1.2 and \u00a715.3.</p>"},{"location":"custom-attributes-and-reflection/","title":"13. Custom Attributes and Reflection","text":"<p>CLI languages use metadata inspection and the <code>System.Reflection</code> libraries to make guarantees about how compiled entities appear at runtime. They also allow entities to be attributed by static data, and these attributes may be accessed and read by tools and running programs. This chapter describes these mechanisms for F#.</p> <p>Attributes are given by the following grammar:</p> <pre><code>attribute := attribute-target : opt object-construction\n\nattribute-set := [&lt; attribute ; ... ; attribute &gt;]\n\nattributes := attribute-set ... attribute-set\n\nattribute-target :=\n    assembly\n    module\n    return\n    field\n    property\n    param\n    type\n    constructor\n    event\n</code></pre>"},{"location":"custom-attributes-and-reflection/#131-custom-attributes","title":"13.1 Custom Attributes","text":"<p>CLI languages support the notion of custom attributes which can be added to most declarations. These are added to the corresponding elaborated and compiled forms of the constructs to which they apply.</p> <p>Custom attributes can be applied only to certain target language constructs according to the <code>AttributeUsage</code> attribute, which is found on the attribute class itself. An error occurs if an attribute is attached to a language construct that does not allow that attribute.</p> <p>Custom attributes are not permitted on function or value definitions in expressions or computation expressions. Attributes on parameters are given as follows:</p> <pre><code>let foo([&lt;SomeAttribute&gt;] a) = a + 5\n</code></pre> <p>If present, the arguments to a custom attribute must be literal constant expressions , or arrays of the same.</p> <p>Custom attributes on return values are given as follows:</p> <pre><code>let foo a : [&lt;SomeAttribute&gt;] = a + 5\n</code></pre> <p>Custom attributes on primary constructors are given before the arguments and before any accessibility annotation:</p> <pre><code>type Foo1 [&lt;System.Obsolete(\"don't use me\")&gt;] () =\n    member x.Bar() = 1\n\ntype Foo2 [&lt;System.Obsolete(\"don't use me\")&gt;] private () =\n    member x.Bar() = 1\n</code></pre> <p>Custom attributes are mapped to compiled CLI metadata as follows:</p> <ul> <li>Custom attributes map to the element that is specified by their target, if a target is given.</li> <li>A custom attribute on a type <code>type</code> is compiled to a custom attribute on the corresponding CLI     type definition, whose <code>System.Type</code> object is returned by <code>typeof&lt;type&gt;</code>.</li> <li>By default, a custom attribute on a record field <code>F</code> for a type <code>T</code> is compiled to a custom attribute     on the CLI property for the field that is named <code>F</code>, unless the target of the attribute is <code>field</code>, in     which case it becomes a custom attribute on the underlying backing field for the CLI property     that is named <code>_F</code>.</li> <li>A custom attribute on a union case <code>ABC</code> for a type <code>T</code> is compiled to a custom attribute on a static     method on the CLI type definition <code>T</code>. This method is called:</li> <li><code>get_ABC</code> if the union case takes no arguments</li> <li><code>ABC</code> otherwise</li> <li>Custom attributes on arguments are propagated only for arguments of member definitions, and     not for \u201clet\u201d-bound function definitions.</li> <li>Custom attributes on generic parameters are not propagated.</li> </ul> <p>Custom attributes that appear immediately preceding \u201cdo\u201d statements in modules anywhere in an assembly are attached to one of the following:</p> <ul> <li>The <code>main</code> entry point of the program.</li> <li>The compiled module.</li> <li>The compiled assembly.</li> </ul> <p>Custom attributes are attached to the main entry point if it is valid for them to be attached to a method according to the <code>AttributeUsage</code> attribute that is found on the attribute class itself, and likewise for the assembly. If it is valid for the attribute to be attached to either the main method or the assembly. the main method takes precedence.</p> <p>For example, the <code>STAThread</code> attribute should be placed immediately before a top-level <code>do</code> statement.</p> <pre><code>let main() =\n    let form = new System.Windows.Forms.Form()\n    System.Windows.Forms.Application.Run(form)\n\n[&lt;STAThread&gt;]\ndo main()\n</code></pre>"},{"location":"custom-attributes-and-reflection/#1311-custom-attributes-and-signatures","title":"13.1.1 Custom Attributes and Signatures","text":"<p>During signature checking, custom attributes attached to items in F# signature files (<code>.fsi</code> files) are combined with custom attributes on the corresponding element from the implementation file according to the following algorithm:</p> <ul> <li>Start with lists <code>AImpl</code> and <code>ASig</code> containing the attributes in the implementation and signature, in     declaration order.</li> <li>Check each attribute in <code>AImpl</code> against the available attributes in <code>ASig</code>.</li> <li>If <code>ASig</code> contains an attribute that is an exact match after evaluating attribute arguments, then     ignore the attribute in the implementation, remove the attribute from <code>ASig</code> , and continue     checking;</li> <li>If <code>ASig</code> contains an attribute that has the same attribute type but is not an exact match, then     give a warning and ignore the attribute in the implementation;</li> <li>Otherwise, keep the attribute in the implementation.</li> </ul> <p>The compiled element contains the compiled forms of the attributes from the signature and the retained attributes from the implementation.</p> <p>This means:</p> <ul> <li>When an implementation has an attribute <code>X(\"abc\")</code> and the signature is missing the     attribute, then no warning is given and the attribute appears in the compiled assembly.</li> <li>When a signature has an attribute <code>X(\"abc\")</code> and the implementation is missing the attribute,     then no warning is given, and the attribute appears in the compiled assembly.</li> <li>When an implementation has an attribute <code>X(\"abc\")</code> and the signature has attribute     <code>X(\"def\")</code>, then a warning is given, and only <code>X(\"def\")</code> appears in the compiled assembly.</li> </ul>"},{"location":"custom-attributes-and-reflection/#132-reflected-forms-of-declaration-elements","title":"13.2 Reflected Forms of Declaration Elements","text":"<p>The <code>typeof</code> and <code>typedefof</code> F# library operators return a <code>System.Type</code> object for an F# type definition. According to typical implementations of the CLI execution environment, the <code>System.Type</code> object in turn can be used to access further information about the compiled form of F# member declarations. If this operation is supported in a particular implementation of F#, then the following rules describe which declaration elements have corresponding <code>System.Reflection</code> objects:</p> <ul> <li>All member declarations are present as corresponding methods, properties or events.</li> <li>Private and internal members and types are included.</li> <li>Type abbreviations are not given corresponding <code>System.Type</code> definitions.</li> </ul> <p>In addition:</p> <ul> <li>F# modules are compiled to provide a corresponding compiled CLI type declaration and     <code>System.Type</code> object, although the <code>System.Type</code> object is not accessible by using the <code>typeof</code>     operator.</li> </ul> <p>However:</p> <ul> <li>Internal and private function and value definitions are not guaranteed to be given corresponding     compiled CLI metadata definitions. They may be removed by optimization.</li> <li>Additional internal and private compiled type and member definitions may be present in the     compiled CLI assembly as necessary for the correct implementation of F# programs.</li> <li>The <code>System.Reflection</code> operations return results that are consistent with the erasure of F# type     abbreviations and F# unit-of-measure annotations.</li> <li>The definition of new units of measure results in corresponding compiled CLI type declarations     with an associated <code>System.Type</code>.</li> </ul>"},{"location":"expressions/","title":"6. Expressions","text":"<p>The expression forms and related elements are as follows:</p> <pre><code>expr :=\n    const                               -- a constant value\n    ( expr )                            -- block expression\n    begin expr end                      -- block expression\n    long-ident-or-op                    -- lookup expression\n    expr '.' long-ident-or-op           -- dot lookup expression\n    expr expr                           -- application expression\n    expr ( expr )                       -- high precedence application\n    expr &lt; types &gt;                      -- type application expression\n    expr infix-op expr                  -- infix application expression\n    prefix-op expr                      -- prefix application expression\n    expr .[ expr ]                      -- indexed lookup expression\n    expr .[ slice-ranges ]              -- slice expression\n    expr &lt;- expr                        -- assignment expression\n    expr , ... , expr                   -- tuple expression\n    struct (expr , ... , expr)          -- struct tuple expression\n    new type expr                       -- simple object expression\n    { new base-call object-members interface-impls } -- object expression\n    { field-initializers }              -- record expression\n    { expr with field-initializers }    -- record cloning expression\n    [ expr ; ... ; expr ]               -- list expression\n    [| expr ; ... ; expr |]             -- array expression\n    expr { comp-or-range-expr }         -- computation expression\n    [ comp-or-range-expr ]              -- computed list expression\n    [| comp-or-range-expr |]            -- computed array expression\n    lazy expr                           -- delayed expression\n    null                                -- the \"null\" value for a reference type\n    expr : type                         -- type annotation\n    expr :&gt; type                        -- static upcast coercion\n    expr :? type                        -- dynamic type test\n    expr :?&gt; type                       -- dynamic downcast coercion\n    upcast expr                         -- static upcast expression\n    downcast expr                       -- dynamic downcast expression\n    let function-defn in expr           -- function definition expression\n    let value-defn in expr              -- value definition expression\n    let rec function-or-value-defns in expr -- recursive definition expression\n    use ident = expr in expr            -- deterministic disposal expression\n    use ident = fixed expr              -- pinned pointer expression\n    fun argument-pats - &gt; expr          -- function expression\n    function rules                      -- matching function expression\n    expr ; expr                         -- sequential execution expression\n    match expr with rules               -- match expression\n    try expr with rules                 -- try/with expression\n    try expr finally expr               -- try/finally expression\n    if expr then expr elif-branches? else-branch? -- conditional expression\n    while expr do expr done             -- while loop\n    for ident = expr to expr do expr done -- simple for loop\n    for pat in expr - or-range-expr do expr done -- enumerable for loop\n    assert expr                         -- assert expression\n    &lt;@ expr @&gt;                          -- quoted expression\n    &lt;@@ expr @@&gt;                        -- quoted expression\n\n    %expr                              -- expression splice\n    %%expr                              -- weakly typed expression splice\n\n    (static-typars : (member-sig) expr) -\u2013 static member invocation\n</code></pre> <p>Expressions are defined in terms of patterns and other entities that are discussed later in this specification. The following constructs are also used:</p> <pre><code>exprs := expr ',' ... ',' expr\n\nexpr-or-range-expr :=\n    expr\n    range-expr\n\nelif-branches := elif-branch ... elif-branch\n\nelif-branch := elif expr then expr\n\nelse-branch := else expr\n\nfunction-or-value-defn :=\n    function-defn\n    value-defn\n\nfunction-defn :=\n    inline? access? ident-or-op typar-defns? argument-pats return-type? = expr\n\nvalue-defn :=\n    mutable? access? pat typar-defns? return-type? = expr\n\nreturn-type :=\n    : type\n\nfunction-or-value-defns :=\n    function-or-value-defn and ... and function-or-value-defn\n\nargument-pats := atomic-pat ... atomic-pat\n\nfield-initializer :=\n    long-ident = expr -- field initialization\n\nfield-initializers := field-initializer ; ... ; field-initializer\n\nobject-construction :=\n    type expr -- construction expression\n    type      -- interface construction expression\n\nbase-call :=\n    object-construction          -- anonymous base construction\n    object-construction as ident -- named base construction\n\ninterface-impls := interface-impl ... interface-impl\n\ninterface-impl :=\n    interface type object-members? -- interface implementation\n\nobject-members := with member-defns end\n\nmember-defns := member-defn ... member-defn\n</code></pre> <p>Computation and range expressions are defined in terms of the following productions:</p> <pre><code>comp-or-range-expr :=\n    comp-expr\n    short-comp-expr\n    range-expr\n\ncomp-expr :=\n    let! pat = expr in comp-expr    -- binding computation\n    let pat = expr in comp-expr\n    do! expr in comp-expr           -- sequential computation\n    do expr in comp-expr\n    use! pat = expr in comp-expr    -- auto cleanup computation\n    use pat = expr in comp-expr\n    yield! expr                     -- yield computation\n    yield expr                      -- yield result\n    return! expr                    -- return computation\n    return expr                     -- return result\n    if expr then comp - expr        -- control flow or imperative action\n    if expr then expr else comp-expr\n    match! expr with pat -&gt; comp-expr | ... | pat -&gt; comp-expr\n    match expr with pat -&gt; comp-expr | ... | pat -&gt; comp-expr\n    try comp - expr with pat -&gt; comp-expr | ... | pat -&gt; comp-expr\n    try comp - expr finally expr\n    while expr do comp - expr done\n    for ident = expr to expr do comp - expr done\n    for pat in expr - or-range-expr do comp - expr done\n    comp - expr ; comp - expr\n    expr\n\nshort-comp-expr :=\n    for pat in expr-or-range-expr -&gt; expr -- yield result\n\nrange-expr :=\n    expr .. expr                    -- range sequence\n    expr .. expr .. expr            -- range sequence with skip\n\nslice-ranges := slice-range , ... , slice-range\n\nslice-range :=\n    expr                            -- slice of one element of dimension\n    expr ..                         -- slice from index to end\n    .. expr                         -- slice from start to index\n    expr .. expr                    -- slice from index to index\n    '*'                             -- slice from start to end\n</code></pre>"},{"location":"expressions/#61-some-checking-and-inference-terminology","title":"6.1 Some Checking and Inference Terminology","text":"<p>The rules applied to check individual expressions are described in the following subsections. Where necessary, these sections reference specific inference procedures such as Name Resolution (\u00a714.1) and Constraint Solving (\u00a714.5).</p> <p>All expressions are assigned a static type through type checking and inference. During type checking, each expression is checked with respect to an initial type. The initial type establishes some of the information available to resolve method overloading and other language constructs. We also use the following terminology:</p> <ul> <li> <p>The phrase \u201cthe type <code>ty1</code> is asserted to be equal to the type <code>ty2</code>\u201d or simply \u201c<code>ty1 = ty2</code> is asserted\u201d     indicates that the constraint \u201c<code>ty1 = ty2</code>\u201d is added to the current inference constraints.</p> </li> <li> <p>The phrase \u201c<code>ty1</code> is asserted to be a subtype of <code>ty2</code>\u201d or simply \u201c<code>ty1 :&gt; ty2</code> is asserted\u201d indicates     that the constraint <code>ty1 :&gt; ty2</code> is added to the current inference constraints.</p> </li> <li>The phrase \u201ctype <code>ty</code> is known to ...\u201d indicates that the initial type satisfies the given property     given the current inference constraints.</li> <li>The phrase \u201cthe expression <code>expr</code> has type <code>ty</code> \u201d means the initial type of the expression is asserted     to be equal to <code>ty</code>.</li> </ul> <p>Additionally:</p> <ul> <li>The addition of constraints to the type inference constraint set fails if it causes an inconsistent     set of constraints (\u00a714.5). In this case either an error is reported or, if we are only attempting to     assert the condition, the state of the inference procedure is left unchanged and the test fails.</li> </ul>"},{"location":"expressions/#62-elaboration-and-elaborated-expressions","title":"6.2 Elaboration and Elaborated Expressions","text":"<p>Checking an expression generates an elaborated expression in a simpler, reduced language that effectively contains a fully resolved and annotated form of the expression. The elaborated expression provides more explicit information than the source form. For example, the elaborated form of <code>System.Console.WriteLine(\"Hello\")</code> indicates exactly which overloaded method definition the call has resolved to.</p> <p>Except for this extra resolution information, elaborated forms are syntactically a subset of syntactic expressions, and in some cases (such as constants) the elaborated form is the same as the source form. This specification uses the following elaborated forms:</p> <ul> <li>Constants</li> <li>Resolved value references: <code>path</code></li> <li>Lambda expressions: <code>(fun ident -&gt; expr)</code></li> <li>Primitive object expressions</li> <li>Data expressions (tuples, union cases, array creation, record creation)</li> <li>Default initialization expressions</li> <li>Local definitions of values: <code>let ident = expr in expr</code></li> <li>Local definitions of functions:     <code>let rec ident = expr and ... and ident = expr in expr</code></li> <li>Applications of methods and functions (with static overloading resolved)</li> <li>Dynamic type coercions: <code>expr :?&gt; type</code></li> <li>Dynamic type tests: <code>expr :? type</code></li> <li>For-loops: <code>for ident in ident to ident do expr done</code></li> <li>While-loops: <code>while expr do expr done</code></li> <li>Sequencing: <code>expr; expr</code></li> <li>Try-with: <code>try expr with expr</code></li> <li>Try-finally: <code>try expr finally expr</code></li> <li>The constructs required for the elaboration of pattern matching (\u00a77.).</li> <li>Null tests</li> <li>Switches on integers and other types</li> <li>Switches on union cases</li> <li>Switches on the runtime types of objects</li> </ul> <p>The following constructs are used in the elaborated forms of expressions that make direct assignments to local variables and arrays and generate \u201cbyref\u201d pointer values. The operations are loosely named after their corresponding primitive constructs in the CLI.</p> <ul> <li>Assigning to a byref-pointer: <code>expr &lt;-stobj expr</code></li> <li>Generating a byref-pointer by taking the address of a mutable value: <code>&amp;path</code>.</li> <li>Generating a byref-pointer by taking the address of a record field: <code>&amp;(expr.field)</code></li> <li>Generating a byref-pointer by taking the address of an array element: <code>&amp;(expr.[expr])</code></li> </ul> <p>Elaborated expressions form the basis for evaluation (see \u00a76.9) and for the expression trees that quoted expressions return (see \u00a76.8).</p> <p>By convention, when describing the process of elaborating compound expressions, we omit the process of recursively elaborating sub-expressions.</p>"},{"location":"expressions/#63-data-expressions","title":"6.3 Data Expressions","text":"<p>This section describes the following data expressions:</p> <ul> <li>Simple constant expressions</li> <li>Tuple expressions</li> <li>List expressions</li> <li>Array expressions</li> <li>Record expressions</li> <li>Copy-and-update record expressions</li> <li>Function expressions</li> <li>Object expressions</li> <li>Delayed expressions</li> <li>Computation expressions</li> <li>Sequence expressions</li> <li>Range expressions</li> <li>Lists via sequence expressions</li> <li>Arrays via sequence expressions</li> <li>Null expressions</li> <li>'printf' formats</li> </ul>"},{"location":"expressions/#631-simple-constant-expressions","title":"6.3.1 Simple Constant Expressions","text":"<p>Simple constant expressions are numeric, string, Boolean and unit constants. For example:</p> <pre><code>3y              // sbyte\n32uy            // byte\n17s             // int16\n18us            // uint16\n86              // int/int32\n99u             // uint32\n99999999L       // int64\n10328273UL      // uint64\n1.              // float/double\n1.01            // float/double\n1.01e10         // float/double\n1.0f            // float32/single\n1.01f           // float32/single\n1.01e10f        // float32/single\n99999999n       // nativeint    (System.IntPtr)\n10328273un      // unativeint   (System.UIntPtr)\n99999999I       // bigint       (System.Numerics.BigInteger or user-specified)\n'a'             // char         (System.Char)\n\"3\"             // string       (String)\n\"c:\\\\home\"      // string       (System.String)\n@\"c:\\home\"      // string       (Verbatim Unicode, System.String)\n\"ASCII\"B        // byte[]\n()              // unit         (FSharp.Core.Unit)\nfalse           // bool         (System.Boolean)\ntrue            // bool         (System.Boolean)\n</code></pre> <p>Simple constant expressions have the corresponding simple type and elaborate to the corresponding simple constant value.</p> <p>Integer literals with the suffixes <code>Q</code>, <code>R</code>, <code>Z</code>, <code>I</code>, <code>N</code>, <code>G</code> are processed using the following syntactic translation:</p> <pre><code>xxxx&lt;suffix&gt;\n    For xxxx = 0                \u2192 NumericLiteral&lt;suffix&gt;.FromZero()\n    For xxxx = 1                \u2192 NumericLiteral&lt;suffix&gt;.FromOne()\n    For xxxx in the Int32 range \u2192 NumericLiteral&lt;suffix&gt;.FromInt32(xxxx)\n    For xxxx in the Int64 range \u2192 NumericLiteral&lt;suffix&gt;.FromInt64(xxxx)\n    For other numbers           \u2192 NumericLiteral&lt;suffix&gt;.FromString(\"xxxx\")\n</code></pre> <p>For example, defining a module <code>NumericLiteralZ</code> as below enables the use of the literal form <code>32Z</code> to generate a sequence of 32 \u2018Z\u2019 characters. No literal syntax is available for numbers outside the range of 32-bit integers.</p> <pre><code>module NumericLiteralZ =\n    let FromZero() = \"\"\n    let FromOne() = \"Z\"\n    let FromInt32 n = String.replicate n \"Z\"\n</code></pre> <p>F# compilers may optimize on the assumption that calls to numeric literal functions always terminate, are idempotent, and do not have observable side effects.</p>"},{"location":"expressions/#632-tuple-expressions","title":"6.3.2 Tuple Expressions","text":"<p>An expression of the form <code>expr1 , ..., exprn</code> is a tuple expression. For example:</p> <pre><code>let three = (1,2,\"3\")\nlet blastoff = (10,9,8,7,6,5,4,3,2,1,0)\n</code></pre> <p>The expression has the type <code>S&lt;ty1 * ... * tyn&gt;</code> for fresh types <code>ty1 ... tyn</code> and fresh pseudo-type <code>S</code> that indicates the \"structness\" (i.e. reference tuple or struct tuple) of the tuple. Each individual expression <code>expri</code> is checked using initial type <code>tyi</code>. The pseudo-type <code>S</code> participates in type checking similar to normal types until it is resolved to either reference or struct tuple, with a default of reference tuple.</p> <p>An expression of the form <code>struct (expr1 , ..., exprn)</code> is a struct tuple expression. For example:</p> <pre><code>let pair = struct (1,2)\n</code></pre> <p>A struct tuple expression is checked in the same way as a tuple expression, but the pseudo-type <code>S</code> is resolved to struct tuple.</p> <p>Tuple types and expressions that have <code>S</code> resolved to reference tuple are translated into applications of a family of .NET types named <code>System.Tuple</code>. Tuple types <code>ty1 * ... * tyn</code> are translated as follows:</p> <ul> <li>For <code>n &lt;= 7</code> the elaborated form is <code>Tuple&lt;ty1 ,... , tyn&gt;</code>.</li> <li>For larger <code>n</code> , tuple types are shorthand for applications of the additional F# library type     System.Tuple&lt;_&gt; as follows:</li> <li>For <code>n = 8</code> the elaborated form is <code>Tuple&lt;ty1, ..., ty7, Tuple&lt;ty8&gt;&gt;</code>.</li> <li>For <code>9 &lt;= n</code> the elaborated form is <code>Tuple&lt;ty1, ..., ty7, tyB&gt;</code> where <code>tyB</code> is the converted form of        the type <code>(ty8 * ... * tyn)</code>.</li> </ul> <p>Tuple expressions <code>(expr1, ..., exprn)</code> are translated as follows:</p> <ul> <li>For <code>n &lt;= 7</code> the elaborated form <code>new Tuple&lt;ty1, ..., tyn&gt;(expr1, ..., exprn)</code>.</li> <li>For <code>n = 8</code> the elaborated form <code>new Tuple&lt;ty1, ..., ty7, Tuple&lt;ty8&gt;&gt;(expr1, ..., expr7, new Tuple&lt;ty8&gt;(expr8)</code>.</li> <li>For <code>9 &lt;= n</code> the elaborated form <code>new Tuple&lt;ty1, ... ty7, ty8n&gt;(expr1, ..., expr7, new ty8n(e8n)</code>     where <code>ty8n</code> is the type <code>(ty8 * ... * tyn)</code> and <code>expr8n</code> is the elaborated form of the expression     <code>expr8, ..., exprn</code>.</li> </ul> <p>When considered as static types, tuple types are distinct from their encoded form. However, the encoded form of tuple values and types is visible in the F# type system through runtime types. For example, <code>typeof&lt;int * int&gt;</code> is equivalent to <code>typeof&lt;System.Tuple&lt;int,int&gt;&gt;</code>, and <code>(1 ,2)</code> has the runtime type <code>System.Tuple&lt;int,int&gt;</code>. Likewise, <code>(1,2,3,4,5,6,7,8,9)</code> has the runtime type <code>Tuple&lt;int,int,int,int,int,int,int,Tuple&lt;int,int&gt;&gt;</code>.</p> <p>Tuple types and expressions that have <code>S</code> resolved to struct tuple are translated in the same way to <code>System.ValueTuple</code> .</p> <p>Note: The above encoding is invertible and the substitution of types for type variables preserves this inversion. This means, among other things, that the F# reflection library can correctly report tuple types based on runtime System.Type and System.ValueTuple values. The inversion is defined by: - For the runtime type <code>Tuple&lt;ty1, ..., tyN&gt;</code> when <code>n &lt;= 7</code>, the corresponding F# tuple     type is <code>ty1 * ... * tyN</code> - For the runtime type <code>Tuple&lt;ty1, ..., Tuple&lt;tyN&gt;&gt;</code> when <code>n = 8</code>, the corresponding F#     tuple type is <code>ty1 * ... * ty8</code> - For the runtime type <code>Tuple&lt;ty1, ..., ty7, ty8n&gt;</code> , if <code>ty8n</code> corresponds to the F# tuple     type <code>ty8 * ... * tyN</code>, then the corresponding runtime type is <code>ty1 * ... * tyN</code>.Runtime types of other forms do not have a corresponding tuple type. In particular, runtime types that are instantiations of the eight-tuple type <code>Tuple&lt;_, _, _, _, _, _, _, _ &gt;</code> must always have <code>Tuple&lt;_&gt;</code> in the final position. Syntactic types that have some other form of type in this position are not permitted, and if such an instantiation occurs in F# code or CLI library metadata that is referenced by F# code, an F# implementation may report an error.</p>"},{"location":"expressions/#633-list-expressions","title":"6.3.3 List Expressions","text":"<p>An expression of the form <code>[expr1 ; ...; exprn]</code> is a list expression. The initial type of the expression is asserted to be <code>FSharp.Collections.List&lt;ty&gt;</code> for a fresh type <code>ty</code>.</p> <p>If <code>ty</code> is a named type, each expression <code>expri</code> is checked using a fresh type <code>ty'</code> as its initial type, with the constraint <code>ty' :&gt; ty</code>. Otherwise, each expression <code>expri</code> is checked using <code>ty</code> as its initial type.</p> <p>List expressions elaborate to uses of <code>FSharp.Collections.List&lt;_&gt;</code> as <code>op_Cons(expr1 ,(op_Cons(_expr2 ... op_Cons(exprn, op_Nil) ...)</code> where <code>op_Cons</code> and <code>op_Nil</code> are the union cases with symbolic names <code>::</code> and <code>[]</code> respectively.</p>"},{"location":"expressions/#634-array-expressions","title":"6.3.4 Array Expressions","text":"<p>An expression of the form <code>[|expr1; ...; exprn|]</code> is an array expression. The initial type of the expression is asserted to be <code>ty[]</code> for a fresh type <code>ty</code>.</p> <p>If this assertion determines that <code>ty</code> is a named type, each expression <code>expri</code> is checked using a fresh type <code>ty'</code> as its initial type, with the constraint <code>ty' :&gt; ty</code>. Otherwise, each expression <code>expri</code> is checked using <code>ty</code> as its initial type.</p> <p>Array expressions are a primitive elaborated form.</p> <p>Note: The F# implementation ensures that large arrays of constants of type <code>bool</code>, <code>char</code>, <code>byte</code>, <code>sbyte</code>, <code>int16</code>, <code>uint16</code>, <code>int32</code>, <code>uint32</code>, <code>int64</code>, and <code>uint64</code> are compiled to an efficient binary representation based on a call to <code>System.Runtime.CompilerServices.RuntimeHelpers.InitializeArray</code>.</p>"},{"location":"expressions/#635-record-expressions","title":"6.3.5 Record Expressions","text":"<p>An expression of the form <code>{field-initializer1; ... ; field-initializern}</code> is a record construction expression. For example:</p> <pre><code>type Data = { Count : int; Name : string }\nlet data1 = { Count = 3; Name = \"Hello\"; }\nlet data2 = { Name = \"Hello\"; Count= 3 }\n</code></pre> <p>In the following example, <code>data4</code> uses a long identifier to indicate the relevant field:</p> <pre><code>module M =\n    type Data = { Age : int; Name : string; Height : float }\n\nlet data3 = { M.Age = 17; M.Name = \"John\"; M.Height = 186.0 }\nlet data4 = { data3 with M.Name = \"Bill\"; M.Height = 176.0 }\n</code></pre> <p>Fields may also be referenced by using the name of the containing type:</p> <pre><code>module M2 =\n    type Data = { Age : int; Name : string; Height : float }\n\nlet data5 = { M2.Data.Age = 17; M2.Data.Name = \"John\"; M2.Data.Height = 186.0 }\nlet data6 = { data5 with M2.Data.Name = \"Bill\"; M2.Data.Height=176.0 }\n\nopen M2\nlet data7 = { Data.Age = 17; Data.Name = \"John\"; Data.Height = 186.0 }\nlet data8 = { data5 with Data.Name = \"Bill\"; Data.Height=176.0 }\n</code></pre> <p>Each <code>field-initializeri</code> has the form <code>field-labeli = expri</code>. Each <code>field-labeli</code> is a <code>long-ident</code>, which must resolve to a field <code>F</code> i in a unique record type <code>R</code> as follows:</p> <ul> <li>If <code>field-labeli</code> is a single identifier <code>fld</code> and the initial type is known to be a record type     <code>R&lt;_, ..., _&gt;</code> that has field <code>Fi</code> with name <code>fld</code>, then the field label resolves to <code>Fi</code>.</li> <li>If <code>field-labeli</code> is not a single identifier or if the initial type is a variable type, then the field label     is resolved by performing Field Label Resolution (see \u00a714.1) on <code>field-labeli</code>. This procedure     results in a set of fields <code>FSeti</code>. Each element of this set has a corresponding record type, thus     resulting in a set of record types <code>RSeti</code>. The intersection of all <code>RSeti</code> must yield a single record     type <code>R</code>, and each field then resolves to the corresponding field in <code>R</code>.     The set of fields must be complete. That is, each field in record type <code>R</code> must have exactly one     field definition. Each referenced field must be accessible (see \u00a710.5), as must the type <code>R</code>.</li> </ul> <p>After all field labels are resolved, the overall record expression is asserted to be of type <code>R&lt;ty1, ..., tyN&gt;</code> for fresh types <code>ty1, ..., tyN</code>. Each <code>expri</code> is then checked in turn. The initial type is determined as follows:</p> <ol> <li>Assume the type of the corresponding field <code>Fi</code> in <code>R&lt;ty1, ..., tyN&gt;</code> is <code>ftyi</code></li> <li>If the type of <code>Fi</code> prior to taking into account the instantiation <code>&lt;ty1, ..., tyN&gt;</code> is a named type, then     the initial type is a fresh type inference variable <code>fty'i</code> with a constraint <code>fty'i :&gt; ftyi</code>.</li> <li>Otherwise the initial type is <code>ftyi</code>.</li> </ol> <p>Primitive record constructions are an elaborated form in which the fields appear in the same order as in the record type definition. Record expressions themselves elaborate to a form that may introduce local value definitions to ensure that expressions are evaluated in the same order that the field definitions appear in the original expression. For example:</p> <pre><code>type R = {b : int; a : int }\n{ a = 1 + 1; b = 2 }\n</code></pre> <p>The expression on the last line elaborates to <code>let v = 1 + 1 in { b = 2; a = v }</code>.</p> <p>Records expressions are also used for object initializations in additional object constructor definitions (\u00a78.6.3). For example:</p> <pre><code>type C =\n    val x : int\n    val y : int\n    new() = { x = 1; y = 2 }\n</code></pre> <p>Note: The following record initialization form is deprecated: <code>{ new type with Field1 = expr1 and ... and Fieldn = exprn }</code> The F# implementation allows the use of this form only with uppercase identifiers. F# code should not use this expression form. A future version of the F# language will issue a deprecation warning.</p>"},{"location":"expressions/#636-copy-and-update-record-expressions","title":"6.3.6 Copy-and-update Record Expressions","text":"<p>A copy-and-update record expression has the following form:</p> <pre><code>{ expr with field-initializers }\n</code></pre> <p>where <code>field-initializers</code> is of the following form:</p> <pre><code>field-label1 = expr1; ...; field-labeln = exprn\n</code></pre> <p>Each <code>field-labeli</code> is a <code>long-ident</code>. In the following example, <code>data2</code> is defined by using such an expression:</p> <pre><code>type Data = { Age : int; Name : string; Height : float }\nlet data1 = { Age = 17; Name = \"John\"; Height = 186.0 }\nlet data2 = { data1 with Name = \"Bill\"; Height = 176.0 }\n</code></pre> <p>The expression <code>expr</code> is first checked with the same initial type as the overall expression. Next, the field definitions are resolved by using the same technique as for record expressions. Each field label must resolve to a field <code>Fi</code> in a single record type <code>R</code> , all of whose fields are accessible. After all field labels are resolved, the overall record expression is asserted to be of type <code>R&lt;ty1, ..., tyN&gt;</code> for fresh types <code>ty1, ..., tyN</code>. Each <code>expri</code> is then checked in turn with initial type that results from the following procedure:</p> <ol> <li>Assume the type of the corresponding field <code>Fi</code> in <code>R&lt;ty1, ..., tyN&gt;</code> is <code>ftyi</code>.</li> <li>If the type of <code>Fi</code> before considering the instantiation <code>&lt;ty1, ..., tyN&gt;</code> is a named type, then the     initial type is a fresh type inference variable <code>fty'i</code> with a constraint <code>fty'i :&gt; ftyi</code>.</li> <li>Otherwise, the initial type is <code>ftyi</code>.</li> </ol> <p>A copy-and-update record expression elaborates as if it were a record expression written as follows:</p> <p><code>let v = expr in { field-label1 = expr1; ...; field-labeln = exprn; F1 = v.F1; ...; FM = v.FM }</code> where <code>F1 ... FM</code> are the fields of <code>R</code> that are not defined in <code>field-initializers</code> and <code>v</code> is a fresh variable.</p>"},{"location":"expressions/#637-function-expressions","title":"6.3.7 Function Expressions","text":"<p>An expression of the form <code>fun pat1 ... patn -&gt; expr</code> is a function expression. For example:</p> <pre><code>(fun x -&gt; x + 1)\n(fun x y -&gt; x + y)\n(fun [x] -&gt; x) // note, incomplete match\n(fun (x,y) (z,w) -&gt; x + y + z + w)\n</code></pre> <p>Function expressions that involve only variable patterns are a primitive elaborated form. Function expressions that involve non-variable patterns elaborate as if they had been written as follows:</p> <pre><code>fun v1 ... vn -&gt;\n    let pat1 = v 1\n    ...\n    let patn = vn\n    expr\n</code></pre> <p>No pattern matching is performed until all arguments have been received. For example, the following does not raise a <code>MatchFailureException</code> exception:</p> <pre><code>let f = fun [x] y -&gt; y\nlet g = f [] // ok\n</code></pre> <p>However, if a third line is added, a <code>MatchFailureException</code> exception is raised:</p> <pre><code>let z = g 3 // MatchFailureException is raised\n</code></pre>"},{"location":"expressions/#638-object-expressions","title":"6.3.8 Object Expressions","text":"<p>An expression of the following form is an object expression :</p> <pre><code>{ new ty0 args-expr? object-members\n  interface ty1 object-members1\n  ...\n  interface tyn object-membersn }\n</code></pre> <p>In the case of the interface declarations, the <code>object-members</code> are optional and are considered empty if absent. Each set of <code>object-members</code> has the form:</p> <pre><code>with member-defns end?\n</code></pre> <p>Lexical filtering inserts simulated <code>$end</code> tokens when lightweight syntax is used.</p> <p>Each member of an object expression members can use the keyword <code>member</code>, <code>override</code>, or <code>default</code>. The keyword <code>member</code> can be used even when overriding a member or implementing an interface.</p> <p>For example:</p> <pre><code>let obj1 =\n    { new System.Collections.Generic.IComparer&lt;int&gt; with\n        member x.Compare(a,b) = compare (a % 7) (b % 7) }\n\nlet obj2 =\n    { new System.Object() with\n        member x.ToString () = \"Hello\" }\n\nlet obj3 =\n    { new System.Object() with\n        member x.ToString () = \"Hello, base.ToString() = \" + base.ToString() }\n\nlet obj4 =\n    { new System.Object() with\n        member x.Finalize() = printfn \"Finalize\";\n    interface System.IDisposable with\n        member x.Dispose() = printfn \"Dispose\"; }\n</code></pre> <p>An object expression can specify additional interfaces beyond those required to fulfill the abstract slots of the type being implemented. For example, <code>obj4</code> in the preceding examples has static type <code>System.Object</code> but the object additionally implements the interface <code>System.IDisposable</code>. The additional interfaces are not part of the static type of the overall expression, but can be revealed through type tests.</p> <p>Object expressions are statically checked as follows.</p> <ol> <li> <p>First, <code>ty0</code> to <code>tyn</code> are checked to verify that they are named types. The overall type of the expression is <code>ty0</code> and is asserted to be equal to the initial type of the expression. However, if <code>ty0</code> is type equivalent to <code>System.Object</code> and <code>ty1</code> exists, then the overall type is instead <code>ty1</code>.</p> </li> <li> <p>The type <code>ty0</code> must be a class or interface type. The base construction argument <code>args-expr</code> must     appear if and only if <code>ty0</code> is a class type. The type must have one or more accessible constructors;     the call to these constructors is resolved and elaborated using Method Application Resolution     (see \u00a714.4). Except for <code>ty0</code>, each <code>tyi</code> must be an interface type.</p> </li> <li>The F# compiler attempts to associate each member with a unique dispatch slot by using     dispatch slot inference (\u00a714.7). If a unique matching dispatch slot is found, then the argument     types and return type of the member are constrained to be precisely those of the dispatch slot.</li> <li>The arguments, patterns, and expressions that constitute the bodies of all implementing     members are next checked one by one to verify the following:<ul> <li>For each member, the \u201cthis\u201d value for the member is in scope and has type <code>ty0</code>.</li> <li>Each member of an object expression can initially access the protected members of <code>ty0</code>.</li> <li>If the variable <code>base-ident</code> appears, it must be named <code>base</code>, and in each member a base    variable with this name is in scope. Base variables can be used only in the member    implementations of an object expression, and are subject to the same limitations as byref    values described in \u00a714.9.</li> </ul> </li> </ol> <p>The object must satisfy dispatch slot checking (\u00a714.8) which ensures that a one-to-one mapping exists between dispatch slots and their implementations.</p> <p>Object expressions elaborate to a primitive form. At execution, each object expression creates an object whose runtime type is compatible with all of the <code>tyi</code> that have a dispatch map that is the result of dispatch slot checking (\u00a714.8).</p> <p>The following example shows how to both implement an interface and override a method from <code>System.Object</code>. The overall type of the expression is <code>INewIdentity</code>.</p> <pre><code>type public INewIdentity =\n    abstract IsAnonymous : bool\n\nlet anon =\n{ new System.Object() with\n    member i.ToString() = \"anonymous\"\n  interface INewIdentity with\n    member i.IsAnonymous = true }\n</code></pre>"},{"location":"expressions/#639-delayed-expressions","title":"6.3.9 Delayed Expressions","text":"<p>An expression of the form <code>lazy expr</code> is a delayed expression. For example:</p> <pre><code>lazy (printfn \"hello world\")\n</code></pre> <p>is syntactic sugar for</p> <pre><code>new System.Lazy (fun () -&gt; expr )\n</code></pre> <p>The behavior of the <code>System.Lazy</code> library type ensures that expression <code>expr</code> is evaluated on demand in response to a <code>.Value</code> operation on the lazy value.</p>"},{"location":"expressions/#6310-computation-expressions","title":"6.3.10 Computation Expressions","text":"<p>The following expression forms are all computation expressions :</p> <pre><code>expr { for ... }\nexpr { let ... }\nexpr { let! ... }\nexpr { use ... }\nexpr { while ... }\nexpr { yield ... }\nexpr { yield! ... }\nexpr { try ... }\nexpr { return ... }\nexpr { return! ... }\nexpr { match! ... }\n</code></pre> <p>More specifically, computation expressions have the following form:</p> <pre><code>builder-expr { cexpr }\n</code></pre> <p>where <code>cexpr</code> is, syntactically, the grammar of expressions with the additional constructs that are defined in <code>comp-expr</code>. Computation expressions are used for sequences and other non-standard interpretations of the F# expression syntax. For a fresh variable <code>b</code>, the expression</p> <pre><code>builder-expr { cexpr }\n</code></pre> <p>translates to</p> <pre><code>let b = builder-expr in {| cexpr |}C\n</code></pre> <p>The type of <code>b</code> must be a named type after the checking of builder-expr. The subscript indicates that custom operations (<code>C</code>) are acceptable but are not required.</p> <p>If the inferred type of <code>b</code> has one or more of the <code>Run</code>, <code>Delay</code>, or <code>Quote</code> methods when <code>builder-expr</code> is checked, the translation involves those methods. For example, when all three methods exist, the same expression translates to:</p> <pre><code>let b = builder-expr in b.Run (&lt;@ b.Delay(fun () -&gt; {| cexpr |}C) &gt;@)\n</code></pre> <p>If a <code>Run</code> method does not exist on the inferred type of b, the call to <code>Run</code> is omitted. Likewise, if no <code>Delay</code> method exists on the type of <code>b</code>, that call and the inner lambda are omitted, so the expression translates to the following:</p> <pre><code>let b = builder-expr in b.Run (&lt;@ {| cexpr |}C &gt;@)\n</code></pre> <p>Similarly, if a <code>Quote</code> method exists on the inferred type of <code>b</code>, at-signs <code>&lt;@ @&gt;</code> are placed around <code>{| cexpr |}C</code> or <code>b.Delay(fun () -&gt; {| cexpr |}C)</code> if a <code>Delay</code> method also exists.</p> <p>The translation <code>{| cexpr |}C</code> , which rewrites computation expressions to core language expressions, is defined recursively according to the following rules:</p> <p><code>{| cexpr |}C = T (cexpr, [], fun v -&gt; v, true)</code></p> <p>During the translation, we use the helper function {| cexpr |}0 to denote a translation that does not involve custom operations:</p> <p><code>{| cexpr |}0 = T (cexpr, [], fun v -&gt; v, false)</code></p> <pre><code>T (e, V , C , q) where e : the computation expression being translated\n                       V : a set of scoped variables\n                       C : continuation (or context where \u201ce\u201d occurs,\n                           up to a hole to be filled by the result of translating \u201ce\u201d)\n                       q : Boolean that indicates whether a custom operator is allowed\n</code></pre> <p>Then, T is defined for each computation expression e:</p> <p>T (let p = e in ce, V , C , q) = T (ce, V \uf0c5 <code>var</code> (p), \uf06cv. C (let p = e in v), q)</p> <p>T (let! p = e in ce, V , C , q) = T (ce, V \uf0c5 <code>var</code> (p), \uf06cv. C (b.Bind( <code>src</code> (e),fun p -&gt; v), q)</p> <p>T (yield e, V , C , q) = C (b.Yield(e))</p> <p>T (yield! e, V , C , q) = C (b.YieldFrom( <code>src</code> (e)))</p> <p>T (return e, V , C , q) = C (b.Return(e))</p> <p>T (return! e, V , C , q) = C (b.ReturnFrom( <code>src</code> (e)))</p> <p>T (use p = e in ce, V , C , q) = C (b.Using(e, fun p -&gt; {| <code>ce</code> |} 0 ))</p> <p>T (use! p = e in ce, V , C , q) = C (b.Bind( <code>src</code> (e), fun p -&gt; b.Using(p, fun p -&gt; {| <code>ce</code> |} 0 ))</p> <p>T (match e with pi - &gt; cei, V , C , q) = C (match e with pi - &gt; {| <code>ce</code> i |} 0 )</p> <p>T (match! e with pi - &gt; cei, V , C , q) = C (let! p = e in match p with pi - &gt; {| <code>ce</code> i |} 0 )</p> <p>T (while e do ce, V , C , q) = T (ce, V , \uf06cv. C (b.While(fun () -&gt; e, b.Delay(fun () -&gt; v))), q)</p> <p>T (try ce with pi - &gt; cei, V , C , q) = Assert(not q); C (b.TryWith(b.Delay(fun () -&gt; {| <code>ce</code> |} 0 ), fun pi - &gt; {| <code>ce</code> i |} 0 ))</p> <p>T (try ce finally e, V , C , q) = Assert(not q); C (b.TryFinally(b.Delay(fun () -&gt; {| <code>ce</code> |} 0 ), fun () -&gt; e))</p> <p>T (if e then ce, V , C , q) = T (ce, V , \uf06cv. C (if e then v else b.Zero()), q)</p> <p>T (if e then ce1 else ce2 , V , C , q) = Assert(not q); C (if e then {| <code>ce</code> 1 |} 0 ) else {| <code>ce</code> 2 |} 0 )</p> <p>T (for x = e1 to e2 do ce, V , C , q) = T (for x in e1 .. e2 do ce, V , C , q)</p> <p>T (for p1 in e1 do joinOp p2 in e2 onWord (e3 <code>eop</code> e4 ) ce, V , C , q) = Assert(q); T (for <code>pat</code> ( V ) in b.Join( <code>src</code> (e1 ), <code>src</code> (e2 ), \uf06cp1 .e3 , \uf06cp2 .e4 , \uf06cp1. \uf06cp2 .(p1 ,p2 )) do ce, V , C , q)</p> <p>T (for p1 in e1 do groupJoinOp p2 in e2 onWord (e3 <code>eop</code> e4) into p3 ce, V , C , q) = Assert(q); T (for <code>pat</code> ( V ) in b.GroupJoin( <code>src</code> (e1), <code>src</code> (e2), \uf06cp1.e3, \uf06cp2.e4, \uf06cp1. \uf06cp3.(p1,p3)) do ce, V , C , q)</p> <p>T (for x in e do ce, V , C , q) = T (ce, V \uf0c5 {x}, \uf06cv. C (b.For( <code>src</code> (e), fun x -&gt; v)), q)</p> <p>T (do e in ce, V , C , q) = T (ce, V , \uf06cv. C (e; v), q)</p> <p>T (do! e in ce, V , C , q) = T (let! () = e in ce, V , C , q)</p> <p>T (joinOp p2 in e2 on (e3 <code>eop</code> e4) ce, V , C , q) = T (for <code>pat</code> ( V ) in C ({| yield <code>exp</code> ( V ) |}0) do join p2 in e2 onWord (e3 <code>eop</code> e4) ce, V , \uf06cv.v, q)</p> <p>T (groupJoinOp p2 in e2 onWord (e3 eop e4) into p3 ce, V , C , q) = T (for <code>pat</code> ( V ) in C ({| yield <code>exp</code> ( V ) |}0) do groupJoin p2 in e2 on (e3 <code>eop</code> e4) into p3 ce, V , \uf06cv.v, q)</p> <p>T ([]cop arg, V , C , q) = Assert (q); [| cop arg, C (b.Yield <code>exp</code> ( V )) |] V <p>T ([]cop arg; e, V , C , q) = Assert (q); CL (cop arg; e, V , C (b.Return <code>exp</code> ( V )), false) <p>T ([]cop arg; e, V , C , q) = Assert (q); CL (cop arg; e, V , C (b.Yield <code>exp</code> ( V )), false) <p>T (ce1; ce2, V , C , q) = C (b.Combine({| ce1 |}0, b.Delay(fun () -&gt; {| ce2 |}0)))</p> <p>T (do! e;, V , C , q) = T (let! () = <code>src</code> (e) in b.Return(), V , C , q)</p> <p>T (e;, V , C , q) = C (e;b.Zero())</p> <p>The following notes apply to the translations:</p> <ul> <li>The lambda expression (fun f x -&gt; b) is represented by \uf06cx.b.</li> <li>The auxiliary function var (p) denotes a set of variables that are introduced by a pattern p. For     example:     var(x) = {x}, var((x,y)) = {x,y} or var(S (x,y)) = {x,y}     where S is a type constructor.</li> <li>\uf0c5 is an update operator for a set V to denote extended variable spaces. It updates the existing     variables. For example, {x,y} \uf0c5 var((x,z)) becomes {x,y,z} where the second x replaces the     first x.</li> <li>The auxiliary function pat ( V ) denotes a pattern tuple that represents a set of variables in V. For     example, pat({x,y}) becomes (x,y), where x and y represent pattern expressions.</li> <li> <p>The auxiliary function exp ( V ) denotes a tuple expression that represents a set of variables in V.     For example, exp ({x,y}) becomes (x,y), where x and y represent variable expressions.</p> </li> <li> <p>The auxiliary function src (e) denotes b.Source(e) if the innermost ForEach is from the user     code instead of generated by the translation, and a builder b contains a Source method.     Otherwise, src (e) denotes e.</p> </li> <li>Assert() checks whether a custom operator is allowed. If not, an error message is reported.     Custom operators may not be used within try/with, try/finally, if/then/else, use, match, or     sequential execution expressions such as (e1;e2). For example, you cannot use if/then/else in     any computation expressions for which a builder defines any custom operators, even if the     custom operators are not used.</li> <li>The operator eop denotes one of =, ?=, =? or ?=?.</li> <li>joinOp and onWord represent keywords for join-like operations that are declared in     CustomOperationAttribute. For example, [] declares \u201cjoin\u201d and \u201con\u201d. <li>Similarly, groupJoinOp represents a keyword for groupJoin-like operations, declared in     CustomOperationAttribute. For example, [] declares \u201cgroupJoin\u201d and \u201con\u201d. <li>The auxiliary translation CL is defined as follows:</li> <pre><code>CL (e1, V, e2, bind) where e1: the computation expression being translated\nV : a set of scoped variables\ne2 : the expression that will be translated after e1 is done\nbind: indicator if it is for Bind (true) or iterator (false).\n</code></pre> <p>The following shows translations for the uses of CL in the preceding computation expressions:</p> <pre><code>CL (cop arg, V , e\u2019, bind) = [| cop arg, e\u2019 |] V\nCL ([&lt;MaintainsVariableSpaceUsingBind=true&gt;]cop arg into p; e, V , e\u2019, bind) =\nT (let! p = e\u2019 in e, [], \uf06cv.v, true)\nCL (cop arg into p; e, V , e\u2019, bind) = T (for p in e\u2019 do e, [], \uf06cv.v, true)\nCL ([&lt;MaintainsVariableSpace=true&gt;]cop arg; e, V , e\u2019, bind) =\nCL (e, V , [| cop arg, e\u2019 |] V , true)\nCL ([&lt;MaintainsVariableSpaceUsingBind=true&gt;]cop arg; e, V , e\u2019, bind) =\nCL (e, V , [| cop arg, e\u2019 |] V , true)\nCL (cop arg; e, V , e\u2019, bind) = CL (e, [], [| cop arg, e\u2019 |] V , false)\nCL (e, V , e\u2019, true) = T (let! pat ( V ) = e\u2019 in e, V , \uf06cv.v, true)\nCL (e, V , e\u2019, false) = T (for pat ( V ) in e\u2019 do e, V , \uf06cv.v, true)\n</code></pre> <ul> <li>The auxiliary translation [| e1, e2 |]V is defined as follows:</li> </ul> <p>[|[ e1, e2 |] V where e1: the custom operator available in a build e2 : the context argument that will be passed to a custom operator V : a list of bound variables</p> <pre><code>[|[&lt;CustomOperator(\" Cop\")&gt;] cop [&lt;ProjectionParameter&gt;] arg, e |] V =\nb.Cop (e, fun pat ( V) - &gt; arg)\n[|[&lt;CustomOperator(\"Cop\")&gt;] cop arg, e |] V = b.Cop (e, arg)\n</code></pre> <ul> <li>The final two translation rules (for do! e; and do! e;) apply only for the final expression in the     computation expression. The semicolon (;) can be omitted.</li> </ul> <p>The following attributes specify custom operations:</p> <ul> <li><code>CustomOperationAttribute</code> indicates that a member of a builder type implements a custom     operation in a computation expression. The attribute has one parameter: the name of the     custom operation. The operation can have the following properties:</li> <li><code>MaintainsVariableSpace</code> indicates that the custom operation maintains the variable space of        a computation expression.</li> <li><code>MaintainsVariableSpaceUsingBind</code> indicates that the custom operation maintains the        variable space of a computation expression through the use of a bind operation.</li> <li><code>AllowIntoPattern</code> indicates that the custom operation supports the use of \u2018into\u2019 immediately        following the operation in a computation expression to consume the result of the operation.</li> <li><code>IsLikeJoin</code> indicates that the custom operation is similar to a join in a sequence        computation, which supports two inputs and a correlation constraint.</li> <li><code>IsLikeGroupJoin</code> indicates that the custom operation is similar to a group join in a sequence        computation, which support two inputs and a correlation constraint, and generates a group.</li> <li><code>JoinConditionWord</code> indicates the names used for the \u2018on\u2019 part of the custom operator for        join-like operators.</li> <li><code>ProjectionParameterAttribute</code> indicates that, when a custom operation is used in a     computation expression, a parameter is automatically parameterized by the variable space of     the computation expression.</li> </ul> <p>The following examples show how the translation works. Assume the following simple sequence builder:</p> <pre><code>type SimpleSequenceBuilder() =\n    member __.For (source : seq&lt;'a&gt;, body : 'a -&gt; seq&lt;'b&gt;) =\n        seq { for v in source do yield! body v }\n    member __.Yield (item:'a) : seq&lt;'a&gt; = seq { yield item }\n\nlet myseq = SimpleSequenceBuilder()\n</code></pre> <p>Then, the expression</p> <pre><code>myseq {\n    for i in 1 .. 10 do\n    yield i*i\n    }\n</code></pre> <p>translates to</p> <pre><code>let b = myseq\nb.For([1..10], fun i -&gt;\n    b.Yield(i*i))\n</code></pre> <p><code>CustomOperationAttribute</code> allows us to define custom operations. For example, the simple sequence builder can have a custom operator, \u201cwhere\u201d:</p> <pre><code>type SimpleSequenceBuilder() =\n    member __.For (source : seq&lt;'a&gt;, body : 'a -&gt; seq&lt;'b&gt;) =\n        seq { for v in source do yield! body v }\n    member __.Yield (item:'a) : seq&lt;'a&gt; = seq { yield item }\n    [&lt;CustomOperation(\"where\")&gt;]\n    member __.Where (source : seq&lt;'a&gt;, f: 'a -&gt; bool) : seq&lt;'a&gt; = Seq.filter f source\n\nlet myseq = SimpleSequenceBuilder()\n</code></pre> <p>Then, the expression</p> <pre><code>myseq {\n    for i in 1 .. 10 do\n    where (fun x -&gt; x &gt; 5)\n    }\n</code></pre> <p>translates to</p> <pre><code>let b = myseq\n    b.Where(\n        b.For([1..10], fun i -&gt;\n            b.Yield (i)),\n        fun x -&gt; x &gt; 5)\n</code></pre> <p><code>ProjectionParameterAttribute</code> automatically adds a parameter from the variable space of the computation expression. For example, <code>ProjectionParameterAttribute</code> can be attached to the second argument of the <code>where</code> operator:</p> <pre><code>type SimpleSequenceBuilder() =\n    member __.For (source : seq&lt;'a&gt;, body : 'a -&gt; seq&lt;'b&gt;) =\n        seq { for v in source do yield! body v }\n    member __.Yield (item:'a) : seq&lt;'a&gt; = seq { yield item }\n    [&lt;CustomOperation(\"where\")&gt;]\n    member __.Where (source: seq&lt;'a&gt;, [&lt;ProjectionParameter&gt;]f: 'a -&gt; bool) : seq&lt;'a&gt; =\n        Seq.filter f source\n\nlet myseq = SimpleSequenceBuilder()\n</code></pre> <p>Then, the expression</p> <pre><code>myseq {\n    for i in 1 .. 10 do\n    where (i &gt; 5)\n    }\n</code></pre> <p>translates to</p> <pre><code>let b = myseq\nb.Where(\n    b.For([1..10], fun i -&gt;\n        b.Yield (i)),\n    fun i -&gt; i &gt; 5)\n</code></pre> <p><code>ProjectionParameterAttribute</code> is useful when a let binding appears between <code>ForEach</code> and the custom operators. For example, the expression</p> <pre><code>myseq {\n    for i in 1 .. 10 do\n    let j = i * i\n    where (i &gt; 5 &amp;&amp; j &lt; 49)\n    }\n</code></pre> <p>translates to</p> <pre><code>let b = myseq\nb.Where(\n    b.For([1..10], fun i -&gt;\n        let j = i * i\n        b.Yield (i,j)),\n    fun (i,j) -&gt; i &gt; 5 &amp;&amp; j &lt; 49)\n</code></pre> <p>Without <code>ProjectionParameterAttribute</code>, a user would be required to write \u201c<code>fun (i,j) -&gt;</code>\u201d explicitly.</p> <p>Now, assume that we want to write the condition \u201c<code>where (i &gt; 5 &amp;&amp; j &lt; 49)</code>\u201d in the following syntax:</p> <pre><code>where (i &gt; 5)\nwhere (j &lt; 49)\n</code></pre> <p>To support this style, the <code>where</code> custom operator should produce a computation that has the same variable space as the input computation. That is, <code>j</code> should be available in the second <code>where</code>. The following example uses the <code>MaintainsVariableSpace</code> property on the custom operator to specify this behavior:</p> <pre><code>type SimpleSequenceBuilder() =\n    member __.For (source : seq&lt;'a&gt;, body : 'a -&gt; seq&lt;'b&gt;) =\n        seq { for v in source do yield! body v }\n    member __.Yield (item:'a) : seq&lt;'a&gt; = seq { yield item }\n    [&lt;CustomOperation(\"where\", MaintainsVariableSpace=true)&gt;]\n    member __.Where (source: seq&lt;'a&gt;, [&lt;ProjectionParameter&gt;]f: 'a -&gt; bool) : seq&lt;'a&gt; =\n        Seq.filter f source\n\nlet myseq = SimpleSequenceBuilder()\n</code></pre> <p>Then, the expression</p> <pre><code>myseq {\n    for i in 1 .. 10 do\n    let j = i * i\n    where (i &gt; 5)\n    where (j &lt; 49)\n    }\n</code></pre> <p>translates to</p> <pre><code>let b = myseq\nb.Where(\n    b.Where(\n        b.For([1..10], fun i -&gt;\n            let j = i * i\n            b.Yield (i,j)),\n        fun (i,j) -&gt; i &gt; 5),\n    fun (i,j) -&gt; j &lt; 49)\n</code></pre> <p>When we may not want to produce the variable space but rather want to explicitly express the chain of the <code>where</code> operator, we can design this simple sequence builder in a slightly different way. For example, we can express the same expression in the following way:</p> <pre><code>myseq {\n    for i in 1 .. 10 do\n    where (i &gt; 5) into j\n    where (j*j &lt; 49)\n    }\n</code></pre> <p>In this example, instead of having a let-binding (for <code>j</code> in the previous example) and passing variable space (including <code>j</code>) down to the chain, we can introduce a special syntax that captures a value into a pattern variable and passes only this variable down to the chain, which is arguably more readable. For this case, <code>AllowIntoPattern</code> allows the custom operation to have an <code>into</code> syntax:</p> <pre><code>type SimpleSequenceBuilder() =\n    member __.For (source : seq&lt;'a&gt;, body : 'a -&gt; seq&lt;'b&gt;) =\n        seq { for v in source do yield! body v }\n    member __.Yield (item:'a) : seq&lt;'a&gt; = seq { yield item }\n\n    [&lt;CustomOperation(\"where\", AllowIntoPattern=true)&gt;]\n    member __.Where (source: seq&lt;'a&gt;, [&lt;ProjectionParameter&gt;]f: 'a -&gt; bool) : seq&lt;'a&gt; =\n        Seq.filter f source\n\nlet myseq = SimpleSequenceBuilder()\n</code></pre> <p>Then, the expression</p> <pre><code>myseq {\n    for i in 1 .. 10 do\n    where (i &gt; 5) into j\n    where (j*j &lt; 49)\n    }\n</code></pre> <p>translates to</p> <pre><code>let b = myseq\nb.Where(\n    b.For(\n        b.Where(\n            b.For([1..10], fun i -&gt; b.Yield (i))\n            fun i -&gt; i&gt;5),\n        fun j -&gt; b.Yield (j)),\n    fun j -&gt; j*j &lt; 49)\n</code></pre> <p>Note that the <code>into</code> keyword is not customizable, unlike <code>join</code> and <code>on</code>.</p> <p>In addition to <code>MaintainsVariableSpace</code>, <code>MaintainsVariableSpaceUsingBind</code> is provided to pass variable space down to the chain in a different way. For example:</p> <pre><code>type SimpleSequenceBuilder() =\n    member __.For (source : seq&lt;'a&gt;, body : 'a -&gt; seq&lt;'b&gt;) =\n        seq { for v in source do yield! body v }\n    member __.Return (item:'a) : seq&lt;'a&gt; = seq { yield item }\n    member __.Bind (value , cont) = cont value\n    [&lt;CustomOperation(\"where\", MaintainsVariableSpaceUsingBind=true, AllowIntoPattern=true)&gt;]\n    member __.Where (source: seq&lt;'a&gt;, [&lt;ProjectionParameter&gt;]f: 'a -&gt; bool) : seq&lt;'a&gt; =\n        Seq.filter f source\n\nlet myseq = SimpleSequenceBuilder()\n</code></pre> <p>The presence of <code>MaintainsVariableSpaceUsingBindAttribute</code> requires <code>Return</code> and <code>Bind</code> methods during the translation.</p> <p>Then, the expression</p> <pre><code>myseq {\n    for i in 1 .. 10 do\n    where (i &gt; 5 &amp;&amp; i*i &lt; 49) into j\n    return j\n    }\n</code></pre> <p>translates to</p> <pre><code>let b = myseq\nb.Bind(\n    b.Where(B.For([1..10], fun i -&gt; b.Return (i)),\n        fun i -&gt; i &gt; 5 &amp;&amp; i*i &lt; 49),\n    fun j -&gt; b.Return (j))\n</code></pre> <p>where <code>Bind</code> is called to capture the pattern variable <code>j</code>. Note that <code>For</code> and <code>Yield</code> are called to capture the pattern variable when <code>MaintainsVariableSpace</code> is used.</p> <p>Certain properties on the <code>CustomOperationAttribute</code> introduce join-like operators. The following example shows how to use the <code>IsLikeJoin</code> property.</p> <pre><code>type SimpleSequenceBuilder() =\n    member __.For (source : seq&lt;'a&gt;, body : 'a -&gt; seq&lt;'b&gt;) =\n        seq { for v in source do yield! body v }\n    member __.Yield (item:'a) : seq&lt;'a&gt; = seq { yield item }\n    [&lt;CustomOperation(\"merge\", IsLikeJoin=true, JoinConditionWord=\"whenever\")&gt;]\n    member __.Merge (src1:seq&lt;'a&gt;, src2:seq&lt;'a&gt;, ks1, ks2, ret) =\n        seq { for a in src1 do\n            for b in src2 do\n            if ks1 a = ks2 b then yield((ret a ) b)\n        }\n\nlet myseq = SimpleSequenceBuilder()\n</code></pre> <p><code>IsLikeJoin</code> indicates that the custom operation is similar to a join in a sequence computation; that is, it supports two inputs and a correlation constraint.</p> <p>The expression</p> <pre><code>myseq {\n    for i in 1 .. 10 do\n    merge j in [5 .. 15] whenever (i = j)\n    yield j\n    }\n</code></pre> <p>translates to</p> <pre><code>let b = myseq\nb.For(\n    b.Merge([1..10], [5..15],\n            fun i -&gt; i, fun j -&gt; j,\n            fun i -&gt; fun j -&gt; (i,j)),\n    fun j -&gt; b.Yield (j))\n</code></pre> <p>This translation implicitly places type constraints on the expected form of the builder methods. For example, for the <code>async</code> builder found in the <code>FSharp.Control</code> library, the translation phase corresponds to implementing a builder of a type that has the following member signatures:</p> <pre><code>type AsyncBuilder with\n    member For: seq&lt;'T&gt; * ('T -&gt; Async&lt;unit&gt;) -&gt; Async&lt;unit&gt;\n    member Zero : unit -&gt; Async&lt;unit&gt;\n    member Combine : Async&lt;unit&gt; * Async&lt;'T&gt; -&gt; Async&lt;'T&gt;\n    member While : (unit -&gt; bool) * Async&lt;unit&gt; -&gt; Async&lt;unit&gt;\n    member Return : 'T -&gt; Async&lt;'T&gt;\n    member Delay : (unit -&gt; Async&lt;'T&gt;) -&gt; Async&lt;'T&gt;\n    member Using: 'T * ('T -&gt; Async&lt;'U&gt;) -&gt; Async&lt;'U&gt;\n        when 'U :&gt; System.IDisposable\n    member Bind: Async&lt;'T&gt; * ('T -&gt; Async&lt;'U&gt;) -&gt; Async&lt;'U&gt;\n    member TryFinally: Async&lt;'T&gt; * (unit -&gt; unit) -&gt; Async&lt;'T&gt;\n    member TryWith: Async&lt;'T&gt; * (exn -&gt; Async&lt;'T&gt;) -&gt; Async&lt;'T&gt;\n</code></pre> <p>The following example shows a common approach to implementing a new computation expression builder for a monad. The example uses computation expressions to define computations that can be partially run by executing them step-by-step, for example, up to a time limit.</p> <pre><code>/// Computations that can cooperatively yield by returning a continuation\ntype Eventually&lt;'T&gt; =\n    | Done of 'T\n    | NotYetDone of (unit -&gt; Eventually&lt;'T&gt;)\n\n[&lt;CompilationRepresentation(CompilationRepresentationFlags.ModuleSuffix)&gt;]\nmodule Eventually =\n\n    /// The bind for the computations. Stitch 'k' on to the end of the computation.\n    /// Note combinators like this are usually written in the reverse way,\n    /// for example,\n    /// e |&gt; bind k\n    let rec bind k e =\n        match e with\n        | Done x -&gt; NotYetDone (fun () -&gt; k x)\n        | NotYetDone work -&gt; NotYetDone (fun () -&gt; bind k (work()))\n\n    /// The return for the computations.\n    let result x = Done x\n\n    type OkOrException&lt;'T&gt; =\n        | Ok of 'T\n        | Exception of System.Exception\n\n    /// The catch for the computations. Stitch try/with throughout\n    /// the computation and return the overall result as an OkOrException.\n    let rec catch e =\n        match e with\n        | Done x -&gt; result (Ok x)\n        | NotYetDone work -&gt;\n            NotYetDone (fun () -&gt;\n                let res = try Ok(work()) with | e -&gt; Exception e\n                match res with\n                | Ok cont -&gt; catch cont // note, a tailcall\n                | Exception e -&gt; result (Exception e))\n\n    /// The delay operator.\n    let delay f = NotYetDone (fun () -&gt; f())\n\n    /// The stepping action for the computations.\n    let step c =\n        match c with\n        | Done _ -&gt; c\n        | NotYetDone f -&gt; f ()\n\n    // The rest of the operations are boilerplate.\n\n    /// The tryFinally operator.\n    /// This is boilerplate in terms of \"result\", \"catch\" and \"bind\".\n    let tryFinally e compensation =\n        catch (e)\n        |&gt; bind (fun res -&gt;\n            compensation();\n            match res with\n            | Ok v -&gt; result v\n            | Exception e -&gt; raise e)\n\n    /// The tryWith operator.\n    /// This is boilerplate in terms of \"result\", \"catch\" and \"bind\".\n    let tryWith e handler =\n        catch e\n        |&gt; bind (function Ok v -&gt; result v | Exception e -&gt; handler e)\n\n    /// The whileLoop operator.\n    /// This is boilerplate in terms of \"result\" and \"bind\".\n    let rec whileLoop gd body =\n        if gd() then body |&gt; bind (fun v -&gt; whileLoop gd body)\n        else result ()\n\n    /// The sequential composition operator\n    /// This is boilerplate in terms of \"result\" and \"bind\".\n    let combine e1 e2 =\n        e1 |&gt; bind (fun () -&gt; e2)\n\n    /// The using operator.\n    let using (resource: #System.IDisposable) f =\n        tryFinally (f resource) (fun () -&gt; resource.Dispose())\n\n    /// The forLoop operator.\n    /// This is boilerplate in terms of \"catch\", \"result\" and \"bind\".\n    let forLoop (e:seq&lt;_&gt;) f =\n        let ie = e.GetEnumerator()\n        tryFinally (whileLoop (fun () -&gt; ie.MoveNext())\n                              (delay (fun () -&gt; let v = ie.Current in f v)))\n                   (fun () -&gt; ie.Dispose())\n\n// Give the mapping for F# computation expressions.\ntype EventuallyBuilder() =\n    member x.Bind(e,k) = Eventually.bind k e\n    member x.Return(v) = Eventually.result v\n    member x.ReturnFrom(v) = v\n    member x.Combine(e1,e2) = Eventually.combine e1 e2\n    member x.Delay(f) = Eventually.delay f\n    member x.Zero() = Eventually.result ()\n    member x.TryWith(e,handler) = Eventually.tryWith e handler\n    member x.TryFinally(e,compensation) = Eventually.tryFinally e compensation\n    member x.For(e:seq&lt;_&gt;,f) = Eventually.forLoop e f\n    member x.Using(resource,e) = Eventually.using resource e\n\nlet eventually = new EventuallyBuilder()\n</code></pre> <p>After the computations are defined, they can be built by using eventually { ... }:</p> <pre><code>let comp =\n    eventually {\n        for x in 1 .. 2 do\n            printfn \" x = %d\" x\n        return 3 + 4 }\n</code></pre> <p>These computations can now be stepped. For example:</p> <pre><code>let step x = Eventually.step x\n    comp |&gt; step\n// returns \"NotYetDone &lt;closure&gt;\"\n\ncomp |&gt; step |&gt; step\n// prints \"x = 1\"\n// returns \"NotYetDone &lt;closure&gt;\"\n\ncomp |&gt; step |&gt; step |&gt; step |&gt; step |&gt; step |&gt; step\n// prints \"x = 1\"\n// prints \"x = 2\"\n// returns \u201cNotYetDone &lt;closure&gt;\u201d\n\ncomp |&gt; step |&gt; step |&gt; step |&gt; step |&gt; step |&gt; step |&gt; step |&gt; step\n// prints \"x = 1\"\n// prints \"x = 2\"\n// returns \"Done 7\"\n</code></pre>"},{"location":"expressions/#6311-sequence-expressions","title":"6.3.11 Sequence Expressions","text":"<p>An expression in one of the following forms is a sequence expression :</p> <pre><code>seq { comp-expr }\nseq { short-comp-expr }\n</code></pre> <p>For example:</p> <pre><code>seq { for x in [ 1; 2; 3 ] do for y in [5; 6] do yield x + y }\nseq { for x in [ 1; 2; 3 ] do yield x + x }\nseq { for x in [ 1; 2; 3 ] -&gt; x + x }\n</code></pre> <p>Logically speaking, sequence expressions can be thought of as computation expressions with a builder of type <code>FSharp.Collections.SeqBuilder</code>. This type can be considered to be defined as follows:</p> <pre><code>type SeqBuilder() =\n    member x.Yield (v) = Seq.singleton v\n    member x.YieldFrom (s:seq&lt;_&gt;) = s\n    member x.Return (():unit) = Seq.empty\n    member x.Combine (xs1,xs2) = Seq.append xs1 xs2\n    member x.For (xs,g) = Seq.collect f xs\n    member x.While (guard,body) = SequenceExpressionHelpers.EnumerateWhile guard body\n    member x.TryFinally (xs,compensation) =\n        SequenceExpressionHelpers.EnumerateThenFinally xs compensation\n    member x.Using (resource,xs) = SequenceExpressionHelpers.EnumerateUsing resource xs\n</code></pre> <p>Note that this builder type is not actually defined in the F# library. Instead, sequence expressions are elaborated directly. For details, see page 79 of the old pdf spec.</p>"},{"location":"expressions/#6312-range-expressions","title":"6.3.12 Range Expressions","text":"<p>Expressions of the following forms are range expressions.</p> <pre><code>{ e1 .. e2 }\n{ e1 .. e2 .. e3 }\nseq { e1 .. e2 }\nseq { e1 .. e2 .. e3 }\n</code></pre> <p>Range expressions generate sequences over a specified range. For example:</p> <pre><code>seq { 1 .. 10 } // 1; 2; 3; 4; 5; 6; 7; 8; 9; 10\nseq { 1 .. 2 .. 10 } // 1; 3; 5; 7; 9\n</code></pre> <p>Range expressions involving <code>expr1 .. expr2</code> are translated to uses of the <code>(..)</code> operator, and those involving <code>expr1 .. expr1 .. expr3</code> are translated to uses of the <code>(.. ..)</code> operator:</p> <pre><code>seq { e1 .. e2 } \u2192 ( .. ) e1 e2\nseq { e1 .. e2 .. e3 } \u2192 ( .. .. ) e1 e2 e3\n</code></pre> <p>The default definition of these operators is in <code>FSharp.Core.Operators</code>. The ( <code>..</code> ) operator generates an <code>IEnumerable&lt;_&gt;</code> for the range of values between the start (<code>expr1</code>) and finish (<code>expr2</code>) values, using an increment of 1 (as defined by <code>FSharp.Core.LanguagePrimitives.GenericOne</code>). The <code>(.. ..)</code> operator generates an <code>IEnumerable&lt;_&gt;</code> for the range of values between the start (<code>expr1</code>) and finish (<code>expr3</code>) values, using an increment of <code>expr2</code>.</p> <p>The <code>seq</code> keyword, which denotes the type of computation expression, can be omitted for simple range expressions, but this is not recommended and might be deprecated in a future release. It is always preferable to explicitly mark the type of a computation expression.</p> <p>Range expressions also occur as part of the translated form of expressions, including the following:</p> <ul> <li><code>[ expr1 .. expr2 ]</code></li> <li><code>[| expr1 .. expr2 |]</code></li> <li><code>for var in expr1 .. expr2 do expr3</code></li> </ul> <p>A sequence iteration expression of the form <code>for var in expr1 .. expr2 do expr3 done</code> is sometimes elaborated as a simple for loop-expression (\u00a76.5.7).</p>"},{"location":"expressions/#6313-lists-via-sequence-expressions","title":"6.3.13 Lists via Sequence Expressions","text":"<p>A list sequence expression is an expression in one of the following forms</p> <pre><code>[ comp-expr ]\n[ short-comp-expr ]\n[ range-expr ]\n</code></pre> <p>In all cases <code>[ cexpr ]</code> elaborates to <code>FSharp.Collections.Seq.toList(seq { cexpr })</code>.</p> <p>For example:</p> <pre><code>let x2 = [ yield 1; yield 2 ]\n</code></pre> <pre><code>let x3 = [ yield 1\n           if System.DateTime.Now.DayOfWeek = System.DayOfWeek.Monday then\n               yield 2]\n</code></pre>"},{"location":"expressions/#6314-arrays-sequence-expressions","title":"6.3.14 Arrays Sequence Expressions","text":"<p>An expression in one of the following forms is an array sequence expression :</p> <pre><code>[| comp-expr |]\n[| short-comp-expr |]\n[| range-expr |]\n</code></pre> <p>In all cases <code>[| cexpr |]</code> elaborates to <code>FSharp.Collections.Seq.toArray(seq { cexpr })</code>.</p> <p>For example:</p> <pre><code>let x2 = [| yield 1; yield 2 |]\nlet x3 = [| yield 1\n    if System.DateTime.Now.DayOfWeek = System.DayOfWeek.Monday then\n        yield 2 |]\n</code></pre>"},{"location":"expressions/#6315-null-expressions","title":"6.3.15 Null Expressions","text":"<p>An expression in the form <code>null</code> is a null expression. A null expression imposes a nullness constraint (\u00a75.2.2, \u00a75.4.8) on the initial type of the expression. The constraint ensures that the type directly supports the value <code>null</code>.</p> <p>Null expressions are a primitive elaborated form.</p>"},{"location":"expressions/#6316-printf-formats","title":"6.3.16 'printf' Formats","text":"<p>Format strings are strings with <code>%</code> markers as format placeholders. Format strings are analyzed at compile time and annotated with static and runtime type information as a result of that analysis. They are typically used with one of the functions <code>printf</code>, <code>fprintf</code>, <code>sprintf</code>, or <code>bprintf</code> in the <code>FSharp.Core.Printf</code> module. Format strings receive special treatment in order to type check uses of these functions more precisely.</p> <p>More concretely, a constant string is interpreted as a printf-style format string if it is expected to have the type <code>FSharp.Core.PrintfFormat&lt;'Printer,'State,'Residue,'Result,'Tuple&gt;</code>. The string is statically analyzed to resolve the generic parameters of the <code>PrintfFormat type</code>, of which <code>'Printer</code> and <code>'Tuple</code> are the most interesting:</p> <ul> <li><code>'Printer</code> is the function type that is generated by applying a printf-like function to the format     string.</li> <li><code>'Tuple</code> is the type of the tuple of values that are generated by treating the string as a generator     (for example, when the format string is used with a function similar to <code>scanf</code> in other     languages).</li> </ul> <p>A format placeholder has the following shape:</p> <p><code>%[flags][width][.precision][type]</code></p> <p>where:</p> <p><code>flags</code> are 0 , -, +, and the space character. The # flag is invalid and results in a compile-time error.</p> <p><code>width</code> is an integer that specifies the minimum number of characters in the result.</p> <p><code>precision</code> is the number of digits to the right of the decimal point for a floating-point type..</p> <p><code>type</code> is as shown in the following table.</p> Placeholder string Type <code>%b</code> <code>bool</code> <code>%s</code> <code>string</code> <code>%c</code> <code>char</code> <code>%d, %i</code> One of the basic integer types.A basic integer type is <code>byte</code>, <code>sbyte</code>, <code>int16</code>, <code>uint16</code>, <code>int32</code>, <code>uint32</code>, <code>int64</code>, <code>uint64</code>, <code>nativeint</code>, <code>unativeint</code>, or one of these types with a unit of measure <code>%u</code> Basic integer type formatted as an unsigned integer <code>%x</code> Basic integer type formatted as an unsigned hexadecimal integer with lowercase letters a through f. <code>%X</code> Basic integer type formatted as an unsigned hexadecimal integer with uppercase letters A through F. <code>%o</code> Basic integer type formatted as an unsigned octal integer. <code>%e, %E, %f, %F, %g, %G</code> <code>float</code> or <code>float32</code>, possibly with a unit of measure <code>%M</code> <code>System.Decimal</code>, possibly with a unit of measure <code>%O</code> <code>System.Object</code>, possibly with a unit of measure <code>%A</code> Fresh variable type <code>'T</code> <code>%a</code> Formatter of type <code>'State -&gt; 'T -&gt; 'Residue</code> for a fresh variable type <code>'T</code> <code>%t</code> Formatter of type <code>'State -&gt; 'Residue</code> <p>For example, the format string \"<code>%s %d %s</code>\" is given the type <code>PrintfFormat&lt;(string -&gt; int -&gt; string -&gt; 'd), 'b, 'c, 'd, (string * int * string)&gt;</code> for fresh variable types <code>'b</code>, <code>'c</code>, <code>'d</code>. Applying <code>printf</code> to it yields a function of type <code>string -&gt; int -&gt; string -&gt; unit</code>.</p>"},{"location":"expressions/#64-application-expressions","title":"6.4 Application Expressions","text":""},{"location":"expressions/#641-basic-application-expressions","title":"6.4.1 Basic Application Expressions","text":"<p>Application expressions involve variable names, dot-notation lookups, function applications, method applications, type applications, and item lookups, as shown in the following table.</p> Expression Description <code>long-ident-or-op</code> Long-ident lookup expression <code>expr '.' long-ident-or-op</code> Dot lookup expression <code>expr expr</code> Function or member application expression <code>expr(expr)</code> High precedence function or member application expression <code>expr&lt;types&gt;</code> Type application expression <code>expr&lt; &gt;</code> Type application expression with an empty type list <code>type expr</code> Simple object expression <p>The following are examples of application expressions:</p> <pre><code>System.Math.PI\nSystem.Math.PI.ToString()\n(3 + 4).ToString()\nSystem.Environment.GetEnvironmentVariable(\"PATH\").Length\nSystem.Console.WriteLine(\"Hello World\")\n</code></pre> <p>Application expressions may start with object construction expressions that do not include the <code>new</code> keyword:</p> <pre><code>System.Object()\nSystem.Collections.Generic.List&lt;int&gt;(10)\nSystem.Collections.Generic.KeyValuePair(3,\"Three\")\nSystem.Object().GetType()\nSystem.Collections.Generic.Dictionary&lt;int,int&gt;(10).[1]\n</code></pre> <p>If the <code>long-ident-or-op</code> starts with the special pseudo-identifier keyword <code>global</code>, F# resolves the identifier with respect to the global namespace \u2014 that is, ignoring all <code>open</code> directives (see \u00a714.2). For example:</p> <pre><code>global.System.Math.PI\n</code></pre> <p>is resolved to <code>System.Math.PI</code> ignoring all <code>open</code> directives.</p> <p>The checking of application expressions is described in detail as an algorithm in \u00a714.2. To check an application expression, the expression form is repeatedly decomposed into a lead expression <code>expr</code> and a list of projections <code>projs</code> through the use of Unqualified Lookup (\u00a714.2.1). This in turn uses procedures such as Expression-Qualified Lookup and Method Application Resolution.</p> <p>As described in \u00a714.2, checking an application expression results in an elaborated expression that contains a series of lookups and method calls. The elaborated expression may include:</p> <ul> <li>Uses of named values</li> <li>Uses of union cases</li> <li>Record constructions</li> <li>Applications of functions</li> <li>Applications of methods (including methods that access properties)</li> <li>Applications of object constructors</li> <li>Uses of fields, both static and instance</li> <li>Uses of active pattern result elements</li> </ul> <p>Additional constructs may be inserted when resolving method calls into simpler primitives:</p> <ul> <li> <p>The use of a method or value as a first-class function may result in a function expression.</p> <p>For example, <code>System.Environment.GetEnvironmentVariable</code> elaborates to: <code>(fun v -&gt; System.Environment.GetEnvironmentVariable(v))</code> for some fresh variable <code>v</code>.</p> </li> <li> <p>The use of post-hoc property setters results in the insertion of additional assignment and     sequential execution expressions in the elaborated expression.</p> <p>For example, <code>new System.Windows.Forms.Form(Text=\"Text\")</code> elaborates to <code>let v = new System.Windows.Forms.Form() in v.set_Text(\"Text\"); v</code> for some fresh variable <code>v</code>.</p> </li> <li> <p>The use of optional arguments results in the insertion of <code>Some(_)</code> and <code>None</code> data constructions in     the elaborated expression.</p> </li> </ul> <p>For uses of active pattern results (see \u00a710.2.4), for result <code>i</code> in an active pattern that has <code>N</code> possible results of types <code>types</code> , the elaborated expression form is a union case <code>ChoiceNOfi</code> of type <code>FSharp.Core.Choice&lt;types&gt;</code>.</p>"},{"location":"expressions/#642-object-construction-expressions","title":"6.4.2 Object Construction Expressions","text":"<p>An expression of the following form is an object construction expression:</p> <pre><code>new ty ( e1 ... en )\n</code></pre> <p>An object construction expression constructs a new instance of a type, usually by calling a constructor method on the type. For example:</p> <pre><code>new System.Object()\nnew System.Collections.Generic.List&lt;int&gt;()\nnew System.Windows.Forms.Form (Text=\"Hello World\")\nnew 'T()\n</code></pre> <p>The initial type of the expression is first asserted to be equal to <code>ty</code>. The type <code>ty</code> must not be an array, record, union or tuple type. If <code>ty</code> is a named class or struct type:</p> <ul> <li><code>ty</code> must not be abstract.</li> <li>If <code>ty</code> is a struct type, <code>n</code> is 0 , and <code>ty</code> does not have a constructor method that takes zero     arguments, the expression elaborates to the default \u201czero-bit pattern\u201d value for <code>ty</code>.</li> <li>Otherwise, the type must have one or more accessible constructors. The overloading between     these potential constructors is resolved and elaborated by using Method Application Resolution     (see \u00a714.4).</li> </ul> <p>If <code>ty</code> is a delegate type the expression is a delegate implementation expression.</p> <ul> <li> <p>If the delegate type has an <code>Invoke</code> method that has the following signature</p> <p><code>Invoke(ty1, ..., tyn) -&gt; rtyA</code> ,</p> <p>then the overall expression must be in this form:</p> <p><code>new ty(expr)</code> where <code>expr</code> has type <code>ty1 -&gt; ... -&gt; tyn -&gt; rtyB</code></p> <p>If type <code>rtyA</code> is a CLI void type, then <code>rtyB</code> is unit, otherwise it is <code>rtyA</code>.</p> </li> <li> <p>If any of the types <code>tyi</code> is a byref-type then an explicit function expression must be specified. That     is, the overall expression must be of the form <code>new ty(fun pat1 ... patn -&gt; exprbody)</code>.</p> </li> </ul> <p>If <code>ty</code> is a type variable:</p> <ul> <li>There must be no arguments (that is, <code>n = 0</code>).</li> <li> <p>The type variable is constrained as follows:</p> <p><code>ty : (new : unit -&gt; ty )</code> -- CLI default constructor constraint</p> </li> <li> <p>The expression elaborates to a call to     <code>FSharp.Core.LanguagePrimitives.IntrinsicFunctions.CreateInstance&lt;ty&gt;()</code>, which in turn calls     <code>System.Activator.CreateInstance&lt;ty&gt;()</code>, which in turn uses CLI reflection to find and call the     null object constructor method for type <code>ty</code>. On return from this function, any exceptions are     wrapped by using <code>System.TargetInvocationException</code>.</p> </li> </ul>"},{"location":"expressions/#643-operator-expressions","title":"6.4.3 Operator Expressions","text":"<p>Operator expressions are specified in terms of their shallow syntactic translation to other constructs. The following translations are applied in order:</p> <pre><code>infix-or-prefix-op e1 \u2192 (~infix-or-prefix-op) e1\nprefix-op e1 \u2192 (prefix-op) e1\ne1 infix-op e2 \u2192 (infix-op) e1 e2\n</code></pre> <p>Note: When an operator that may be used as either an infix or prefix operator is used in prefix position, a tilde character ~ is added to the name of the operator during the translation process.</p> <p>These rules are applied after applying the rules for dynamic operators (\u00a76.4.4).</p> <p>The parenthesized operator name is then treated as an identifier and the standard rules for unqualified name resolution (\u00a714.1) in expressions are applied. The expression may resolve to a specific definition of a user-defined or library-defined operator. For example:</p> <pre><code>let (+++) a b = (a,b)\n3 +++ 4\n</code></pre> <p>In some cases, the operator name resolves to a standard definition of an operator from the F# library. For example, in the absence of an explicit definition of (+),</p> <pre><code>3 + 4\n</code></pre> <p>resolves to a use of the infix operator FSharp.Core.Operators.(+).</p> <p>Some operators that are defined in the F# library receive special treatment in this specification. In particular:</p> <ul> <li>The <code>&amp;expr</code> and <code>&amp;&amp;expr</code> address-of operators (\u00a76.4.5)</li> <li>The <code>expr &amp;&amp; expr</code> and <code>expr || expr</code> shortcut control flow operators (\u00a76.5.4)</li> <li>The <code>%expr</code> and <code>%%expr</code> expression splice operators in quotations (\u00a76.8.3)</li> <li>The library-defined operators, such as <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code>, <code>**</code>, <code>&lt;&lt;&lt;</code>, <code>&gt;&gt;&gt;</code>, <code>&amp;&amp;&amp;</code>, <code>|||</code>, and <code>^^^</code> (\u00a718.2).</li> </ul> <p>If the operator does not resolve to a user-defined or library-defined operator, the name resolution rules (\u00a714.1) ensure that the operator resolves to an expression that implicitly uses a static member invocation expression (\u00a7 ?) that involves the types of the operands. This means that the effective behavior of an operator that is not defined in the F# library is to require a static member that has the same name as the operator, on the type of one of the operands of the operator. In the following code, the otherwise undefined operator <code>--&gt;</code> resolves to the static member on the <code>Receiver</code> type, based on a type-directed resolution:</p> <pre><code>type Receiver(latestMessage:string) =\n    static member (&lt;--) (receiver:Receiver,message:string) =\n        Receiver(message)\n\n    static member (--&gt;) (message,receiver:Receiver) =\n        Receiver(message)\n\nlet r = Receiver \"no message\"\n\nr &lt;-- \"Message One\"\n\n\"Message Two\" --&gt; r\n</code></pre>"},{"location":"expressions/#644-dynamic-operator-expressions","title":"6.4.4 Dynamic Operator Expressions","text":"<p>Expressions of the following forms are dynamic operator expressions:</p> <pre><code>expr1 ? expr2\nexpr1 ? expr2 &lt;- expr3\n</code></pre> <p>These expressions are defined by their syntactic translation:</p> <p><code>expr ? ident</code> \u2192 <code>(?) expr \"ident\"</code></p> <p><code>expr1 ? (expr2)</code> \u2192 <code>(?) expr1 expr2</code></p> <p><code>expr1 ? ident &lt;- expr2</code> \u2192 <code>(?&lt;-) expr1 \"ident\" expr2</code></p> <p><code>expr1 ? (expr2) &lt;- expr3</code> \u2192 <code>(?&lt;-) expr1 expr2 expr3</code></p> <p>Here <code>\"ident\"</code> is a string literal that contains the text of <code>ident</code>.</p> <p>Note: The F# core library <code>FSharp.Core.dll</code> does not define the <code>(?)</code> and <code>(?&lt;-)</code> operators. However, user code may define these operators. For example, it is common to define the operators to perform a dynamic lookup on the properties of an object by using reflection.</p> <p>This syntactic translation applies regardless of the definition of the <code>(?)</code> and <code>(?&lt;-)</code> operators. However, it does not apply to uses of the parenthesized operator names, as in the following:</p> <pre><code>(?) x y\n</code></pre>"},{"location":"expressions/#645-the-addressof-operators","title":"6.4.5 The AddressOf Operators","text":"<p>Under default definitions, expressions of the following forms are address-of expressions, called byref-address-of expression and nativeptr-address-of expression, respectively:</p> <pre><code>&amp; expr\n&amp;&amp; expr\n</code></pre> <p>Such expressions take the address of a mutable local variable, byref-valued argument, field, array element, or static mutable global variable.</p> <p>For <code>&amp;expr</code> and <code>&amp;&amp;expr</code>, the initial type of the overall expression must be of the form <code>byref&lt;ty&gt;</code> and <code>nativeptr&lt;ty&gt;</code> respectively, and the expression <code>expr</code> is checked with initial type <code>ty</code>.</p> <p>The overall expression is elaborated recursively by taking the address of the elaborated form of <code>expr</code>, written <code>AddressOf(expr, DefinitelyMutates)</code>, defined in \u00a76.9.4.</p> <p>Use of these operators may result in unverifiable or invalid common intermediate language (CIL) code; when possible, a warning or error is generated. In general, their use is recommended only:</p> <ul> <li>To pass addresses where <code>byref</code> or <code>nativeptr</code> parameters are expected.</li> <li>To pass a <code>byref</code> parameter on to a subsequent function.</li> <li>When required to interoperate with native code.</li> </ul> <p>Addresses that are generated by the <code>&amp;&amp;</code> operator must not be passed to functions that are in tail call position. The F# compiler does not check for this.</p> <p>Direct uses of <code>byref</code> types, <code>nativeptr</code> types, or values in the <code>FSharp.NativeInterop</code> module may result in invalid or unverifiable CIL code. In particular, <code>byref</code> and <code>nativeptr</code> types may NOT be used within named types such as tuples or function types.</p> <p>When calling an existing CLI signature that uses a CLI pointer type <code>ty*</code>, use a value of type <code>nativeptr&lt;ty&gt;</code>.</p> <p>Note: The rules in this section apply to the following prefix operators, which are defined in the F# core library for use with one argument. <code>FSharp.Core.LanguagePrimitives.IntrinsicOperators.(~&amp;)</code> <code>FSharp.Core.LanguagePrimitives.IntrinsicOperators.(~&amp;&amp;)</code> Other uses of these operators are not permitted.</p>"},{"location":"expressions/#646-lookup-expressions","title":"6.4.6 Lookup Expressions","text":"<p>Lookup expressions are specified by syntactic translation:</p> <p><code>e1.[eargs]</code> \u2192 <code>e1.get_Item(eargs)</code></p> <p><code>e1.[eargs] &lt;- e3</code> \u2192 <code>e .set_Item(eargs, e3)</code></p> <p>In addition, for the purposes of resolving expressions of this form, array types of rank 1, 2, 3, and 4 are assumed to support a type extension that defines an <code>Item</code> property that has the following signatures:</p> <pre><code>type 'T[] with\n    member arr.Item : int -&gt; 'T\n\ntype 'T[,] with\n    member arr.Item : int * int -&gt; 'T\n\ntype 'T[,,] with\n    member arr.Item : int * int * int -&gt; 'T\n\ntype 'T[,,,] with\n    member arr.Item : int * int * int * int -&gt; 'T\n</code></pre> <p>In addition, if type checking determines that the type of <code>e1</code> is a named type that supports the <code>DefaultMember</code> attribute, then the member name identified by the <code>DefaultMember</code> attribute is used instead of Item.</p>"},{"location":"expressions/#647-slice-expressions","title":"6.4.7 Slice Expressions","text":"<p>Slice expressions are defined by syntactic translation:</p> <p><code>e1.[sliceArg1, ,,, sliceArgN]</code> \u2192 <code>e1.GetSlice(args1, ..., argsN)</code></p> <p><code>e1.[sliceArg1, ,,, sliceArgN] &lt;- expr</code> \u2192 <code>e1.SetSlice(args1, ...,argsN, expr)</code></p> <p>where each <code>sliceArgN</code> is one of the following and translated to <code>argsN</code> (giving one or two args) as indicated</p> <p><code>*</code> \u2192 <code>None, None</code></p> <p><code>e1..</code> \u2192 <code>Some e1, None</code></p> <p><code>..e2</code> \u2192 <code>None, Some e2</code></p> <p><code>e1..e2</code> \u2192 <code>Some e1, Some e2</code></p> <p><code>idx</code> \u2192 <code>idx</code></p> <p>Because this is a shallow syntactic translation, the <code>GetSlice</code> and <code>SetSlice</code> name may be resolved by any of the relevant Name Resolution (\u00a714.1) techniques, including defining the method as a type extension for an existing type.</p> <p>For example, if a matrix type has the appropriate overloads of the GetSlice method (see below), it is possible to do the following:</p> <pre><code>matrix.[1..,*] // get rows 1.. from a matrix (returning a matrix)\nmatrix.[1..3,*] // get rows 1..3 from a matrix (returning a matrix)\nmatrix.[*,1..3] // get columns 1..3from a matrix (returning a matrix)\nmatrix.[1..3,1,.3] // get a 3x3 sub-matrix (returning a matrix)\nmatrix.[3,*] // get row 3 from a matrix as a vector\nmatrix.[*,3] // get column 3 from a matrix as a vector\n</code></pre> <p>In addition, CIL array types of rank 1 to 4 are assumed to support a type extension that defines a method <code>GetSlice</code> that has the following signature:</p> <pre><code>type 'T[] with\n    member arr.GetSlice : ?start1:int * ?end1:int -&gt; 'T[]\ntype 'T[,] with\n    member arr.GetSlice : ?start1:int * ?end1:int * ?start2:int * ?end2:int -&gt; 'T[,]\n    member arr.GetSlice : idx1:int * ?start2:int * ?end2:int -&gt; 'T[]\n    member arr.GetSlice : ?start1:int * ?end1:int * idx2:int - &gt; 'T[]\ntype 'T[,,] with\n    member arr.GetSlice : ?start1:int * ?end1:int * ?start2:int * ?end2:int *\n                          ?start3:int * ?end3:int\n                            -&gt; 'T[,,]\ntype 'T[,,,] with\n    member arr.GetSlice : ?start1:int * ?end1:int * ?start2:int * ?end2:int *\n                          ?start3:int * ?end3:int * ?start4:int * ?end4:int\n                            -&gt; 'T[,,,]\n</code></pre> <p>In addition, CIL array types of rank 1 to 4 are assumed to support a type extension that defines a method <code>SetSlice</code> that has the following signature:</p> <pre><code>type 'T[] with\n    member arr.SetSlice : ?start1:int * ?end1:int * values:T[] -&gt; unit\n\ntype 'T[,] with\n    member arr.SetSlice : ?start1:int * ?end1:int * ?start2:int * ?end2:int *\n                          values:T[,] -&gt; unit\n    member arr.SetSlice : idx1:int * ?start2:int * ?end2:int * values:T[] -&gt; unit\n    member arr.SetSlice : ?start1:int * ?end1:int * idx2:int * values:T[] -&gt; unit\n\ntype 'T[,,] with\n    member arr.SetSlice : ?start1:int * ?end1:int * ?start2:int * ?end2:int *\n                          ?start3:int * ?end3:int *\n                          values:T[,,] -&gt; unit\n\ntype 'T[,,,] with\n    member arr.SetSlice : ?start1:int * ?end1:int * ?start2:int * ?end2:int *\n                          ?start3:int * ?end3:int * ?start4:int * ?end4:int *\n                          values:T[,,,] -&gt; unit\n</code></pre>"},{"location":"expressions/#648-member-constraint-invocation-expressions","title":"6.4.8 Member Constraint Invocation Expressions","text":"<p>An expression of the following form is a member constraint invocation expression:</p> <pre><code>(static-typars : (member-sig) expr)\n</code></pre> <p>Type checking proceeds as follows:</p> <ol> <li>The expression is checked with initial type <code>ty</code>.</li> <li>A statically resolved member constraint is applied (\u00a75.2.3):     <code>static-typars: (member-sig)</code></li> <li><code>ty</code> is asserted to be equal to the return type of the constraint.</li> <li><code>expr</code> is checked with an initial type that corresponds to the argument types of the constraint.</li> </ol> <p>The elaborated form of the expression is a member invocation. For example:</p> <pre><code>let inline speak (a: ^a) =\n    let x = (^a : (member Speak: unit -&gt; string) (a))\n    printfn \"It said: %s\" x\n    let y = (^a : (member MakeNoise: unit -&gt; string) (a))\n    printfn \"Then it went: %s\" y\n\ntype Duck() =\n    member x.Speak() = \"I'm a duck\"\n    member x.MakeNoise() = \"quack\"\ntype Dog() =\n    member x.Speak() = \"I'm a dog\"\n    member x.MakeNoise() = \"grrrr\"\n\nlet x = new Duck()\nlet y = new Dog()\nspeak x\nspeak y\n</code></pre> <p>Outputs:</p> <pre><code>It said: I'm a duck\nThen it went: quack\nIt said: I'm a dog\nThen it went: grrrr\n</code></pre>"},{"location":"expressions/#649-assignment-expressions","title":"6.4.9 Assignment Expressions","text":"<p>An expression of the following form is an assignment expression :</p> <pre><code>expr1 &lt;- expr2\n</code></pre> <p>A modified version of Unqualified Lookup (\u00a714.2.1) is applied to the expression <code>expr1</code> using a fresh expected result type <code>ty</code> , thus producing an elaborate expression <code>expr1</code>. The last qualification for <code>expr1</code> must resolve to one of the following constructs:</p> <ul> <li> <p>An invocation of a property with a setter method. The property may be an indexer.</p> <p>Type checking incorporates <code>expr2</code> as the last argument in the method application resolution for the setter method. The overall elaborated expression is a method call to this setter property and includes the last argument.</p> </li> <li> <p>A mutable value <code>path</code> of type <code>ty</code>.</p> <p>Type checking of <code>expr2</code> uses the expected result type <code>ty</code> and generates an elaborated expression <code>expr2</code>. The overall elaborated expression is an assignment to a value reference <code>&amp;path &lt;-stobj expr2</code>.</p> </li> <li> <p>A reference to a value <code>path</code> of type <code>byref&lt;ty&gt;</code>.</p> <p>Type checking of <code>expr2</code> uses the expected result type <code>ty</code> and generates an elaborated expression <code>expr2</code>. The overall elaborated expression is an assignment to a value reference <code>path &lt;-stobj expr2</code>.</p> </li> <li> <p>A reference to a mutable field <code>expr1a.field</code> with the actual result type <code>ty</code>.</p> <p>Type checking of <code>expr2</code> uses the expected result type <code>ty</code> and generates an elaborated expression <code>expr2</code>. The overall elaborated expression is an assignment to a field (see \u00a76.9.4):</p> <p><code>AddressOf(expr1a.field, DefinitelyMutates) &lt;-stobj expr2</code></p> </li> <li> <p>A array lookup <code>expr1a.[expr1b]</code> where <code>expr1a</code> has type <code>ty[]</code>.</p> <p>Type checking of expr2 uses the expected result type ty and generates thean elaborated expression expr2. The overall elaborated expression is an assignment to a field (see \u00a76.9.4):</p> <p><code>AddressOf(expr1a.[expr1b], DefinitelyMutates) &lt;-stobj expr2</code></p> <p>Note: Because assignments have the preceding interpretations, local values must be mutable so that primitive field assignments and array lookups can mutate their immediate contents. In this context, \u201cimmediate\u201d contents means the contents of a mutable value type. For example, given</p> <pre><code>[&lt;Struct&gt;]\ntype SA =\n    new(v) = { x = v }\n    val mutable x : int\n\n[&lt;Struct&gt;]\ntype SB =\n    new(v) = { sa = v }\n    val mutable sa : SA\n\nlet s1 = SA(0)\nlet mutable s2 = SA(0)\nlet s3 = SB(0)\nlet mutable s4 = SB(0)\n</code></pre> <p>Then these are not permitted:</p> <pre><code>s1.x &lt;- 3\ns3.sa.x &lt;- 3\n</code></pre> <p>and these are:</p> <pre><code>s2.x &lt;- 3\ns4.sa.x &lt;- 3\ns4.sa &lt;- SA(2)\n</code></pre> </li> </ul>"},{"location":"expressions/#65-control-flow-expressions","title":"6.5 Control Flow Expressions","text":""},{"location":"expressions/#651-parenthesized-and-block-expressions","title":"6.5.1 Parenthesized and Block Expressions","text":"<p>A parenthesized expression has the following form:</p> <pre><code>(expr)\n</code></pre> <p>A block expression has the following form:</p> <pre><code>begin expr end\n</code></pre> <p>The expression <code>expr</code> is checked with the same initial type as the overall expression.</p> <p>The elaborated form of the expression is simply the elaborated form of <code>expr</code>.</p>"},{"location":"expressions/#652-sequential-execution-expressions","title":"6.5.2 Sequential Execution Expressions","text":"<p>A sequential execution expression has the following form:</p> <pre><code>expr1 ; expr2\n</code></pre> <p>For example:</p> <pre><code>printfn \"Hello\"; printfn \"World\"; 3\n</code></pre> <p>The <code>;</code> token is optional when both of the following are true:</p> <ul> <li> <p>The expression <code>expr2</code> occurs on a subsequent line that starts in the same column as <code>expr1</code>.</p> </li> <li> <p>The current pre-parse context that results from the syntax analysis of the program text is a     <code>SeqBlock</code> (\u00a715.).</p> </li> </ul> <p>When the semicolon is optional, parsing inserts a <code>$sep</code> token automatically and applies an additional syntax rule for lightweight syntax (\u00a715.1.1). In practice, this means that code can omit the <code>;</code> token for sequential execution expressions that implement functions or immediately follow tokens such as <code>begin</code> and <code>(</code>.</p> <p>The expression <code>expr1</code> is checked with an arbitrary initial type <code>ty</code>. After checking <code>expr1</code>, <code>ty</code> is asserted to be equal to <code>unit</code>. If the assertion fails, a warning rather than an error is reported. The expression <code>expr2</code> is then checked with the same initial type as the overall expression.</p> <p>Sequential execution expressions are a primitive elaborated form.</p>"},{"location":"expressions/#653-conditional-expressions","title":"6.5.3 Conditional Expressions","text":"<p>A conditional expression has the following forms</p> <pre><code>if expr1a then expr1b\nelif expr3a then expr2b\n...\nelif exprna then exprnb\nelse exprlast\n</code></pre> <p>The <code>elif</code> and <code>else</code> branches may be omitted. For example:</p> <pre><code>if (1 + 1 = 2) then \"ok\" else \"not ok\"\nif (1 + 1 = 2) then printfn \"ok\"\n</code></pre> <p>Conditional expressions are equivalent to pattern matching on Boolean values. For example, the following expression forms are equivalent:</p> <pre><code>if expr1 then expr2 else expr3\nmatch (expr1: bool) with true -&gt; expr2 | false -&gt; expr3\n</code></pre> <p>If the <code>else</code> branch is omitted, the expression is a sequential conditional expression and is equivalent to:</p> <pre><code>match (expr1: bool) with true -&gt; expr2 | false -&gt; ()\n</code></pre> <p>with the exception that the initial type of the overall expression is first asserted to be <code>unit</code>.</p>"},{"location":"expressions/#654-shortcut-operator-expressions","title":"6.5.4 Shortcut Operator Expressions","text":"<p>Under default definitions, expressions of the following form are respectively an shortcut and expression and a shortcut or expression :</p> <pre><code>expr &amp;&amp; expr\nexpr || expr\n</code></pre> <p>These expressions are defined by their syntactic translation:</p> <pre><code>expr1 &amp;&amp; expr2 \u2192 if expr1 then expr2 else false\nexpr1 || expr2 \u2192 if expr1 then true else expr2\n</code></pre> <p>Note: The rules in this section apply when the following operators, as defined in the F#     core library, are applied to two arguments.     <code>FSharp.Core.LanguagePrimitives.IntrinsicOperators.(&amp;&amp;)</code> <code>FSharp.Core.LanguagePrimitives.IntrinsicOperators.(||)</code>      If the operator is not immediately applied to two arguments, it is interpreted as a strict     function that evaluates both its arguments before use.</p>"},{"location":"expressions/#655-pattern-matching-expressions-and-functions","title":"6.5.5 Pattern-Matching Expressions and Functions","text":"<p>A pattern-matching expression has the following form:</p> <pre><code>match expr with rules\n</code></pre> <p>Pattern matching is used to evaluate the given expression and select a rule (\u00a77.). For example:</p> <pre><code>match (3, 2) with\n| 1, j -&gt; printfn \"j = %d\" j\n| i, 2 - &gt; printfn \"i = %d\" i\n| _ - &gt; printfn \"no match\"\n</code></pre> <p>A pattern-matching function is an expression of the following form:</p> <pre><code>function rules\n</code></pre> <p>A pattern-matching function is syntactic sugar for a single-argument function expression that is followed by immediate matches on the argument. For example:</p> <pre><code>function\n| 1, j -&gt; printfn \"j = %d\" j\n| _ - &gt; printfn \"no match\"\n</code></pre> <p>is syntactic sugar for the following, where x is a fresh variable:</p> <pre><code>fun x -&gt;\n    match x with\n    | 1, j -&gt; printfn \"j = %d\" j\n    | _ - &gt; printfn \"no match\"\n</code></pre>"},{"location":"expressions/#656-sequence-iteration-expressions","title":"6.5.6 Sequence Iteration Expressions","text":"<p>An expression of the following form is a sequence iteration expression :</p> <pre><code>for pat in expr1 do expr2 done\n</code></pre> <p>The done token is optional if <code>expr2</code> appears on a later line and is indented from the column position of the for token. In this case, parsing inserts a <code>$done</code> token automatically and applies an additional syntax rule for lightweight syntax (\u00a715.1.1).</p> <p>For example:</p> <pre><code>for x, y in [(1, 2); (3, 4)] do\n    printfn \"x = %d, y = %d\" x y\n</code></pre> <p>The expression <code>expr1</code> is checked with a fresh initial type <code>tyexpr</code>, which is then asserted to be a subtype of type <code>IEnumerable&lt;ty&gt;</code>, for a fresh type <code>ty</code>. If the assertion succeeds, the expression elaborates to the following, where <code>v</code> is of type <code>IEnumerator&lt;ty&gt;</code> and <code>pat</code> is a pattern of type <code>ty</code> :</p> <pre><code>let v = expr1.GetEnumerator()\ntry\n    while (v.MoveNext()) do\n        match v.Current with\n        | pat - &gt; expr2\n        | _ -&gt; ()\nfinally\n    match box(v) with\n    | :? System.IDisposable as d - &gt; d .Dispose()\n    | _ -&gt; ()\n</code></pre> <p>If the assertion fails, the type <code>tyexpr</code> may also be of any static type that satisfies the \u201ccollection pattern\u201d of CLI libraries. If so, the enumerable extraction process is used to enumerate the type. In particular, <code>tyexpr</code> may be any type that has an accessible GetEnumerator method that accepts zero arguments and returns a value that has accessible MoveNext and Current properties. The type of <code>pat</code> is the same as the return type of the Current property on the enumerator value. However, if the Current property has return type obj and the collection type <code>ty</code> has an Item property with a more specific (non-object) return type <code>ty2</code> , type <code>ty2</code> is used instead, and a dynamic cast is inserted to convert v.Current to <code>ty2</code>.</p> <p>A sequence iteration of the form</p> <pre><code>for var in expr1 .. expr2 do expr3 done\n</code></pre> <p>where the type of <code>expr1</code> or <code>expr2</code> is equivalent to <code>int</code>, is elaborated as a simple for-loop expression (\u00a76.5.7)</p>"},{"location":"expressions/#657-simple-for-loop-expressions","title":"6.5.7 Simple for-Loop Expressions","text":"<p>An expression of the following form is a simple for loop expression :</p> <pre><code>for var = expr1 to expr2 do expr3 done\n</code></pre> <p>The <code>done</code> token is optional when <code>e2</code> appears on a later line and is indented from the column position of the <code>for</code> token. In this case, a <code>$done</code> token is automatically inserted, and an additional syntax rule for lightweight syntax applies (\u00a715.1.1). For example:</p> <pre><code>for x = 1 to 30 do\n    printfn \"x = %d, x^2 = %d\" x (x*x)\n</code></pre> <p>The bounds <code>expr1</code> and <code>expr2</code> are checked with initial type <code>int</code>. The overall type of the expression is <code>unit</code>. A warning is reported if the body <code>expr3</code> of the <code>for</code> loop does not have static type <code>unit</code>.</p> <p>The following shows the elaborated form of a simple for-loop expression for fresh variables <code>start</code> and <code>finish</code>:</p> <pre><code>let start = expr1 in\nlet finish = expr2 in\nfor var = start to finish do expr3 done\n</code></pre> <p>For-loops over ranges that are specified by variables are a primitive elaborated form. When executed, the iterated range includes both the starting and ending values in the range, with an increment of 1.</p> <p>An expression of the form</p> <pre><code>for var in expr1 .. expr2 do expr3 done\n</code></pre> <p>is always elaborated as a simple for-loop expression whenever the type of <code>expr1</code> or <code>expr2</code> is equivalent to <code>int</code>.</p>"},{"location":"expressions/#658-while-expressions","title":"6.5.8 While Expressions","text":"<p>A while loop expression has the following form:</p> <pre><code>while expr1 do expr2 done\n</code></pre> <p>The <code>done</code> token is optional when <code>expr2</code> appears on a subsequent line and is indented from the column position of the <code>while</code>. In this case, a <code>$done</code> token is automatically inserted, and an additional syntax rule for lightweight syntax applies (\u00a715.1.1).</p> <p>For example:</p> <pre><code>while System.DateTime.Today.DayOfWeek = System.DayOfWeek.Monday do\n    printfn \"I don't like Mondays\"\n</code></pre> <p>The overall type of the expression is <code>unit</code>. The expression <code>expr1</code> is checked with initial type <code>bool</code>. A warning is reported if the body <code>expr2</code> of the while loop cannot be asserted to have type <code>unit</code>.</p>"},{"location":"expressions/#659-try-with-expressions","title":"6.5.9 Try-with Expressions","text":"<p>A try-with expression has the following form:</p> <pre><code>try expr with rules\n</code></pre> <p>For example:</p> <pre><code>try \"1\" with _ -&gt; \"2\"\n\ntry\n    failwith \"fail\"\nwith\n    | Failure msg -&gt; \"caught\"\n    | :? System.InvalidOperationException -&gt; \"unexpected\"\n</code></pre> <p>Expression <code>expr</code> is checked with the same initial type as the overall expression. The pattern matching clauses are then checked with the same initial type and with input type <code>System.Exception</code>.</p> <p>Try-with expressions are a primitive elaborated form.</p>"},{"location":"expressions/#6510-reraise-expressions","title":"6.5.10 Reraise Expressions","text":"<p>A reraise expression is an application of the <code>reraise</code> F# library function. This function must be applied to an argument and can be used only on the immediate right-hand side of <code>rules</code> in a try-with expression.</p> <pre><code>try\n    failwith \"fail\"\nwith e -&gt; printfn \"Failing\"; reraise()\n</code></pre> <p>Note: The rules in this section apply to any use of the function   <code>FSharp.Core.Operators.reraise</code>, which is defined in the F# core library.</p> <p>When executed, <code>reraise()</code> continues exception processing with the original exception information.</p>"},{"location":"expressions/#6511-try-finally-expressions","title":"6.5.11 Try-finally Expressions","text":"<p>A try-finally expression has the following form:</p> <pre><code>try expr1 finally expr2\n</code></pre> <p>For example:</p> <pre><code>try \"1\" finally printfn \"Finally!\"\n\ntry\n    failwith \"fail\"\nfinally\n    printfn \"Finally block\"\n</code></pre> <p>Expression <code>expr1</code> is checked with the initial type of the overall expression. Expression <code>expr2</code> is checked with arbitrary initial type, and a warning occurs if this type cannot then be asserted to be equal to <code>unit</code>.</p> <p>Try-finally expressions are a primitive elaborated form.</p>"},{"location":"expressions/#6512-assertion-expressions","title":"6.5.12 Assertion Expressions","text":"<p>An assertion expression has the following form:</p> <pre><code>assert expr\n</code></pre> <p>The expression <code>assert expr</code> is syntactic sugar for <code>System.Diagnostics.Debug.Assert(expr)</code></p> <p>Note: <code>System.Diagnostics.Debug.Assert</code> is a conditional method call. This means that assertions are triggered only if the DEBUG conditional compilation symbol is defined.</p>"},{"location":"expressions/#66-definition-expressions","title":"6.6 Definition Expressions","text":"<p>A definition expression has one of the following forms:</p> <pre><code>let function-defn in expr\nlet value-defn in expr\nlet rec function-or-value-defns in expr\nuse ident = expr1 in expr\n</code></pre> <p>Such an expression establishes a local function or value definition within the lexical scope of <code>expr</code> and has the same overall type as <code>expr</code>.</p> <p>In each case, the <code>in</code> token is optional if <code>expr</code> appears on a subsequent line and is aligned with the token <code>let</code>. In this case, a <code>$in</code> token is automatically inserted, and an additional syntax rule for lightweight syntax applies (\u00a715.1.1)</p> <p>For example:</p> <pre><code>let x = 1\nx + x\n</code></pre> <p>and</p> <pre><code>let x, y = (\"One\", 1)\nx.Length + y\n</code></pre> <p>and</p> <pre><code>let id x = x in (id 3, id \"Three\")\n</code></pre> <p>and</p> <pre><code>let swap (x, y) = (y,x)\nList.map swap [ (1, 2); (3, 4) ]\n</code></pre> <p>and</p> <pre><code>let K x y = x in List.map (K 3) [ 1; 2; 3; 4 ]\n</code></pre> <p>Function and value definitions in expressions are similar to function and value definitions in class definitions (\u00a78.6), modules (\u00a710.2.1), and computation expressions (\u00a76.3.10), with the following exceptions:</p> <ul> <li>Function and value definitions in expressions may not define explicit generic parameters (\u00a75.3).     For example, the following expression is rejected:        <code>let f&lt;'T&gt; (x:'T) = x in f 3</code></li> <li>Function and value definitions in expressions are not public and are not subject to arity analysis     (\u00a714.11).</li> <li>Any custom attributes that are specified on the declaration, parameters, and/or return     arguments are ignored and result in a warning. As a result, function and value definitions in     expressions may not have the <code>ThreadStatic</code> or <code>ContextStatic</code> attribute.</li> </ul>"},{"location":"expressions/#661-value-definition-expressions","title":"6.6.1 Value Definition Expressions","text":"<p>A value definition expression has the following form:</p> <pre><code>let value-defn in expr\n</code></pre> <p>where value-defn has the form:</p> <pre><code>mutable? access? pat typar-defns? return-type? = rhs-expr\n</code></pre> <p>Checking proceeds as follows:</p> <ol> <li> <p>Check the value-defn (\u00a714.6), which defines a group of identifiers <code>identj</code> with inferred types <code>tyj</code></p> </li> <li> <p>Add the identifiers <code>identj</code> to the name resolution environment, each with corresponding type     <code>tyj</code>.</p> </li> <li>Check the body <code>expr</code> against the initial type of the overall expression.</li> </ol> <p>In this case, the following rules apply:</p> <ul> <li> <p>If <code>pat</code> is a single value pattern <code>ident</code>, the resulting elaborated form of the entire expression is</p> <pre><code>let ident1 &lt;typars1&gt; = expr1 in\nbody-expr\n</code></pre> <p>where ident1 , typars1 and expr1 are defined in \u00a714.6.</p> </li> <li> <p>Otherwise, the resulting elaborated form of the entire expression is</p> <pre><code>let tmp &lt;typars1 ... typars n&gt; = expr in\nlet ident1 &lt;typars1&gt; = expr1 in\n...\nlet identn &lt;typarsn&gt; = exprn in\nbody-expr\n</code></pre> <p>where <code>tmp</code> is a fresh identifier and <code>identi</code>, <code>typarsi</code>, and <code>expri</code> all result from the compilation of the pattern <code>pat</code> (\u00a77.) against the input <code>tmp</code>.</p> </li> </ul> <p>Value definitions in expressions may be marked as <code>mutable</code>. For example:</p> <pre><code>let mutable v = 0\nwhile v &lt; 10 do\n    v &lt;- v + 1\n    printfn \"v = %d\" v\n</code></pre> <p>Such variables are implicitly dereferenced each time they are used.</p>"},{"location":"expressions/#662-function-definition-expressions","title":"6.6.2 Function Definition Expressions","text":"<p>A function definition expression has the form:</p> <pre><code>let function-defn in expr\n</code></pre> <p>where <code>function-defn</code> has the form:</p> <pre><code>inline? access? ident-or-op typar-defns? pat1 ... patn return-type? = rhs-expr\n</code></pre> <p>Checking proceeds as follows:</p> <ol> <li>Check the <code>function-defn</code> (\u00a714.6), which defines <code>ident1</code>, <code>ty1</code>, <code>typars1</code> and <code>expr1</code></li> <li>Add the identifier <code>ident1</code> to the name resolution environment, each with corresponding type <code>ty1</code>.</li> <li>Check the body <code>expr</code> against the initial type of the overall expression.</li> </ol> <p>The resulting elaborated form of the entire expression is</p> <pre><code>let ident1 &lt; typars1 &gt; = expr1 in\nexpr\n</code></pre> <p>where <code>ident1</code> , <code>typars1</code> and <code>expr1</code> are as defined in \u00a714.6.</p>"},{"location":"expressions/#663-recursive-definition-expressions","title":"6.6.3 Recursive Definition Expressions","text":"<p>An expression of the following form is a recursive definition expression:</p> <pre><code>let rec function-or-value-defns in expr\n</code></pre> <p>The defined functions and values are available for use within their own definitions\u2014that is can be used within any of the expressions on the right-hand side of <code>function-or-value-defns</code>. Multiple functions or values may be defined by using <code>let rec ... and ...</code>. For example:</p> <pre><code>let test() =\n    let rec twoForward count =\n        printfn \"at %d, taking two steps forward\" count\n        if count = 1000 then \"got there!\"\n        else oneBack (count + 2)\n    and oneBack count =\n        printfn \"at %d, taking one step back \" count\n        twoForward (count - 1)\n\n    twoForward 1\n\ntest()\n</code></pre> <p>In the example, the expression defines a set of recursive functions. If one or more recursive values are defined, the recursive expressions are analyzed for safety (\u00a714.6.6). This may result in warnings (including some reported as compile-time errors) and runtime checks.</p>"},{"location":"expressions/#664-deterministic-disposal-expressions","title":"6.6.4 Deterministic Disposal Expressions","text":"<p>A deterministic disposal expression has the form:</p> <pre><code>use ident = expr1 in expr2\n</code></pre> <p>For example:</p> <pre><code>use inStream = System.IO.File.OpenText \"input.txt\"\nlet line1 = inStream.ReadLine()\nlet line2 = inStream.ReadLine()\n(line1,line2)\n</code></pre> <p>The expression is first checked as an expression of form <code>let ident = expr1 in expr2</code> (\u00a76.6.1), which results in an elaborated expression of the following form:</p> <pre><code>let ident1 : ty1 = expr1 in expr2.\n</code></pre> <p>Only one value may be defined by a deterministic disposal expression, and the definition is not generalized (\u00a714.6.7). The type <code>ty1</code> , is then asserted to be a subtype of <code>System.IDisposable</code>. If the dynamic value of the expression after coercion to type <code>obj</code> is non-null, the <code>Dispose</code> method is called on the value when the value goes out of scope. Thus the overall expression elaborates to this:</p> <pre><code>let ident1 : ty1 = expr1\ntry expr2\nfinally (match ( ident :&gt; obj) with\n         | null -&gt; ()\n         | _ -&gt; (ident :&gt; System.IDisposable).Dispose())\n</code></pre>"},{"location":"expressions/#665-pinned-pointer-expressions","title":"6.6.5 Pinned Pointer Expressions","text":"<p>A pinned pointer expression allows a pointer to be extracted from an expression and bound to a name, preventing the value from being collected or moved by the garbage collector for the scope of the binding. This feature is intended for low-level programming scenarios.</p> <p>A pinned pointer expression has the following form:</p> <pre><code>use ident = fixed expr\n</code></pre> <p>For example, pinning a field within an object:</p> <pre><code>type Point = { mutable x : int; mutable y : int }\n\nlet pinObject() =\n    let point = { x = 1; y = 2 }\n    use p1 = fixed &amp;point.x\n    // code that uses p1 as a nativeptr&lt;int&gt;\n</code></pre> <p>Pinning an array:</p> <pre><code>let pinArray() =\n    let arr = [| 0.0; 1.5; 2.3 |]\n    use p = fixed arr\n    // code that uses p as a nativeptr&lt;float&gt;\n</code></pre> <p>Pinning a string:</p> <pre><code>let pinString() =\n    let str = \"Hello\"\n    use pChar = fixed str\n    // code that uses pChar as a nativeptr&lt;char&gt;\n</code></pre> <p>The <code>fixed</code> keyword is used to pin the expression and can only appear immediately to the right of a <code>use</code> binding. The pointer is fixed for the duration of the <code>use</code> binding's scope; once it goes out of scope, it is no longer pinned. This construct is not a try/finally <code>IDisposable</code> pattern but is instead used to define the scope of the pinning.</p> <p>A pinned pointer expression is more efficient and convenient than creating a <code>GCHandle</code>.</p> <p>Like all pointer-related code, the use of <code>fixed</code> is considered an unsafe feature and will result in a compiler warning. The use of <code>fixed</code> is restricted to expressions within functions or methods and cannot be used at the script or module level.</p>"},{"location":"expressions/#67-type-related-expressions","title":"6.7 Type-related Expressions","text":""},{"location":"expressions/#671-type-annotated-expressions","title":"6.7.1 Type-Annotated Expressions","text":"<p>A type-annotated expression has the following form, where <code>ty</code> indicates the static type of <code>expr</code>:</p> <pre><code>expr : ty\n</code></pre> <p>For example:</p> <pre><code>(1 : int)\nlet f x = (x : string) + x\n</code></pre> <p>When checked, the initial type of the overall expression is asserted to be equal to <code>ty</code>. Expression <code>expr</code> is then checked with initial type <code>ty</code>. The expression elaborates to the elaborated form of <code>expr</code>. This ensures that information from the annotation is used during the analysis of <code>expr</code> itself.</p>"},{"location":"expressions/#672-static-coercion-expressions","title":"6.7.2 Static Coercion Expressions","text":"<p>A static coercion expression \u2014 also called a flexible type constraint \u2014 has the following form:</p> <pre><code>expr :&gt; ty\n</code></pre> <p>The expression <code>upcast expr</code> is equivalent to <code>expr :&gt; _</code>, so the target type is the same as the initial type of the overall expression. For example:</p> <pre><code>(1 :&gt; obj)\n(\"Hello\" :&gt; obj)\n([1;2;3] :&gt; seq&lt;int&gt;).GetEnumerator()\n(upcast 1 : obj)\n</code></pre> <p>The initial type of the overall expression is <code>ty</code>. Expression <code>expr</code> is checked using a fresh initial type <code>tye</code>, with constraint <code>tye :&gt; ty</code>. Static coercions are a primitive elaborated form.</p>"},{"location":"expressions/#673-dynamic-type-test-expressions","title":"6.7.3 Dynamic Type-Test Expressions","text":"<p>A dynamic type-test expression has the following form:</p> <pre><code>expr :? ty\n</code></pre> <p>For example:</p> <pre><code>((1 :&gt; obj) :? int)\n((1 :&gt; obj) :? string)\n</code></pre> <p>The initial type of the overall expression is <code>bool</code>. Expression <code>expr</code> is checked using a fresh initial type <code>tye</code>. After checking:</p> <ul> <li>The type <code>tye</code> must not be a variable type.</li> <li>A warning is given if the type test will always be true and therefore is unnecessary.</li> <li>The type <code>tye</code> must not be sealed.</li> <li>If type <code>ty</code> is sealed, or if <code>ty</code> is a variable type, or if type <code>tye</code> is not an interface type, then <code>ty :&gt; tye</code>     is asserted.</li> </ul> <p>Dynamic type tests are a primitive elaborated form.</p>"},{"location":"expressions/#674-dynamic-coercion-expressions","title":"6.7.4 Dynamic Coercion Expressions","text":"<p>A dynamic coercion expression has the following form:</p> <pre><code>expr :?&gt; ty\n</code></pre> <p>The expression downcast <code>e1</code> is equivalent to <code>expr :?&gt; _</code> , so the target type is the same as the initial type of the overall expression. For example:</p> <pre><code>let obj1 = (1 :&gt; obj)\n(obj1 :?&gt; int)\n(obj1 :?&gt; string)\n(downcast obj1 : int)\n</code></pre> <p>The initial type of the overall expression is <code>ty</code>. Expression <code>expr</code> is checked using a fresh initial type <code>tye</code>. After these checks:</p> <ul> <li>The type <code>tye</code> must not be a variable type.</li> <li>A warning is given if the type test will always be true and therefore is unnecessary.</li> <li>The type <code>tye</code> must not be sealed.</li> <li>If type <code>ty</code> is sealed, or if <code>ty</code> is a variable type, or if type <code>tye</code> is not an interface type, then <code>ty :&gt; tye</code>     is asserted.</li> </ul> <p>Dynamic coercions are a primitive elaborated form.</p>"},{"location":"expressions/#68-quoted-expressions","title":"6.8 Quoted Expressions","text":"<p>An expression in one of these forms is a quoted expression:</p> <pre><code>&lt;@ expr @&gt;\n\n&lt;@@ expr @@&gt;\n</code></pre> <p>The former is a strongly typed quoted expression , and the latter is a weakly typed quoted expression. In both cases, the expression forms capture the enclosed expression in the form of a typed abstract syntax tree.</p> <p>The exact nodes that appear in the expression tree are determined by the elaborated form of <code>expr</code> that type checking produces.</p> <p>For details about the nodes that may be encountered, see the documentation for the <code>FSharp.Quotations.Expr</code> type in the F# core library. In particular, quotations may contain:</p> <ul> <li> <p>References to module-bound functions and values, and to type-bound members. For example:</p> <pre><code>let id x = x\nlet f (x : int) = &lt;@ id 1 @&gt;\n</code></pre> <p>In this case the value appears in the expression tree as a node of kind <code>FSharp.Quotations.Expr.Call</code>.</p> </li> <li> <p>A type, module, function, value, or member that is annotated with the <code>ReflectedDefinition</code>     attribute. If so, the expression tree that forms its definition may be retrieved dynamically using     the <code>FSharp.Quotations.Expr.TryGetReflectedDefinition</code>.</p> <p>If the <code>ReflectedDefinition</code> attribute is applied to a type or module, it will be recursively applied to all members, too.</p> </li> <li> <p>References to defined values, such as the following:</p> <pre><code>let f (x : int) = &lt;@ x + 1 @&gt;\n</code></pre> <p>Such a value appears in the expression tree as a node of kind FSharp.Quotations.Expr.Value.</p> </li> <li> <p>References to generic type parameters or uses of constructs whose type involves a generic     parameter, such as the following:</p> <pre><code>let f (x:'T) = &lt;@ (x, x) : 'T * 'T @&gt;\n</code></pre> <p>In this case, the actual value of the type parameter is implicitly substituted throughout the type annotations and types in the generated expression tree.</p> </li> </ul> <p>As of F# 3. 1 , the following limitations apply to quoted expressions:</p> <ul> <li>Quotations may not use object expressions.</li> <li>Quotations may not define expression-bound functions that are themselves inferred to be     generic. Instead, expression-bound functions should either include type annotations to refer to a     specific type or should be written by using module-bound functions or class-bound members.</li> </ul>"},{"location":"expressions/#681-strongly-typed-quoted-expressions","title":"6.8.1 Strongly Typed Quoted Expressions","text":"<p>A strongly typed quoted expression has the following form:</p> <pre><code>&lt;@ expr @&gt;\n</code></pre> <p>For example:</p> <pre><code>&lt;@ 1 + 1 @&gt;\n\n&lt;@ (fun x -&gt; x + 1) @&gt;\n</code></pre> <p>In the first example, the type of the expression is <code>FSharp.Quotations.Expr&lt;int&gt;</code>. In the second example, the type of the expression is <code>FSharp.Quotations.Expr&lt;int -&gt; int&gt;</code>.</p> <p>When checked, the initial type of a strongly typed quoted expression <code>&lt;@ expr @&gt;</code> is asserted to be of the form <code>FSharp.Quotations.Expr&lt;ty&gt;</code> for a fresh type <code>ty</code>. The expression <code>expr</code> is checked with initial type <code>ty</code>.</p>"},{"location":"expressions/#682-weakly-typed-quoted-expressions","title":"6.8.2 Weakly Typed Quoted Expressions","text":"<p>A weakly typed quoted expression has the following form:</p> <pre><code>&lt;@@ expr @@&gt;\n</code></pre> <p>Weakly typed quoted expressions are similar to strongly quoted expressions but omit any type annotation. For example:</p> <pre><code>&lt;@@ 1 + 1 @@&gt;\n\n&lt;@@ (fun x -&gt; x + 1) @@&gt;\n</code></pre> <p>In both these examples, the type of the expression is <code>FSharp.Quotations.Expr</code>.</p> <p>When checked, the initial type of a weakly typed quoted expression <code>&lt;@@ expr @@&gt;</code> is asserted to be of the form <code>FSharp.Quotations.Expr</code>. The expression <code>expr</code> is checked with fresh initial type <code>ty</code>.</p>"},{"location":"expressions/#683-expression-splices","title":"6.8.3 Expression Splices","text":"<p>Both strongly typed and weakly typed quotations may contain expression splices in the following forms:</p> <pre><code>%expr\n%%expr\n</code></pre> <p>These are respectively strongly typed and weakly typed splicing operators.</p>"},{"location":"expressions/#6831-strongly-typed-expression-splices","title":"6.8.3.1 Strongly Typed Expression Splices","text":"<p>An expression of the following form is a strongly typed expression splice :</p> <pre><code>%expr\n</code></pre> <p>For example, given</p> <pre><code>open FSharp.Quotations\nlet f1 (v:Expr&lt;int&gt;) = &lt;@ %v + 1 @&gt;\nlet expr = f1 &lt;@ 3 @&gt;\n</code></pre> <p>the identifier <code>expr</code> evaluates to the same expression tree as <code>&lt;@ 3 + 1 @&gt;</code>. The expression tree for <code>&lt;@ 3 @&gt;</code> replaces the splice in the corresponding expression tree node.</p> <p>A strongly typed expression splice may appear only in a quotation. Assuming that the splice expression <code>%expr</code> is checked with initial type <code>ty</code> , the expression <code>expr</code> is checked with initial type <code>FSharp.Quotations.Expr&lt;ty&gt;</code>.</p> <p>Note: The rules in this section apply to any use of the prefix operator <code>FSharp.Core.ExtraTopLevelOperators.(~%)</code>. Uses of this operator must be applied to an argument and may only appear in quoted expressions.</p> <p>6.8.3.2 Weakly Typed Expression Splices An expression of the following form is a weakly typed expression splice :</p> <pre><code>%%expr\n</code></pre> <p>For example, given</p> <pre><code>open FSharp.Quotations\nlet f1 (v:Expr) = &lt;@ %%v + 1 @&gt;\nlet tree = f1 &lt;@@ 3 @@&gt;\n</code></pre> <p>the identifier <code>tree</code> evaluates to the same expression tree as <code>&lt;@ 3 + 1 @&gt;</code>. The expression tree replaces the splice in the corresponding expression tree node.</p> <p>A weakly typed expression splice may appear only in a quotation. Assuming that the splice expression <code>%%expr</code> is checked with initial type <code>ty</code>, then the expression <code>expr</code> is checked with initial type <code>FSharp.Quotations.Expr</code>. No additional constraint is placed on <code>ty</code>.</p> <p>Additional type annotations are often required for successful use of this operator.</p> <p>Note: The rules in this section apply to any use of the prefix operator <code>FSharp.Core.ExtraTopLevelOperators.(~%%)</code>, which is defined in the F# core library. Uses of this operator must be applied to an argument and may only occur in quoted expressions.</p>"},{"location":"expressions/#69-evaluation-of-elaborated-forms","title":"6.9 Evaluation of Elaborated Forms","text":"<p>At runtime, execution evaluates expressions to values. The evaluation semantics of each expression form are specified in the subsections that follow.</p>"},{"location":"expressions/#691-values-and-execution-context","title":"6.9.1 Values and Execution Context","text":"<p>The execution of elaborated F# expressions results in values. Values include:</p> <ul> <li>Primitive constant values</li> <li>The special value <code>null</code></li> <li>References to object values in the global heap of object values</li> <li>Values for value types, containing a value for each field in the value type</li> <li>Pointers to mutable locations (including static mutable locations, mutable fields and array     elements)</li> </ul> <p>Evaluation assumes the following evaluation context:</p> <ul> <li>A global heap of object values. Each object value contains:</li> <li>A runtime type and dispatch map</li> <li>A set of fields with associated values</li> <li>For array objects, an array of values in index order</li> <li>For function objects, an expression which is the body of the function</li> <li>An optional union case label , which is an identifier</li> <li>A closure environment that assigns values to all variables that are referenced in the method        bodies that are associated with the object</li> <li>A global environment that maps runtime-type/name pairs to values.Each name identifies a static     field in a type definition or a value in a module.</li> <li>A local environment mapping names of variables to values.</li> <li>A local stack of active exception handlers, made up of a stack of try/with and try/finally handlers.</li> </ul> <p>Evaluation may also raise an exception. In this case, the stack of active exception handlers is processed until the exception is handled, in which case additional expressions may be executed (for</p> <p>try/finally handlers), or an alternative expression may be evaluated (for try/with handlers), as described below.</p>"},{"location":"expressions/#692-parallel-execution-and-memory-model","title":"6.9.2 Parallel Execution and Memory Model","text":"<p>In a concurrent environment, evaluation may involve both multiple active computations (multiple concurrent and parallel threads of execution) and multiple pending computations (pending callbacks, such as those activated in response to an I/O event).</p> <p>If multiple active computations concurrently access mutable locations in the global environment or heap, the atomicity, read, and write guarantees of the underlying CLI implementation apply. The guarantees are related to the logical sizes and characteristics of values, which in turn depend on their type:</p> <ul> <li>F# reference types are guaranteed to map to CLI reference types. In the CLI memory model,     reference types have atomic reads and writes.</li> <li>F# value types map to a corresponding CLI value type that has corresponding fields. Reads and     writes of sizes less than or equal to one machine word are atomic.</li> </ul> <p>The <code>VolatileField</code> attribute marks a mutable location as volatile in the compiled form of the code.</p> <p>Ordering of reads and writes from mutable locations may be adjusted according to the limitations specified by the CLI memory model. The following example shows situations in which changes to read and write order can occur, with annotations about the order of reads:</p> <pre><code>type ClassContainingMutableData() =\n    let value = (1, 2)\n    let mutable mutableValue = (1, 2)\n\n    [&lt;VolatileField&gt;]\n    let mutable volatileMutableValue = (1, 2)\n\n    member x.ReadValues() =\n        // Two reads on an immutable value\n        let (a1, b1) = value\n\n        // One read on mutableValue, which may be duplicated according\n        // to ECMA CLI spec.\n        let (a2, b2) = mutableValue\n\n        // One read on volatileMutableValue, which may not be duplicated.\n        let (a3, b3) = volatileMutableValue\n\n        a1, b1, a2, b2, a3, b3\n\n    member x.WriteValues() =\n        // One read on mutableValue, which may be duplicated according\n        // to ECMA CLI spec.\n        let (a2, b2) = mutableValue\n\n        // One write on mutableValue.\n        mutableValue &lt;- (a2 + 1, b2 + 1)\n\n        // One read on volatileMutableValue, which may not be duplicated.\n        let (a3, b3) = volatileMutableValue\n\n        // One write on volatileMutableValue.\n        volatileMutableValue &lt;- (a3 + 1, b3 + 1)\n\nlet obj = ClassContainingMutableData()\nAsync.Parallel [ async { return obj.WriteValues() };\n                 async { return obj.WriteValues() };\n                 async { return obj.ReadValues() };\n                 async { return obj.ReadValues() } ]\n</code></pre>"},{"location":"expressions/#693-zero-values","title":"6.9.3 Zero Values","text":"<p>Some types have a zero value. The zero value is the \u201cdefault\u201d value for the type in the CLI execution environment. The following types have the following zero values:</p> <ul> <li>For reference types, the <code>null</code> value.</li> <li>For value types, the value with all fields set to the zero value for the type of the field. The zero     value is also computed by the F# library function <code>Unchecked.defaultof&lt;ty&gt;</code>.</li> </ul>"},{"location":"expressions/#694-taking-the-address-of-an-elaborated-expression","title":"6.9.4 Taking the Address of an Elaborated Expression","text":"<p>When the F# compiler determines the elaborated forms of certain expressions, it must compute a \u201creference\u201d to an elaborated expression <code>expr</code> , written <code>AddressOf(expr, mutation)</code>. The <code>AddressOf</code> operation is used internally within this specification to indicate the elaborated forms of address-of expressions, assignment expressions, and method and property calls on objects of variable and value types.</p> <p>The <code>AddressOf</code> operation is computed as follows:</p> <ul> <li>If <code>expr</code> has form <code>path</code> where <code>path</code> is a reference to a value with type <code>byref&lt;ty&gt;</code>, the elaborated     form is <code>&amp;path</code>.</li> <li>If <code>expr</code> has form <code>expra.field</code> where <code>field</code> is a mutable, non-readonly CLI field, the elaborated     form is <code>&amp;(AddressOf(expra).field)</code>.</li> <li>If <code>expr</code> has form expra.[exprb] where the operation is an array lookup, the elaborated form is     <code>&amp;(AddressOf(expra).[exprb])</code>.</li> <li>If <code>expr</code> has any other form, the elaborated form is <code>&amp;v</code> ,where <code>v</code> is a fresh mutable local value that     is initialized by adding <code>let v = expr</code> to the overall elaborated form for the entire assignment     expression. This initialization is known as a defensive copy of an immutable value. If <code>expr</code> is a     struct, <code>expr</code> is copied each time the <code>AddressOf</code> operation is applied, which results in a different     address each time. To keep the struct in place, the field that contains it should be marked as     mutable.</li> </ul> <p>The <code>AddressOf</code> operation is computed with respect to <code>mutation</code>, which indicates whether the relevant elaborated form uses the resulting pointer to change the contents of memory. This assumption changes the errors and warnings reported.</p> <ul> <li>If <code>mutation</code> is <code>DefinitelyMutates</code>, then an error is given if a defensive copy must be created.</li> <li>If <code>mutation</code> is <code>PossiblyMutates</code>, then a warning is given if a defensive copy arises.</li> </ul> <p>An F# compiler can optionally upgrade <code>PossiblyMutates</code> to <code>DefinitelyMutates</code> for calls to property setters and methods named <code>MoveNext</code> and <code>GetNextArg</code>, which are the most common cases of struct- mutators in CLI library design. This is done by the F# compiler.</p> <p>Note:In F#, the warning \u201ccopy due to possible mutation of value type\u201d is a level 4   warning and is not reported when using the default settings of the F# compiler. This is   because the majority of value types in CLI libraries are immutable. This is warning   number 52 in the F# implementation.    CLI libraries do not include metadata to indicate whether a particular value type is   immutable. Unless a value is held in arrays or locations marked mutable, or a value type   is known to be immutable to the F# compiler, F# inserts copies to ensure that   inadvertent mutation does not occur.</p>"},{"location":"expressions/#695-evaluating-value-references","title":"6.9.5 Evaluating Value References","text":"<p>At runtime, an elaborated value reference <code>v</code> is evaluated by looking up the value of <code>v</code> in the local environment.</p>"},{"location":"expressions/#696-evaluating-function-applications","title":"6.9.6 Evaluating Function Applications","text":"<p>At runtime, an elaborated application of a function <code>f e1 ... en</code> is evaluated as follows:</p> <ul> <li>The expressions <code>f</code> and <code>e1 ... en</code>, are evaluated.</li> <li>If <code>f</code> evaluates to a function value with closure environment <code>E</code>, arguments <code>v1 ... vm</code>, and body <code>expr</code>,     where <code>m &lt;= n</code> , then <code>E</code> is extended by mapping <code>v1 ... vm</code> to the argument values for <code>e1 ... em</code>. The     expression <code>expr</code> is then evaluated in this extended environment and any remaining arguments     applied.</li> <li>If <code>f</code> evaluates to a function value with more than <code>n</code> arguments, then a new function value is     returned with an extended closure mapping <code>n</code> additional formal argument names to the     argument values for <code>e1 ... em</code>.</li> </ul> <p>The result of calling the <code>obj.GetType()</code> method on the resulting object is under-specified (see \u00a76.9.24).</p>"},{"location":"expressions/#697-evaluating-method-applications","title":"6.9.7 Evaluating Method Applications","text":"<p>At runtime an elaborated application of a method is evaluated as follows:</p> <ul> <li>The elaborated form is <code>e0.M(e1 , ..., en)</code> for an instance method or <code>M(e, ..., en)</code> for a static method.</li> <li>The (optional) <code>e0</code> and <code>e1</code> ,..., en are evaluated in order.</li> <li>If <code>e0</code> evaluates to <code>null</code>, a <code>NullReferenceException</code> is raised.</li> <li>If the method is declared <code>abstract</code> \u2014 that is, if it is a virtual dispatch slot \u2014 then the body of the     member is chosen according to the dispatch maps of the value of <code>e0</code> (\u00a714.8).</li> <li>The formal parameters of the method are mapped to corresponding argument values. The body     of the method member is evaluated in the resulting environment.</li> </ul>"},{"location":"expressions/#698-evaluating-union-cases","title":"6.9.8 Evaluating Union Cases","text":"<p>At runtime, an elaborated use of a union case <code>Case(e1 , ..., en)</code> for a union type <code>ty</code> is evaluated as follows:</p> <ul> <li>The expressions <code>e1, ..., en</code> are evaluated in order.</li> <li>The result of evaluation is an object value with union case label <code>Case</code> and fields given by the     values of <code>e1 , ..., en</code>.</li> <li>If the type <code>ty</code> uses null as a representation (\u00a75.4.8) and <code>Case</code> is the single union case without     arguments, the generated value is <code>null</code>.</li> <li>The runtime type of the object is either <code>ty</code> or an internally generated type that is compatible     with <code>ty</code>.</li> </ul>"},{"location":"expressions/#699-evaluating-field-lookups","title":"6.9.9 Evaluating Field Lookups","text":"<p>At runtime, an elaborated lookup of a CLI or F# fields is evaluated as follows:</p> <ul> <li>The elaborated form is <code>expr.F</code> for an instance field or <code>F</code> for a static field.</li> <li>The (optional) <code>expr</code> is evaluated.</li> <li>If <code>expr</code> evaluates to <code>null</code>, a <code>NullReferenceException</code> is raised.</li> <li>The value of the field is read from either the global field table or the local field table associated     with the object.</li> </ul>"},{"location":"expressions/#6910-evaluating-array-expressions","title":"6.9.10 Evaluating Array Expressions","text":"<p>At runtime, an elaborated array expression <code>[| e1; ...; en |]ty</code> is evaluated as follows:</p> <ul> <li>Each expression <code>e1 ... en</code> is evaluated in order.</li> <li>The result of evaluation is a new array of runtime type <code>ty[]</code> that contains the resulting values in     order.</li> </ul>"},{"location":"expressions/#6911-evaluating-record-expressions","title":"6.9.11 Evaluating Record Expressions","text":"<p>At runtime, an elaborated record construction <code>{ field1 = e1; ... ; fieldn = en }ty</code> is evaluated as follows:</p> <ul> <li>Each expression <code>e1 ... en</code> is evaluated in order.</li> <li>The result of evaluation is an object of type <code>ty</code> with the given field values</li> </ul>"},{"location":"expressions/#6912-evaluating-function-expressions","title":"6.9.12 Evaluating Function Expressions","text":"<p>At runtime, an elaborated function expression <code>(fun v1 ... vn -&gt; expr)</code> is evaluated as follows:</p> <ul> <li>The expression evaluates to a function object with a closure that assigns values to all variables     that are referenced in <code>expr</code> and a function body that is <code>expr</code>.</li> <li>The values in the closure are the current values of those variables in the execution environment.</li> <li>The result of calling the <code>obj.GetType()</code> method on the resulting object is under-specified (see     \u00a76.9.24).</li> </ul>"},{"location":"expressions/#6913-evaluating-object-expressions","title":"6.9.13 Evaluating Object Expressions","text":"<p>At runtime, elaborated object expressions</p> <pre><code>{ new ty0 args-expr? object-members\n      interface ty1 object-members1\n      interface tyn object-membersn }\n</code></pre> <p>is evaluated as follows:</p> <ul> <li>The expression evaluates to an object whose runtime type is compatible with all of the <code>tyi</code> and     which has the corresponding dispatch map (\u00a714.8). If present, the base construction expression     <code>ty0 (args-expr)</code> is executed as the first step in the construction of the object.</li> <li>The object is given a closure that assigns values to all variables that are referenced in <code>expr</code>.</li> <li>The values in the closure are the current values of those variables in the execution environment.</li> </ul> <p>The result of calling the <code>obj.GetType()</code> method on the resulting object is under-specified (see \u00a76.9.24).</p>"},{"location":"expressions/#6914-evaluating-definition-expressions","title":"6.9.14 Evaluating Definition Expressions","text":"<p>At runtime, each elaborated definition <code>pat = expr</code> is evaluated as follows:</p> <ul> <li>The expression <code>expr</code> is evaluated.</li> <li>The expression is then matched against <code>pat</code> to produce a value for each variable pattern (\u00a77.2)     in <code>pat</code>.</li> <li>These mappings are added to the local environment.</li> </ul>"},{"location":"expressions/#6915-evaluating-integer-for-loops","title":"6.9.15 Evaluating Integer For Loops","text":"<p>At runtime, an integer for loop <code>for var = expr1 to expr2 do expr3 done</code> is evaluated as follows:</p> <ul> <li>Expressions <code>expr1</code> and <code>expr2</code> are evaluated once to values <code>v1</code> and <code>v2</code>.</li> <li>The expression <code>expr3</code> is evaluated repeatedly with the variable <code>var</code> assigned successive values in     the range of <code>v1</code> up to <code>v2</code>.</li> <li>If <code>v1</code> is greater than <code>v2</code> , then <code>expr3</code> is never evaluated.</li> </ul>"},{"location":"expressions/#6916-evaluating-while-loops","title":"6.9.16 Evaluating While Loops","text":"<p>As runtime, while-loops <code>while expr1 do expr2 done</code> are evaluated as follows:</p> <ul> <li>Expression <code>expr1</code> is evaluated to a value <code>v1</code>.</li> <li>If <code>v1</code> is true, expression <code>expr2</code> is evaluated, and the expression <code>while expr1 do expr2 done</code> is     evaluated again.</li> <li>If <code>v1</code> is <code>false</code>, the loop terminates and the resulting value is <code>null</code> (the representation of the only     value of type <code>unit</code>)</li> </ul>"},{"location":"expressions/#6917-evaluating-static-coercion-expressions","title":"6.9.17 Evaluating Static Coercion Expressions","text":"<p>At runtime, elaborated static coercion expressions of the form <code>expr :&gt; ty</code> are evaluated as follows:</p> <ul> <li>Expression <code>expr</code> is evaluated to a value <code>v</code>.</li> <li>If the static type of <code>e</code> is a value type, and <code>ty</code> is a reference type, <code>v</code> is boxed ; that is, <code>v</code> is converted     to an object on the heap with the same field assignments as the original value. The expression     evaluates to a reference to this object.</li> <li>Otherwise, the expression evaluates to <code>v</code>.</li> </ul>"},{"location":"expressions/#6918-evaluating-dynamic-type-test-expressions","title":"6.9.18 Evaluating Dynamic Type-Test Expressions","text":"<p>At runtime, elaborated dynamic type test expressions <code>expr :? ty</code> are evaluated as follows:</p> <ol> <li>Expression <code>expr</code> is evaluated to a value <code>v</code>.</li> <li>If <code>v</code> is <code>null</code>, then:<ul> <li>If <code>tye</code> uses <code>null</code> as a representation (\u00a75.4.8), the result is <code>true</code>.</li> <li>Otherwise the expression evaluates to <code>false</code>.</li> </ul> </li> <li>If <code>v</code> is not <code>null</code> and has runtime type <code>vty</code> which dynamically converts to <code>ty</code> (\u00a75.4.10), the     expression evaluates to <code>true</code>. However, if <code>ty</code> is an enumeration type, the expression evaluates to     <code>true</code> if and only if <code>ty</code> is precisely <code>vty</code>.</li> </ol>"},{"location":"expressions/#6919-evaluating-dynamic-coercion-expressions","title":"6.9.19 Evaluating Dynamic Coercion Expressions","text":"<p>At runtime, elaborated dynamic coercion expressions <code>expr :?&gt; ty</code> are evaluated as follows:</p> <ol> <li>Expression <code>expr</code> is evaluated to a value <code>v</code>.</li> <li>If <code>v</code> is <code>null</code>:<ul> <li>If <code>tye</code> uses <code>null</code> as a representation (\u00a75.4.8), the result is the <code>null</code> value.</li> <li>Otherwise a <code>NullReferenceException</code> is raised.</li> </ul> </li> <li>If <code>v</code> is not <code>null</code>:<ul> <li>If <code>v</code> has dynamic type <code>vty</code> which dynamically converts to <code>ty</code> (\u00a75.4.10), the expression evaluates to the dynamic conversion of <code>v</code> to <code>ty</code>.<ul> <li>If <code>vty</code> is a reference type and <code>ty</code> is a value type, then <code>v</code> is unboxed ; that is, <code>v</code> is      converted from an object on the heap to a struct value with the same field      assignments as the object. The expression evaluates to this value.</li> <li>Otherwise, the expression evaluates to <code>v</code>.</li> </ul> </li> <li>Otherwise an <code>InvalidCastException</code> is raised.</li> </ul> </li> </ol> <p>Expressions of the form <code>expr :?&gt; ty</code> evaluate in the same way as the F# library function <code>unbox&lt;ty&gt;(expr)</code>.</p> <p>Note: Some F# types \u2014 most notably the <code>option&lt;_&gt;</code> type \u2014 use <code>null</code> as a representation     for efficiency reasons (\u00a75.4.8). For these  types, boxing and unboxing can lose type     distinctions. For example, contrast the following two examples:</p> <pre><code>```fsother\n&gt; (box([]:string list) :?&gt; int list);;\nSystem.InvalidCastException...\n&gt; (box(None:string option) :?&gt; int option);;\nval it : int option = None\n```\n</code></pre> <p>In the first case, the conversion from an empty list of strings to an empty list of integers     (after first boxing) fails. In the second case, the conversion from a string option to an     integer option (after first boxing) succeeds.</p>"},{"location":"expressions/#6920-evaluating-sequential-execution-expressions","title":"6.9.20 Evaluating Sequential Execution Expressions","text":"<p>At runtime, elaborated sequential expressions <code>expr1 ; expr2</code> are evaluated as follows:</p> <ul> <li>The expression <code>expr1</code> is evaluated for its side effects and the result is discarded.</li> <li>The expression <code>expr2</code> is evaluated to a value <code>v2</code> and the result of the overall expression is <code>v2</code>.</li> </ul>"},{"location":"expressions/#6921-evaluating-try-with-expressions","title":"6.9.21 Evaluating Try-with Expressions","text":"<p>At runtime, elaborated try-with expressions try <code>expr1 with rules</code> are evaluated as follows:</p> <ul> <li>The expression <code>expr1</code> is evaluated to a value <code>v1</code>.</li> <li>If no exception occurs, the result is the value <code>v1</code>.</li> <li>If an exception occurs, the pattern rules are executed against the resulting exception value.</li> <li>If no rule matches, the exception is reraised.</li> <li>If a rule <code>pat -&gt; expr2</code> matches, the mapping <code>pat = v1</code> is added to the local environment,        and <code>expr2</code> is evaluated.</li> </ul>"},{"location":"expressions/#6922-evaluating-try-finally-expressions","title":"6.9.22 Evaluating Try-finally Expressions","text":"<p>At runtime, elaborated try-finally expressions try <code>expr1 finally expr2</code> are evaluated as follows:</p> <ul> <li>The expression <code>expr1</code> is evaluated.</li> <li>If the result of this evaluation is a value <code>v</code> , then <code>expr2</code> is evaluated.        1) If this evaluation results in an exception, then the overall result is that exception.        2) If this evaluation does not result in an exception, then the overall result is <code>v</code>.</li> <li>If the result of this evaluation is an exception, then <code>expr2</code> is evaluated.        3) If this evaluation results in an exception, then the overall result is that exception.        4) If this evaluation does not result in an exception, then the original exception is re-           raised.</li> </ul>"},{"location":"expressions/#6923-evaluating-addressof-expressions","title":"6.9.23 Evaluating AddressOf Expressions","text":"<p>At runtime, an elaborated address-of expression is evaluated as follows. First, the expression has one of the following forms:</p> <ul> <li><code>&amp;path</code> where <code>path</code> is a static field.</li> <li><code>&amp;(expr.field)</code></li> <li><code>&amp;(expra.[exprb])</code></li> <li><code>&amp;v</code> where <code>v</code> is a local mutable value.</li> </ul> <p>The expression evaluates to the address of the referenced local mutable value, mutable field, or mutable static field.</p> <p>Note: The underlying CIL execution machinery that F# uses supports covariant arrays, as evidenced by the fact that the type <code>string[]</code> dynamically converts to <code>obj[]</code> (\u00a75.4.10). Although this feature is rarely used in F#, its existence means that array assignments and taking the address of array elements may fail at runtime with a <code>System.ArrayTypeMismatchException</code> if the runtime type of the target array does not match the runtime type of the element being assigned. For example, the following code fails at runtime:</p> <pre><code>let f (x: byref&lt;obj&gt;) = ()\n\nlet a = Array.zeroCreate&lt;obj&gt; 10\nlet b = Array.zeroCreate&lt;string&gt; 10\nf (&amp;a.[0])\nlet bb = ((b :&gt; obj) :?&gt; obj[])\n// The next line raises a System.ArrayTypeMismatchException exception.\nF (&amp;bb.[1])\n</code></pre>"},{"location":"expressions/#6924-values-with-underspecified-object-identity-and-type-identity","title":"6.9.24 Values with Underspecified Object Identity and Type Identity","text":"<p>The CLI and F# support operations that detect object identity\u2014that is, whether two object references refer to the same \u201cphysical\u201d object. For example, <code>System.Object.ReferenceEquals(obj1, obj2)</code> returns true if the two object references refer to the same object. Similarly, <code>System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode()</code> returns a hash code that is partly based on physical object identity, and the <code>AddHandler</code> and <code>RemoveHandler</code> operations (which register and unregister event handlers) are based on the object identity of delegate values.</p> <p>The results of these operations are underspecified when used with values of the following F# types:</p> <ul> <li>Function types</li> <li>Tuple types</li> <li>Immutable record types</li> <li>Union types</li> <li>Boxed immutable value types</li> </ul> <p>For two values of such types, the results of <code>System.Object.ReferenceEquals</code> and <code>System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode</code> are underspecified; however, the operations terminate and do not raise exceptions. An implementation of F# is not required to define the results of these operations for values of these types.</p> <p>For function values and objects that are returned by object expressions, the results of the following operations are underspecified in the same way:</p> <ul> <li><code>Object.GetHashCode()</code></li> <li><code>Object.GetType()</code></li> </ul> <p>For union types the results of the following operations are underspecified in the same way:</p> <ul> <li><code>Object.GetType()</code></li> </ul>"},{"location":"features-for-ml-compatibility/","title":"19. Features for ML Compatibility","text":"<p>F# has its roots in the Caml family of programming languages and its core constructs are similar to some other ML-family languages. As a result, F# supports some constructs for compatibility with other implementations of ML-family languages.</p>"},{"location":"features-for-ml-compatibility/#191-conditional-compilation-for-ml-compatibility","title":"19.1 Conditional Compilation for ML Compatibility","text":"<p>F# supports the following constructs for conditional compilation:</p> <pre><code>token start-fsharp-token = \"(*IF-FSHARP\" | \"(*F#\"\ntoken end-fsharp-token = \"ENDIF-FSHARP*)\" | \"F#*)\"\ntoken start-ml-token = \"(*IF-OCAML*)\"\ntoken end-ml-token = \"(*ENDIF-OCAML*)\"\n</code></pre> <p>F# ignores the <code>start-fsharp-token</code> and <code>end-fsharp-token</code> tokens. This means that sections marked</p> <pre><code>(*IF-FSHARP ... ENDIF-FSHARP*)\n</code></pre> <p>or</p> <pre><code>(*F# ... F#*)\n</code></pre> <p>are included during tokenization when compiling with the F# compiler. The intervening text is tokenized and returned in the token stream as normal.</p> <p>In addition, the <code>start-ml-token</code> token is discarded and the following text is tokenized as <code>string</code> , <code>_</code> (any character), and <code>end-ml-token</code> until an <code>end-ml-token</code> is reached. Comments are not treated as special during this process and are simply processed as \u201cother text\u201d. This means that text surrounded by the following is excluded when compiling with the F# compiler:</p> <pre><code>(*IF-CAML*) ... (*ENDIF-CAML*)\nor (*IF-OCAML*) ... (*ENDIF-OCAML*)\n</code></pre> <p>The intervening text is tokenized as \u201cstrings and other text\u201d and the tokens are discarded until the corresponding end token is reached. Comments are not treated as special during this process and are simply processed as \u201cother text.\u201d</p> <p>The converse holds when programs are compiled using a typical ML compiler.</p>"},{"location":"features-for-ml-compatibility/#192-extra-syntactic-forms-for-ml-compatibility","title":"19.2 Extra Syntactic Forms for ML Compatibility","text":"<p>The following identifiers are also keywords primarily because they are keywords in OCaml. Although F# reserves several OCaml keywords for future use, the <code>/mlcompatibility</code> option enables the use of these keywords as identifiers.</p> <pre><code>token ocaml-ident-keyword =\n    asr land lor lsl lsr lxor mod\n</code></pre> <p>Note: In F# the following alternatives are available. The precedence of these operators differs from the precedence that OCaml uses. <code>asr &gt;&gt;&gt; (on signed type)</code> <code>land &amp;&amp;&amp;</code> <code>lor |||</code> <code>lsl &lt;&lt;&lt;</code> <code>lsr &gt;&gt;&gt; (on unsigned type)</code> <code>lxor ^^^</code> <code>mod %</code> <code>sig begin (that is, begin/end may be used instead of sig/end)</code></p> <p>F# includes the following additional syntactic forms for ML compatibility:</p> <pre><code>expr :=\n    | ...\n    | expr .( expr ) // array lookup\n    | expr .( expr ) &lt;- expr // array assignment\n</code></pre> <pre><code>type :=\n    | ...\n    | ( type ,..., type ) long-ident // generic type instantiation\n\nmodule-implementation :=\n    | ...\n    | module ident = struct ... end\n\nmodule-signature :=\n    | ...\n    | module ident : sig ... end\n</code></pre> <p>An ML compatibility warning occurs when these constructs are used.</p> <p>Note that the for-expression form <code>for var = expr1 downto expr2 do expr3</code> is also permitted for ML compatibility.</p> <p>The following expression forms</p> <pre><code>expr :=\n    | ...\n    | expr.(expr) // array lookup\n    | expr.(expr) &lt;- expr // array assignment\n</code></pre> <p>Are equivalent to the following uses of library-defined operators:</p> <pre><code>e1.(e2)               \u2192 (.()) e1 e2\ne1.(e2) &lt;- e3         \u2192 (.()&lt;-) e1 e2 e3\n</code></pre>"},{"location":"features-for-ml-compatibility/#193-extra-operators","title":"19.3 Extra Operators","text":"<p>F# defines the following two additional shortcut operators:</p> <pre><code>e1 or e2                  \u2192 (or) e1 e2\ne1 &amp; e2                   \u2192 (&amp;) e1 e2\n</code></pre>"},{"location":"features-for-ml-compatibility/#194-file-extensions-and-lexical-matters","title":"19.4 File Extensions and Lexical Matters","text":"<p>F# supports the use of the <code>.ml</code> and <code>.mli</code> extensions on the command line. The \u201cindentation awareness off\u201d syntax option is implicitly enabled when using either of these filename extensions.</p> <p>Lightweight syntax can be explicitly disabled in <code>.fs</code>, <code>.fsi</code>, <code>.fsx</code>, and <code>.fsscript</code> files by specifying <code>#indent \"off\"</code> as the first declaration in a file:</p> <pre><code>#indent \"off\"\n</code></pre> <p>When lightweight syntax is disabled, whitespace can include tab characters:</p> <pre><code>regexp whitespace = [ ' ' '\\t' ]+\n</code></pre>"},{"location":"inference-procedures/","title":"14. Inference Procedures","text":""},{"location":"inference-procedures/#141-name-resolution","title":"14.1 Name Resolution","text":"<p>The following sections describe how F# resolves names in various contexts.</p>"},{"location":"inference-procedures/#1411-name-environments","title":"14.1.1 Name Environments","text":"<p>Each point in the interpretation of an F# program is subject to an environment. The environment encompasses:</p> <ul> <li>All referenced external DLLs (assemblies).</li> <li> <p>ModulesAndNamespaces : a table that maps <code>long-ident</code>s to a list of signatures. Each signature is     either a namespace declaration group signature or a module signature.</p> <p>For example, <code>System.Collections</code> may map to one namespace declaration group signature for each referenced assembly that contributes to the <code>System.Collections</code> namespace, and to a module signature, if a module called <code>System.Collections</code> is declared or in a referenced assembly.</p> <p>If the program references multiple assemblies, the assemblies are added to the name resolution environment in the order in which the references appear on the command line. The order is important only if ambiguities occur in referencing the contents of assemblies\u2014for example, if two assemblies define the type <code>MyNamespace.C</code>.</p> </li> <li> <p>ExprItems : a table that maps names to the following items:</p> <ul> <li>A value</li> <li>A union case for use when constructing data</li> <li>An active pattern result tag for use when returning results from active patterns</li> <li>A type name for each class or struct type</li> </ul> </li> <li>FieldLabels : a table that maps names to sets of field references for record types</li> <li>PatItems : a table that maps names to the following items:<ul> <li>A union case, for use when pattern matching on data</li> <li>An active pattern case name, for use when specifying active patterns</li> <li>A literal definition</li> </ul> </li> <li> <p>Types : a table that maps names to type definitions. Two queries are supported on this table:</p> <ul> <li> <p>Find a type by name alone. This query may return multiple types. For example, in the default     type-checking environment, the resolution of <code>System.Tuple</code> returns multiple tuple types.</p> </li> <li> <p>Find a type by name and generic arity <code>n</code>. This query returns at most one type. For example, in     the default type-checking environment, the resolution of <code>System.Tuple</code> with <code>n = 2</code> returns a     single type.</p> </li> <li>ExtensionsInScope : a table that maps type names to one or more member definitions</li> </ul> </li> </ul> <p>The dot notation is resolved during type checking by consulting these tables.</p>"},{"location":"inference-procedures/#1412-name-resolution-in-module-and-namespace-paths","title":"14.1.2 Name Resolution in Module and Namespace Paths","text":"<p>Given an input <code>long-ident</code> and environment <code>env</code>, Name Resolution in Module and Namespace Paths computes the result of interpreting <code>long-ident</code> as a module or namespace. The procedure returns a list of modules and namespace declaration groups.</p> <p>Name Resolution in Module and Namespace Paths proceeds through the following steps:</p> <ol> <li>Consult the ModulesAndNamespaces table to resolve the <code>long-ident</code> prefix to a list of modules     and namespace declaration group signatures.</li> <li>If any identifiers remain unresolved, recursively consult the declared modules and sub-modules     of these namespace declaration groups.</li> <li>Concatenate all the results.</li> </ol> <p>If the <code>long-ident</code> starts with the special pseudo-identifier keyword <code>global</code>, the identifier is resolved by consulting the ModulesAndNamespaces table and ignoring all <code>open</code> directives, including those implied by <code>AutoOpen</code> attributes.</p> <p>For example, if the environment contains two referenced DLLs, and each DLL has namespace declaration groups for the namespaces <code>System</code>, <code>System.Collections</code>, and <code>System.Collections.Generic</code>, Name Resolution in Module and Namespace Paths for <code>System.Collections</code> returns the two namespace declaration groups named <code>System.Collections</code>, one from each assembly.</p>"},{"location":"inference-procedures/#1413-opening-modules-and-namespace-declaration-groups","title":"14.1.3 Opening Modules and Namespace Declaration Groups","text":"<p>When a module or namespace declaration group <code>F</code> is opened, the compiler adds items to the name environment as follows:</p> <ol> <li>Add each exception label for each exception type definition (\u00a78.11) in <code>F</code> to the ExprItems and     PatItems tables in the original order of declaration in <code>F</code>.</li> <li> <p>Add each type definition in the original order of declaration in <code>F</code>. Adding a type definition     involves the following procedure:</p> <ul> <li>If the type is a class or struct type (or an abbreviation of such a type), add the type name to the ExprItems table.</li> <li>If the type definition is a record, add the record field labels to the FieldLabels table, unless the type has the <code>RequireQualifiedAccess</code> attribute.</li> <li>If the type is a union, add the union cases to the ExprItems and PatItems tables, unless the type has the <code>RequireQualifiedAccess</code> attribute.</li> <li>Add the type to the TypeNames table. If the type has a CLI-encoded generic name such as <code>List`1</code>, add an entry under both <code>List</code> and <code>List`1</code>.</li> </ul> </li> <li> <p>Add each value in the original order of declaration in <code>F</code> , as follows:</p> <ul> <li>Add the value to the ExprItems table.</li> <li>If any value is an active pattern, add the tags of that active pattern to the PatItems table according to the original order of declaration.</li> <li>If the value is a literal, add it to the PatItems table.</li> <li>Add the member contents of each type extension in <code>Fi</code> to the ExtensionsInScope table according to the original order of declaration in <code>Fi</code>.</li> <li>Add each sub-module or sub-namespace declaration group in <code>Fi</code> to the ModulesAndNamespaces table according to the original order of declaration in <code>Fi</code>.</li> <li>Open any sub-modules that are marked with the <code>FSharp.Core.AutoOpen</code> attribute.</li> </ul> </li> </ol>"},{"location":"inference-procedures/#1414-name-resolution-in-expressions","title":"14.1.4 Name Resolution in Expressions","text":"<p>Given an input <code>long-ident</code> , environment <code>env</code> , and an optional count <code>n</code> of the number of subsequent type arguments <code>&lt;_, ..., _&gt;</code>, Name Resolution in Expressions computes a result that contains the interpretation of the <code>long-ident</code> <code>&lt;_, ..., _&gt;</code> prefix as a value or other expression item, and a residue path <code>rest</code>.</p> <p>How Name Resolution in Expressions proceeds depends on whether <code>long-ident</code> is a single identifier or is composed of more than one identifier.</p> <p>If <code>long-ident</code> is a single identifier <code>ident</code>:</p> <ol> <li>Look up <code>ident</code> in the ExprItems table. Return the result and empty <code>rest</code>.</li> <li>If <code>ident</code> does not appear in the ExprItems table, look it up in the Types table, with generic arity     that matches <code>n</code> if available. Return this type and empty <code>rest</code>.</li> <li>If <code>ident</code> does not appear in either the ExprItems table or the Types table, fail.</li> </ol> <p>If <code>long-ident</code> is composed of more than one identifier <code>ident.rest</code>, Name Resolution in Expressions proceeds as follows:</p> <ol> <li>If <code>ident</code> exists as a value in the ExprItems table, return the result, with <code>rest</code> as the residue.</li> <li> <p>If <code>ident</code> does not exist as a value in the ExprItems table, perform a backtracking search as     follows:</p> <ul> <li>Consider each division of <code>long-ident</code> into <code>[namespace-or-module-path].ident[.rest]</code>, in which the <code>namespace-or-module-path</code> becomes successively longer.</li> <li>For each such division, consider each module signature or namespace declaration group signature <code>F</code> in the list that is produced by resolving <code>namespace-or-module-path</code> by using Name Resolution in Module and Namespace Paths.</li> <li>For each such <code>F</code> , attempt to resolve <code>ident[.rest]</code> in the following order. If any resolution succeeds, then terminate the search:<ul> <li>A value in <code>F</code>. Return this item and <code>rest</code>.</li> <li>A union case in <code>F</code>. Return this item and <code>rest</code>.</li> <li>An exception constructor in <code>F</code>. Return this item and <code>rest</code>.</li> <li>A type in <code>F</code>. If <code>rest</code> is empty, then return this type; if not, resolve using Name Resolution for Members.</li> <li>A [sub-]module in <code>F</code>. Recursively resolve <code>rest</code> against the contents of this module.</li> </ul> </li> <li> <p>If steps 1 and 2 do not resolve <code>long-ident</code>, look up <code>ident</code> in the Types table.</p> </li> <li> <p>If the generic arity <code>n</code> is available, then look for a type that matches both <code>ident</code> and <code>n</code>.</p> </li> <li>If no generic arity <code>n</code> is available, and <code>rest</code> is not empty:<ul> <li>If the Types table contains a type <code>ident</code> that does not have generic arguments, resolve to this type.</li> <li>If the Types table contains a unique type <code>ident</code> that has generic arguments, resolve to this type. However, if the overall result of the Name Resolution in Expressions operation is a member, and the generic arguments do not appear in either the return or argument types of the item, warn that the generic arguments cannot be inferred from the type of the item.</li> <li>If neither of the preceding steps resolves the type, give an error.</li> </ul> </li> <li>If rest is empty, return the type, otherwise resolve using Name Resolution for Members.</li> <li>If steps 1-3 do not resolve <code>long-ident</code>, look up <code>ident</code> in the ExprItems table and return the result and residue <code>rest</code>.</li> <li>Otherwise, if <code>ident</code> is a symbolic operator name, resolve to an item that indicates an implicitly resolved symbolic operator.</li> <li>Otherwise, fail.</li> </ul> </li> </ol> <p>If the expression contains ambiguities, Name Resolution in Expressions returns the first result that the process generates. For example, consider the following cases:</p> <pre><code>module M =\n    type C =\n        | C of string\n        | D of string\n        member x.Prop1 = 3\n    type Data =\n        | C of string\n        | E\n        member x.Prop1 = 3\n        member x.Prop2 = 3\n    let C = 5\n    open M\n    let C = 4\n    let D = 6\n\n    let test1 = C               // resolves to the value C\n    let test2 = C.ToString()    // resolves to the value C with residue ToString\n    let test3 = M.C             // resolves to the value M.C\n    let test4 = M.Data.C        // resolves to the union case M.Data.C\n    let test5 = M.C.C           // error: first part resolves to the value M.C,\n                                // and this contains no field or property \"C\"\n    let test6 = C.Prop1         // error: the value C does not have a property Prop\n    let test7 = M.E.Prop2       // resolves to M.E, and then a property lookup\n</code></pre> <p>The following example shows the resolution behavior for type lookups that are ambiguous by generic arity:</p> <pre><code>module M =\n    type C&lt;'T&gt;() =\n        static member P = 1\n\n    type C&lt;'T,'U&gt;() =\n        static member P = 1\n\n    let _ = new M.C() // gives an error\n    let _ = new M.C&lt;int&gt;() // no error, resolves to C&lt;'T&gt;\n    let _ = M.C() // gives an error\n    let _ = M.C&lt;int&gt;() // no error, resolves to C&lt;'T&gt;\n    let _ = M.C&lt;int,int&gt;() // no error, resolves to C&lt;'T,'U&gt;\n    let _ = M.C&lt;_&gt;() // no error, resolves to C&lt;'T&gt;\n    let _ = M.C&lt;_,_&gt;() // no error, resolves to C&lt;'T,'U&gt;\n    let _ = M.C.P // gives an error\n    let _ = M.C&lt;_&gt;.P // no error, resolves to C&lt;'T&gt;\n    let _ = M.C&lt;_,_&gt;.P // no error, resolves to C&lt;'T,'U&gt;\n</code></pre> <p>The following example shows how the resolution behavior differs slightly if one of the types has no generic arguments.</p> <pre><code>module M =\n    type C() =\n        static member P = 1\n\n    type C&lt;'T&gt;() =\n        static member P = 1\n\n    let _ = new M.C()       // no error, resolves to C\n    let _ = new M.C&lt;int&gt;()  // no error, resolves to C&lt;'T&gt;\n    let _ = M.C()           // no error, resolves to C\n    let _ = M.C&lt; &gt;()        // no error, resolves to C\n    let _ = M.C&lt;int&gt;()      // no error, resolves to C&lt;'T&gt;\n    let _ = M.C&lt; &gt;()        // no error, resolves to C\n    let _ = M.C&lt;_&gt;()        // no error, resolves to C&lt;'T&gt;\n    let _ = M.C.P           // no error, resolves to C\nlet _ = M.C&lt; &gt;.P            // no error, resolves to C\n    let _ = M.C&lt;_&gt;.P        // no error, resolves to C&lt;'T&gt;\n</code></pre> <p>In the following example, the procedure issues a warning for an incomplete type. In this case, the type parameter <code>'T</code> cannot be inferred from the use <code>M.C.P</code>, because <code>'T</code> does not appear at all in the type of the resolved element <code>M.C&lt;'T&gt;.P</code>.</p> <pre><code>module M =\n    type C&lt;'T&gt;() =\n        static member P = 1\n\n    let _ = M.C.P // no error, resolves to C&lt;'T&gt;.P, warning given\n</code></pre> <p>The effect of these rules is to prefer value names over module names for single identifiers. For example, consider this case:</p> <pre><code>let Foo = 1\n\nmodule Foo =\n    let ABC = 2\nlet x1 = Foo // evaluates to 1\n</code></pre> <p>The rules, however, prefer type names over value names for single identifiers, because type names appear in the ExprItems table. For example, consider this case:</p> <pre><code>let Foo = 1\ntype Foo() =\n    static member ABC = 2\nlet x1 = Foo.ABC // evaluates to 2\nlet x2 = Foo() // evaluates to a new Foo()\n</code></pre>"},{"location":"inference-procedures/#1415-name-resolution-for-members","title":"14.1.5 Name Resolution for Members","text":"<p>Name Resolution for Members is a sub-procedure used to resolve <code>.member-ident[.rest]</code> to a member, in the context of a particular type <code>type</code>.</p> <p>Name Resolution for Members proceeds through the following steps:</p> <ol> <li> <p>Search the hierarchy of the type from <code>System.Object</code> to <code>type</code>.</p> </li> <li> <p>At each type, try to resolve <code>member-ident</code> to one of the following, in order:</p> <ul> <li>A union case of <code>type</code>.</li> <li>A property group of <code>type</code>.</li> <li>A method group of <code>type</code>.</li> <li>A field of <code>type</code>.</li> <li>An event of <code>type</code>.</li> <li>A property group of extension members of <code>type</code>, by consulting the ExtensionsInScope table.</li> <li>A method group of extension members of <code>type</code>, by consulting the ExtensionsInScope table.</li> <li>A nested type <code>type-nested</code> of <code>type</code>. Recursively resolve <code>.rest</code> if it is present, otherwise return <code>type-nested</code>.</li> </ul> </li> <li> <p>At any type, the existence of a property, event, field, or union case named <code>member-ident</code> causes     any methods or other entities of that same name from base types to be hidden.</p> </li> <li>Combine method groups with method groups from base types. For example:</li> </ol> <pre><code>type A() =\n    member this.Foo(i : int) = 0\n\ntype B() =\n    inherit A()\n    member this.Foo(s : string) = 1\n\nlet b = new B()\nb.Foo(1)        // resolves to method in A\nb.Foo(\"abc\")    // resolves to method in B\n</code></pre>"},{"location":"inference-procedures/#1416-name-resolution-in-patterns","title":"14.1.6 Name Resolution in Patterns","text":"<p>Name Resolution for Patterns is used to resolve <code>long-ident</code> in the context of pattern expressions. The <code>long-ident</code> must resolve to a union case, exception label, literal value, or active pattern case name. If it does not, the <code>long-ident</code> may represent a new variable definition in the pattern.</p> <p>Name Resolution for Patterns follows the same steps to resolve the <code>member-ident</code> as Name Resolution in Expressions (\u00a714.1.4) except that it consults the PatItems table instead of the ExprItems table. As a result, values are not present in the namespace that is used to resolve identifiers in patterns. For example:</p> <pre><code>let C = 3\nmatch 4 with\n| C -&gt; sprintf \"matched, C = %d\" C\n| _ -&gt; sprintf \"no match, C = %d\" C\n</code></pre> <p>results in <code>\"matched, C = 4\"</code>, because <code>C</code> is not present in the PatItems table, and hence becomes a value pattern. In contrast,</p> <pre><code>[&lt;Literal&gt;]\nlet C = 3\n\nmatch 4 with\n| C -&gt; sprintf \"matched, C = %d\" C\n| _ -&gt; sprintf \"no match, C = %d\" C\n</code></pre> <p>results in <code>\"no match, C = 3\"</code>, because <code>C</code> is a literal and therefore is present in the PatItems table.</p>"},{"location":"inference-procedures/#1417-name-resolution-for-types","title":"14.1.7 Name Resolution for Types","text":"<p>Name Resolution for Types is used to resolve <code>long-ident</code> in the context of a syntactic type. A generic arity that matches <code>n</code> is always available. The result is a type definition and a possible residue <code>rest</code>.</p> <p>Name Resolution for Types proceeds through the following steps:</p> <ol> <li>Given <code>ident[.rest]</code>, look up <code>ident</code> in the Types table, with generic arity <code>n</code>. Return the result and     residue <code>rest</code>.</li> <li> <p>If <code>ident</code> is not present in the Types table:</p> <ul> <li>Divide <code>long-ident</code> into <code>[namespace-or-module-path].ident[.rest]</code>, in which the <code>namespace- or-module-path</code> becomes successively longer.</li> <li>For each such division, consider each module and namespace declaration group <code>F</code> in the list that results from resolving <code>namespace-or-module-path</code> by using Name Resolution in Module and Namespace Paths (\u00a714.1.2).</li> <li>For each such <code>F</code> , attempt to resolve <code>ident[.rest]</code> in the following order. Terminate the search when the expression is successfully resolved.     1) A type in <code>F</code>. Return this type and residue <code>rest</code>.     2) A [sub-]module in <code>F</code>. Recursively resolve <code>rest</code> against the contents of this module.</li> </ul> </li> </ol> <p>In the following example, the name <code>C</code> on the last line resolves to the named type <code>M.C&lt;_,_&gt;</code> because <code>C</code> is applied to two type arguments:</p> <pre><code>module M =\n    type C&lt;'T, 'U&gt; = 'T * 'T * 'U\n\nmodule N =\n    type C&lt;'T&gt; = 'T * 'T\n\nopen M\nopen N\n\nlet x : C&lt;int, string&gt; = (1, 1, \"abc\")\n</code></pre>"},{"location":"inference-procedures/#1418-name-resolution-for-type-variables","title":"14.1.8 Name Resolution for Type Variables","text":"<p>Whenever the F# compiler processes syntactic types and expressions, it assumes a context that maps identifiers to inference type variables. This mapping ensures that multiple uses of the same type variable name map to the same type inference variable. For example, consider the following function:</p> <pre><code>let f x y = (x:'T), (y:'T)\n</code></pre> <p>In this case, the compiler assigns the identifiers <code>x</code> and <code>y</code> the same static type - that is, the same type inference variable is associated with the name <code>'T</code>. The full inferred type of the function is:</p> <pre><code>val f&lt;'T&gt; : 'T -&gt; 'T -&gt; 'T * 'T\n</code></pre> <p>The map is used throughout the processing of expressions and types in a left-to-right order. It is initially empty for any member or any other top-level construct that contains expressions and types. Entries are eliminated from the map after they are generalized. As a result, the following code checks correctly:</p> <pre><code>let f () =\n    let g1 (x:'T) = x\n    let g2 (y:'T) = (y:string)\n    g1 3, g1 \"3\", g2 \"4\"\n</code></pre> <p>The compiler generalizes <code>g1</code>, which is applied to both integer and string types. The type variable <code>'T</code> in <code>(y:'T)</code> on the third line refers to a different type inference variable, which is eventually constrained to be type <code>string</code>.</p>"},{"location":"inference-procedures/#1419-field-label-resolution","title":"14.1.9 Field Label Resolution","text":"<p>Field Label Resolution specifies how to resolve identifiers such as <code>field1</code> in <code>{field1 = expr; ... fieldN = expr}</code>.</p> <p>Field Label Resolution proceeds through the following steps:</p> <ol> <li>Look up all fields in all available types in the Types table and the FieldLabels table (\u00a78.4).</li> <li>Return the set of field declarations.</li> </ol>"},{"location":"inference-procedures/#142-resolving-application-expressions","title":"14.2 Resolving Application Expressions","text":"<p>Application expressions that use dot notation - such as <code>x.Y&lt;int&gt;.Z(g).H.I.j</code> - are resolved according to a set of rules that take into account the many possible shapes and forms of these expressions and the ambiguities that may occur during their resolution. This section specifies the exact algorithmic process that is used to resolve these expressions.</p> <p>Resolution of application expressions proceeds as follows:</p> <ol> <li>Repeatedly decompose the application expression into a leading expression <code>expr</code> and a list of     projections <code>projs</code>. Each projection has the following form:<ul> <li><code>.long-ident-or-op</code> is a dot lookup projection.</li> <li><code>expr</code> is an application projection.</li> <li><code>&lt;types&gt;</code> is a type application projection.</li> </ul> </li> </ol> <p>For example:     - <code>x.y.Z(g).H.I.j</code> decomposes into <code>x.y.Z</code> and projections <code>(g)</code>, <code>.H.I.j</code>.     - <code>x.M&lt;int&gt;(g)</code> decomposes into <code>x.M</code> and projections <code>&lt;int&gt;</code>, <code>(g)</code>.     - <code>f x</code> decomposes into <code>f</code> and projection <code>x</code>.</p> <pre><code>&gt; Note: In this specification we write sequences of projections by juxtaposition; for\nexample, `(expr).long-ident&lt;types&gt;(expr)`. We also write ( `.rest` + `projs` ) to refer to\nadding a residue long identifier to the front of a list of projections, which results in `projs`\nif `rest` is empty and `.rest projs` otherwise.\n</code></pre> <ol> <li>After decomposition:<ul> <li>If <code>expr</code> is a long identifier expression <code>long-ident</code>, apply Unqualified Lookup (\u00a714.2.1) on <code>long-ident</code> with projections <code>projs</code>.</li> <li>If <code>expr</code> is not such an expression, check the expression against an arbitrary initial type <code>ty</code>, to    generate an elaborated expression <code>expr</code>. Then process <code>expr</code>, <code>ty</code>, and <code>projs</code> by using    Expression-Qualified Lookup (\u00a714.2.3)</li> </ul> </li> </ol>"},{"location":"inference-procedures/#1421-unqualified-lookup","title":"14.2.1 Unqualified Lookup","text":"<p>Given an input <code>long-ident</code> and projections <code>projs</code>, Unqualified Lookup computes the result of \u201clooking up\u201d <code>long-ident.projs</code> in an environment <code>env</code>. The first part of this process resolves a prefix of the information in <code>long-ident.projs</code>, and recursive resolutions typically use Expression-Qualified Resolution to resolve the remainder.</p> <p>For example, Unqualified Lookup is used to resolve the vast majority of identifier references in F# code, from simple identifiers such as <code>sin</code>, to complex accesses such as <code>System.Environment.GetCommandLineArgs().Length</code>.</p> <p>Unqualified Lookup proceeds through the following steps:</p> <ol> <li>Resolve <code>long-ident</code> by using Name Resolution in Expressions (\u00a714.1). This returns a name resolution item <code>item</code> and a residue long identifier <code>rest</code>.</li> </ol> <p>For example, the result of Name Resolution in Expressions for <code>v.X.Y</code> may be a value reference <code>v</code> along with a residue long identifier <code>X.Y</code>. Likewise, <code>N.X(args).Y</code> may resolve to an overloaded method <code>N.X</code> and a residue long identifier <code>Y</code>.</p> <p>Name Resolution in Expressions also takes as input the presence and count of subsequent type arguments in the first projection. If the first projection in <code>projs</code> is <code>&lt;tyargs&gt;</code>, Unqualified Lookup invokes Name Resolution in Expressions with a known number of type arguments. Otherwise, it is invoked with an unknown number of type arguments.</p> <ol> <li>Apply Item-Qualified Lookup for <code>item</code> and (<code>rest</code> + <code>projs</code>).</li> </ol>"},{"location":"inference-procedures/#1422-item-qualified-lookup","title":"14.2.2 Item-Qualified Lookup","text":"<p>Given an input item <code>item</code> and projections <code>projs</code>, Item-Qualified Lookup computes the projection <code>item.projs</code>. This computation is often a recursive process: the first resolution uses a prefix of the information in <code>item.projs</code>, and recursive resolutions resolve any remaining projections.</p> <p>Item-Qualified Lookup proceeds as follows:</p> <ol> <li>If <code>item</code> is not one of the following, return an error:<ul> <li>A named value</li> <li>A unique type</li> <li>A union case</li> <li>A group of named types</li> <li>A group of methods</li> <li>A group of indexer getter properties</li> <li>A single non-indexer getter property</li> <li>A static F# field</li> <li>A static CLI field</li> <li>An implicitly resolved symbolic operator name</li> </ul> </li> <li>If the first projection is <code>&lt;types&gt;</code>, then we say the resolution has a type application <code>&lt;types&gt;</code> with     remaining projections.</li> <li> <p>Otherwise, checking proceeds as follows.</p> <ul> <li> <p>If <code>item</code> is a value reference <code>v</code> then first Instantiate the type scheme of <code>v</code>, which results in a type <code>ty</code>. Apply these rules:</p> <ul> <li>If the first projection is <code>&lt;types&gt;</code>, process the types and use the results as the arguments to instantiate the type scheme.</li> <li>If the first projection is not <code>&lt;types&gt;</code>, the type scheme is freshly instantiated.</li> <li>If the value has the <code>RequiresExplicitTypeArguments</code> attribute, the first projection must be <code>&lt;types&gt;</code>.</li> <li>If the value has type <code>byref&lt;ty2&gt;</code>, add a byref dereference to the elaborated expression.</li> <li>Insert implicit flexibility for the use of the value (\u00a714.4.3).</li> </ul> <p>Then Apply Expression-Qualified Lookup for type <code>ty</code> and any remaining projections.</p> </li> <li> <p>If <code>item</code> is a type name, where <code>projs</code> begins with <code>&lt;types&gt;.long-ident</code></p> <ul> <li>Process the types and use the results as the arguments to instantiate the named type reference, thus generating a type <code>ty</code>.</li> <li>Apply Name Resolution for Members to <code>ty</code> and <code>long-ident</code>, which generates a new <code>item</code>.</li> <li>Apply Item-Qualified Lookup to the new <code>item</code> and any remaining projections.</li> </ul> </li> <li> <p>If <code>item</code> is a group of type names where <code>projs</code> begins with <code>&lt;types&gt;</code> or <code>expr</code> or <code>projs</code> is empty</p> <ul> <li>Process the types and use the results as the arguments to instantiate the named type reference, thus generating a type <code>ty</code>.</li> <li>Process the object construction <code>ty(expr)</code> as an object constructor call in the same way as <code>new ty(expr)</code>. If <code>projs</code> is empty then process the object construction <code>ty</code> as an object constructor call in the same way as <code>(fun arg -&gt; new ty(arg))</code>, i.e. resolve the object constructor call with no arguments.</li> <li>Apply Expression-Qualified Lookup to <code>item</code> and any remaining projections.</li> </ul> </li> <li> <p>If <code>item</code> is a group of method references</p> <ul> <li>Apply Method Application Resolution for the method group. Method Application Resolution   accepts an optional set of type arguments and a syntactic expression     argument. Determine the arguments based on what <code>projs</code> begins with:<ul> <li><code>&lt;types&gt; expr</code>, then use <code>&lt;types&gt;</code> as the type arguments and <code>expr</code> as the    expression argument.</li> <li><code>expr</code>, then use <code>expr</code> as the expression argument.</li> <li>anything else, use no expression argument or type arguments.</li> </ul> </li> <li>If the result of Method Application Resolution is labeled with the     <code>RequiresExplicitTypeArguments</code> attribute, then explicit type arguments are     required.</li> <li>Let <code>fty</code> be the actual return type that results from Method Application Resolution.     Apply Expression-Qualified Lookup to <code>fty</code> and any remaining projections.</li> </ul> </li> <li> <p>If <code>item</code> is a group of property indexer references</p> <ul> <li>Apply Method Application Resolution, and use the underlying getter indexer methods for the method group.</li> <li>Determine the arguments to Method Application Resolution as described for a group of methods.</li> </ul> </li> <li> <p>If <code>item</code> is a static field reference</p> <ul> <li>Check the field for accessibility and attributes.</li> <li>Let <code>fty</code> be the actual type of the field, taking into account the type <code>ty</code> via which the   field was accessed in the case where this is a field in a generic type.</li> <li>Apply Expression-Qualified Lookup to <code>fty</code> and <code>projs</code>.</li> </ul> </li> <li> <p>If <code>item</code> is a union case tag, exception tag, or active pattern result element tag</p> <ul> <li>Check the tag for accessibility and attributes.</li> <li>If <code>projs</code> begins with <code>expr</code>, use <code>expr</code> as the expression argument.</li> <li>Otherwise, use no expression argument or type arguments. In this case, build a   function expression for the union case.</li> <li>Let <code>fty</code> be the actual type of the union case.</li> <li>Apply Expression-Qualified Lookup to <code>fty</code> and remaining <code>projs</code>.</li> </ul> </li> <li> <p>If <code>item</code> is a unique type name <code>C</code> where <code>projs</code> is empty</p> <ul> <li>Check the type for accessibility and attributes.</li> <li>Process the types using a new instantiation for <code>C</code>, thus generating a type <code>ty</code>, and process the object construction <code>fun v -&gt; new ty(v)</code> as an object constructor call.</li> </ul> </li> <li> <p>If <code>item</code> is a CLI event reference</p> <ul> <li>Check the event for accessibility and attributes.</li> <li>Let <code>fty</code> be the actual type of the event.</li> <li>Apply Expression-Qualified Lookup to <code>fty</code> and <code>projs</code>.</li> </ul> </li> <li> <p>If <code>item</code> is an implicitly resolved symbolic operator name <code>op</code></p> <ul> <li> <p>If <code>op</code> is a unary, binary or the ternary operator ?&lt;-, resolve to the following expressions, respectively:</p> <pre><code>(fun (x:^a) -&gt; (^a : static member (op) : ^a -&gt; ^b) x)\n(fun (x:^a) (y:^b) -&gt;\n    ((^a or ^b) : static member (op) : ^a * ^b -&gt; ^c) (x,y))\n(fun (x:^a) (y:^b) (z:^c)\n    -&gt; ((^a or ^b or ^c) : static member (op) : ^a * ^b * ^c -&gt; ^d) (x,y,z))\n</code></pre> </li> <li> <p>The resulting expressions are static member constraint invocation expressions (\u00a76.4.8), which enable the default interpretation of operators by using type-directed member resolution.</p> </li> <li>Recheck the entire expression with additional subsequent projections <code>.projs</code>.</li> </ul> </li> </ul> </li> </ol>"},{"location":"inference-procedures/#1423-expression-qualified-lookup","title":"14.2.3 Expression-Qualified Lookup","text":"<p>Given an elaborated expression <code>expr</code> of type <code>ty</code>, and projections <code>projs</code>, Expression-Qualified Lookup computes the \u201clookups or applications\u201d for <code>expr.projs</code>.</p> <p>Expression-Qualified Lookup proceeds through the following steps:</p> <ol> <li> <p>Inspect <code>projs</code> and process according to the following table.</p> <code>projs</code> Action Comments Empty Assert that the type of the overall, original application expression is <code>ty</code>. Checking is complete. Starts with <code>(expr2)</code> Apply Function Application Resolution (\u00a714.3). Checking is complete when Function Application Resolution returns. Starts with <code>&lt;types&gt;</code> Fail. Type instantiations may not be applied to arbitrary expressions; they can apply only to generic types, generic methods, and generic values. Starts with <code>.long-ident</code> Resolve <code>long-ident</code> using Name Resolution for Members (\u00a714.1.4)_. Return a name resolution item <code>item</code> and a residue long identifier <code>rest</code>. Continue processing at step 2. For example, for <code>ty = string</code> and <code>long-ident = Length</code>, Name Resolution for Members returns a property reference to the CLI instance property <code>System.String.Length</code>. </li> <li> <p>If Step 1 returned an <code>item</code> and <code>rest</code>, report an error if <code>item</code> is not one of the following:</p> <ul> <li>A group of methods.</li> <li>A group of instance getter property indexers.</li> <li>A single instance, non-indexer getter property.</li> <li>A single instance F# field.</li> <li>A single instance CLI field.</li> </ul> </li> <li> <p>Proceed based on <code>item</code> as follows:</p> <ul> <li> <p>If <code>item</code> is a group of methods</p> <ul> <li> <p>Apply Method Application Resolution for the method group. Method Application Resolution accepts an optional set of type arguments and a syntactic expression argument. If <code>projs</code> begins with:</p> <ul> <li><code>&lt;types&gt;(arg)</code>, then use <code>&lt;types&gt;</code> as the type arguments and <code>arg</code> as the expression argument.</li> <li><code>(arg)</code>, then use <code>arg</code> as the expression argument.</li> <li>otherwise, use no expression argument or type arguments.</li> </ul> </li> <li> <p>Let <code>fty</code> be the actual return type resulting from Method Application Resolution. Apply Expression-Qualified Lookup to <code>fty</code> and any remaining projections.</p> </li> </ul> </li> <li> <p>If <code>item</code> is a group of indexer properties</p> <ul> <li>Apply Method Application Resolution and use the underlying getter indexer methods for the method group.</li> <li>Determine the arguments to Method Application Resolution as described for a group of methods.</li> </ul> </li> <li> <p>If <code>item</code> is a non-indexer getter property</p> <ul> <li>Apply Method Application Resolution for the method group that contains     only the getter method for the property, with no type arguments and one <code>()</code> argument.</li> </ul> </li> <li> <p>If <code>item</code> is an instance intermediate language (IL) or F# field <code>F</code></p> <ul> <li>Check the field for accessibility and attributes.</li> <li>Let <code>fty</code> be the actual type of the field (taking into account the type <code>ty</code>   by which the field was accessed).</li> <li>Assert that <code>ty</code> is a subtype of the actual containing type of the field.</li> <li>Produce an elaborated form for <code>expr.F</code>. If <code>F</code> is a field in a value type   then take the address of <code>expr</code> by using the AddressOf(<code>expr, NeverMutates</code>) operation \u00a76.9.4.</li> <li>Apply Expression-Qualified Lookup to <code>fty</code> and <code>projs</code>.</li> </ul> </li> </ul> </li> </ol>"},{"location":"inference-procedures/#143-function-application-resolution","title":"14.3 Function Application Resolution","text":"<p>Given expressions <code>f</code> and <code>expr</code> where <code>f</code> has type <code>ty</code>, and given subsequent projections <code>projs</code>, Function Application Resolution does the following:</p> <ol> <li>Asserts that <code>f</code> has type <code>ty1 -&gt; ty2</code> for new inference variables <code>ty1</code> and <code>ty2</code>.</li> <li> <p>If the assertion succeeds:</p> <ul> <li>Check <code>expr</code> with the initial type <code>ty1</code>.</li> <li>Process <code>projs</code> using Expression-Qualified Lookup against <code>ty2</code>.</li> <li> <p>If the assertion fails, and <code>expr</code> has the form <code>{ computation-expr }</code>:</p> </li> <li> <p>Check the expression as the computation expression form <code>f { computation-expr }</code>, giving result type <code>ty1</code>.</p> </li> <li>Process <code>projs</code> using Expression-Qualified Lookup against <code>ty1</code>.</li> </ul> </li> </ol>"},{"location":"inference-procedures/#144-method-application-resolution","title":"14.4 Method Application Resolution","text":"<p>Given a method group <code>M</code>, optional type arguments <code>&lt;ActualTypeArgs&gt;</code>, an optional syntactic argument <code>obj</code>, an optional syntactic argument <code>arg</code>, and overall initial type <code>ty</code>, Method Application Resolution resolves the overloading based on the partial type information that is available. It also:</p> <ul> <li>Resolves optional and named arguments.</li> <li>Resolves \u201cout\u201d arguments.</li> <li>Resolves post-hoc property assignments.</li> <li>Applies method application resolution.</li> <li>Inserts ad hoc conversions that are only applied for method calls.</li> </ul> <p>If no syntactic argument is supplied, Method Application Resolution tries to resolve the use of the method as a first class value, such as the method call in the following example:</p> <pre><code>List.map System.Environment.GetEnvironmentVariable [\"PATH\"; \"USERNAME\"]\n</code></pre> <p>Method Application Resolution proceeds through the following steps:</p> <ol> <li>Restrict the candidate method group <code>M</code> to those methods that are accessible from the point of     resolution.</li> <li> <p>If an argument <code>arg</code> is present, determine the sets of unnamed and named actual arguments,     <code>UnnamedActualArgs</code> and <code>NamedActualArgs</code>:</p> <ul> <li> <p>Decompose <code>arg</code> into a list of arguments:</p> <ul> <li>If <code>arg</code> is a syntactic tuple <code>arg1, ..., argN</code>, use these arguments.</li> <li>If <code>arg</code> is a syntactic unit value <code>()</code>, use a zero-length list of arguments.</li> </ul> </li> <li> <p>For each argument:</p> <ul> <li>If <code>arg</code> is a binary expression of the form <code>name=expr</code>, it is a named actual argument.</li> <li>Otherwise, <code>arg</code> is an unnamed actual argument.</li> </ul> </li> </ul> <p>If there are no named actual arguments, and <code>M</code> has only one candidate method, which accepts only one required argument, ignore the decomposition of <code>arg</code> to tuple form. Instead, <code>arg</code> itself is the only named actual argument.</p> <p>All named arguments must appear after all unnamed arguments.</p> <p>Examples: - <code>x.M(1, 2)</code> has two unnamed actual arguments. - <code>x.M(1, y = 2)</code> has one unnamed actual argument and one named actual argument. - <code>x.M(1, (y = 2))</code> has two unnamed actual arguments. - <code>x.M( printfn \"hello\"; ())</code> has one unnamed actual argument. - <code>x.M((a, b))</code> has one unnamed actual argument. - <code>x.M(())</code> has one unnamed actual argument.</p> </li> <li> <p>Determine the named and unnamed prospective actual argument types, called <code>ActualArgTypes</code>.</p> <ul> <li>If an argument <code>arg</code> is present, the prospective actual argument types are fresh type    inference variables for each unnamed and named actual argument.</li> <li>If the argument has the syntactic form of an address-of expression <code>&amp;expr</code> after ignoring       parentheses around the argument, equate this type with a type <code>byref&lt;ty&gt;</code> for a fresh       type <code>ty</code>.</li> <li>If the argument has the syntactic form of a function expression <code>fun pat1 ... patn -&gt; expr</code>       after ignoring parentheses around the argument, equate this type with a       type <code>ty1 -&gt; ... tyn -&gt; rty</code> for fresh types <code>ty1 ... tyn</code>.</li> <li> <p>If no argument <code>arg</code> is present:</p> <ul> <li>If the method group contains a single method, the prospective unnamed argument types are one fresh type inference variable for each required, non-\u201cout\u201d parameter that the method accepts.</li> <li> <p>If the method group contains more than one method, the expected overall type of the expression is asserted to be a function type <code>dty -&gt; rty</code>.</p> <ul> <li> <p>If <code>dty</code> is a tuple type <code>(dty1 * ... * dtyN)</code>, the prospective argument types are <code>(dty1, ..., dtyN)</code>.</p> </li> <li> <p>If <code>dty</code> is <code>unit</code>, then the prospective argument types are an empty list.</p> </li> <li> <p>If <code>dty</code> is any other type, the prospective argument types are <code>dty</code> alone.</p> </li> </ul> </li> <li> <p>Subsequently:</p> <ul> <li> <p>The method application is considered to have one unnamed actual argument for each prospective unnamed actual argument type.</p> </li> <li> <p>The method application is considered to have no named actual arguments.</p> </li> </ul> </li> </ul> </li> </ul> </li> <li> <p>For each candidate method in <code>M</code>, attempt to produce zero, one, or two prospective method calls <code>M~possible</code> as follows:</p> <ul> <li>If the candidate method is generic and has been generalized, generate fresh type inference variables for its generic parameters. This results in the <code>FormalTypeArgs</code> for <code>M~possible</code>.</li> <li>Determine the named and unnamed formal parameters , called <code>NamedFormalArgs</code> and <code>UnnamedFormalArgs</code> respectively, by splitting the formal parameters for <code>M</code> into parameters that have a matching argument in <code>NamedActualArgs</code> and parameters that do not.</li> <li> <p>If the number of <code>UnnamedFormalArgs</code> exceeds the number of <code>UnnamedActualArgs</code>, then modify <code>UnnamedFormalArgs</code> as follows:</p> <ul> <li>Determine the suffix of <code>UnnamedFormalArgs</code> beyond the number of <code>UnnamedActualArgs</code>.</li> <li>If all formal parameters in the suffix are <code>out</code> arguments with <code>byref</code> type, remove the     suffix from <code>UnnamedFormalArgs</code> and call it <code>ImplicitlyReturnedFormalArgs</code>.</li> <li>If all formal parameters in the suffix are optional arguments, remove the suffix from     <code>UnnamedFormalArgs</code> and call it <code>ImplicitlySuppliedFormalArgs</code>.</li> </ul> </li> <li> <p>If the last element of <code>UnnamedFormalArgs</code> has the <code>ParamArray</code> attribute and type <code>pty[]</code> for some <code>pty</code>, then modify <code>UnnamedActualArgs</code> as follows:</p> <ul> <li>If the number of <code>UnnamedActualArgs</code> exceeds the number of <code>UnnamedFormalArgs - 1</code>,     produce a prospective method call named <code>ParamArrayActualArgs</code> that has the excess of     <code>UnnamedActualArgs</code> removed.</li> <li> <p>If the number of <code>UnnamedActualArgs</code> equals the number of <code>UnnamedFormalArgs - 1</code>, produce     two prospective method calls:</p> <ul> <li>One has an empty <code>ParamArrayActualArgs</code>.</li> <li>One has no <code>ParamArrayActualArgs</code>.</li> </ul> </li> <li> <p>If <code>ParamArrayActualArgs</code> has been produced, then <code>M~possible</code> is said to use ParamArray conversion with type <code>pty</code>.</p> </li> </ul> </li> <li> <p>Associate each <code>name = arg</code> in <code>NamedActualArgs</code> with a target. A target is a named formal   parameter, a settable return property, or a settable return field as follows:</p> <ul> <li>If one of the arguments in <code>NamedFormalArgs</code> has name <code>name</code>, that argument is the target.</li> <li>If the return type of <code>M</code>, before the application of any type arguments <code>ActualTypeArgs</code>,     contains a settable property <code>name</code>, then <code>name</code> is the target. The available properties     include any property extension members of type, found by consulting the     ExtensionsInScope table.</li> <li>If the return type of <code>M</code>, before the application of any type arguments <code>ActualTypeArgs</code>,     contains a settable field <code>name</code>, then <code>name</code> is the target.</li> </ul> </li> <li> <p>No prospective method call is generated if any of the following are true:</p> <ul> <li>A named argument cannot be associated with a target.</li> <li>The number of <code>UnnamedActualArgs</code> is less than the number of <code>UnnamedFormalArgs</code> after     steps 4 a-e.</li> <li>The number of <code>ActualTypeArgs</code>, if any actual type arguments are present, does not     precisely equal the number of <code>FormalTypeArgs</code> for <code>M</code>.</li> <li>The candidate method is static and the optional syntactic argument <code>obj</code> is present, or     the candidate method is an instance method and <code>obj</code> is not present.</li> </ul> </li> </ul> </li> <li> <p>Attempt to apply initial types before argument checking. If only one prospective method call <code>M~possible</code> exists, assert <code>M~possible</code> by performing the following steps:</p> <ul> <li>Verify that each <code>ActualTypeArgi</code> is equal to its corresponding <code>FormalTypeArgi</code>.</li> <li>Verify that the type of <code>obj</code> is a subtype of the containing type of the method <code>M</code>.</li> <li>For each <code>UnnamedActualArgi</code> and <code>UnnamedFormalArgi</code>, verify that the corresponding <code>ActualArgType</code> coerces to the type of the corresponding argument of <code>M</code>.</li> <li>If <code>M~possible</code> uses ParamArray conversion with type <code>pty</code>, then for each <code>ParamArrayActualArgi</code>, verify that the corresponding <code>ActualArgType</code> coerces to <code>pty</code>.</li> <li>For each <code>NamedActualArgi</code> that has an associated formal parameter target, verify that the corresponding <code>ActualArgType</code> coerces to the type of the corresponding argument of <code>M</code>.</li> <li>For each <code>NamedActualArgi</code> that has an associated property or field setter target, verify that the corresponding <code>ActualArgType</code> coerces to the type of the property or field.</li> <li> <p>Verify that the prospective formal return type coerces to the expected actual return type. If the method <code>M</code> has return type <code>rty</code>, the formal return type is defined as follows:</p> <ul> <li>If the prospective method call contains <code>ImplicitlyReturnedFormalArgs</code> with type <code>ty1, ..., tyN</code>,   the formal return type is <code>rty * ty1 * ... * tyN</code>. If <code>rty</code> is <code>unit</code> then the formal     return type is <code>ty1 * ... * tyN</code>.</li> <li>Otherwise the formal return type is <code>rty</code>.</li> </ul> </li> </ul> </li> <li> <p>Check and elaborate argument expressions. If <code>arg</code> is present:</p> <ul> <li>Check and elaborate each unnamed actual argument expression <code>argi</code>. Use the corresponding type in <code>ActualArgTypes</code> as the initial type.</li> <li>Check and elaborate each named actual argument expression <code>argi</code>. Use the corresponding type in <code>ActualArgTypes</code> as the initial type.</li> </ul> </li> <li> <p>Choose a unique <code>M~possible</code> according to the following rules:</p> <ul> <li>For each <code>M~possible</code>, determine whether the method is applicable by attempting to assert <code>M~possible</code> as described in step 4a). If the actions in step 4a detect an inconsistent constraint set (\u00a714.5), the method is not applicable. Regardless, the overall constraint set is left unchanged as a result of determining the applicability of each <code>M~possible</code>.</li> <li> <p>If a unique applicable <code>M~possible</code> exists, choose that method. Otherwise, choose the unique best <code>M~possible</code> by applying the following criteria, in order:     1) Prefer candidates whose use does not constrain the use of a user-introduced generic     type annotation to be equal to another type.     2) Prefer candidates that do not use ParamArray conversion. If two candidates both use     ParamArray conversion with types <code>pty1</code> and <code>pty2</code>, and <code>pty1</code> feasibly subsumes <code>pty2</code>, prefer     the second; that is, use the candidate that has the more precise type.     3) Prefer candidates that do not have <code>ImplicitlyReturnedFormalArgs</code>.     4) Prefer candidates that do not have <code>ImplicitlySuppliedFormalArgs</code>.     5) If two candidates have unnamed actual argument types <code>ty11 ... ty1n</code> and <code>ty21 ... ty2n</code>, and        each <code>ty1i</code> either         - feasibly subsumes <code>ty2i</code>, or         - <code>ty2i</code> is a <code>System.Func</code> type and <code>ty1i</code> is some other delegate type,</p> <p>then prefer the second candidate. That is, prefer any candidate that has the more    specific actual argument types, and consider any <code>System.Func</code> type to be more specific    than any other delegate type. 6) Prefer candidates that are not extension members over candidates that are. 7) To choose between two extension members, prefer the one that results from the most recent use of open. 8) Prefer candidates that are not generic over candidates that are generic - that is, prefer candidates that have empty <code>ActualArgTypes</code>.</p> </li> </ul> <p>Report an error if steps 1) through 8) do not result in the selection of a unique better method.</p> </li> <li> <p>Once a unique best <code>M~possible</code> is chosen, commit that method.</p> </li> <li>Apply attribute checks.</li> <li> <p>Build the resulting elaborated expression by following these steps:</p> <ul> <li>If the type of <code>obj</code> is a variable type or a value type, take the address of <code>obj</code> by using the AddressOf<code>(obj , PossiblyMutates)</code> operation (\u00a76.9.4).</li> <li> <p>Build the argument list by:</p> <ul> <li>Passing each argument corresponding to an <code>UnamedFormalArgs</code> where the argument is an     optional argument as a <code>Some</code> value.</li> <li>Passing a <code>None</code> value for each argument that corresponds to an <code>ImplicitlySuppliedFormalArgs</code>.</li> <li>Applying coercion to arguments.</li> </ul> </li> <li> <p>Bind <code>ImplicitlyReturnedFormalArgs</code> arguments by introducing mutable temporaries for each argument, passing them as <code>byref</code> parameters, and building a tuple from these mutable temporaries and any method return value as the overall result.</p> </li> <li>For each <code>NamedActualArgs</code> whose target is a settable property or field, assign the value into the property.</li> <li>If <code>arg</code> is not present, return a function expression that represents a first class function value.</li> </ul> </li> </ol> <p>Two additional rules apply when checking arguments (see \u00a78.13.7 for examples):</p> <ul> <li> <p>If a formal parameter has delegate type <code>D</code>, an actual argument <code>farg</code> has known type       <code>ty1 -&gt; ... -&gt; tyn -&gt; rty</code>, and the number of arguments of the Invoke method of delegate type       <code>D</code> is precisely <code>n</code>, interpret the formal parameter in the same way as the following:          <code>new D (fun arg1 ... argn -&gt; farg arg1 ... argn)</code>.</p> <p>For more information on the conversions that are automatically applied to arguments, see   \u00a78.13.6.</p> </li> <li> <p>If a formal parameter is an <code>out</code> parameter of type <code>byref&lt;ty&gt;</code>, and an actual argument type is       not a byref type, interpret the actual parameter in the same way as type <code>ref&lt;ty&gt;</code>. That is, an F#       reference cell can be passed where a <code>byref&lt;ty&gt;</code> is expected.</p> </li> </ul> <p>One effect of these additional rules is that a method that is used as a first class function value can resolve even if a method is overloaded and no further information is available. For example:</p> <pre><code>let r = new Random()\nlet roll = r.Next;;\n</code></pre> <p>Method Application Resolution results in the following, despite the fact that in the standard CLI library, <code>System.Random.Next</code> is overloaded:</p> <pre><code>val roll : int -&gt; int\n</code></pre> <p>The reason is that if the initial type contains no information about the expected number of arguments, the F# compiler assumes that the method has one argument.</p>"},{"location":"inference-procedures/#1441-additional-propagation-of-known-type-information-in-f-31","title":"14.4.1 Additional Propagation of Known Type Information in F# 3.1","text":"<p>In the above descreiption of F# overload resolution, the argument expressions of a call to an overloaded set of methods</p> <pre><code>callerObjArgTy.Method(callerArgExpr1 , ... callerArgExprN)\n</code></pre> <p>calling</p> <pre><code>calledObjArgTy.Method(calledArgTy1, ... calledArgTyN)\n</code></pre> <p>In F# 3.1 and subsequently, immediately prior to checking argument expressions, each argument position of the unnamed caller arguments for the method call is analysed to propagate type information extracted from method overloads to the expected types of lambda expressions. The new rule is applied when</p> <ul> <li>the candidates are overloaded</li> <li>the caller argument at the given unnamed argument position is a syntactic lambda, possible     parenthesized</li> <li> <p>all the corresponding formal called arguments have <code>calledArgTy</code> either of</p> </li> <li> <p>function type <code>calledArgDomainTy1 -&gt; ... -&gt; calledArgDomainTyN -&gt; calledArgRangeTy</code>         (after taking into account \u201cfunction to delegate\u201d adjustments), or</p> </li> <li> <p>some other type which would cause an overload to be discarded</p> </li> <li> <p>at least one overload has enough curried lambda arguments for it corresponding expected     function type</p> </li> </ul> <p>In this case, for each unnamed argument position, then for each overload:</p> <ul> <li>Attempt to solve <code>callerObjArgTy = calledObjArgTy</code> for the overload, if the overload is for an     instance member. When making this application, only solve type inference variables present in     the <code>calledObjArgTy</code>. If any of these conversions fail, then skip the overload for the purposes of     this rule</li> <li>Attempt to solve <code>callerArgTy = (calledArgDomainTy1_ -&gt; ... -&gt; calledArgDomainTyN_ -&gt; ?)</code>. If     this fails, then skip the overload for the purposes of this rule</li> </ul>"},{"location":"inference-procedures/#1442-conditional-compilation-of-member-calls","title":"14.4.2 Conditional Compilation of Member Calls","text":"<p>If a member definition has the <code>System.Diagnostics.Conditional</code> attribute, then any application of the member is adjusted as follows:</p> <ul> <li>The <code>Conditional(\"symbol\")</code> attribute may apply to methods only.</li> <li>Methods that have the <code>Conditional</code> attribute must have return type <code>unit</code>. The return type may     be checked either on use of the method or definition of the method.</li> <li>If <code>symbol</code> is not in the current set of conditional compilation symbols, the compiler eliminates     application expressions that resolve to calls to members that have the <code>Conditional</code> attribute and     ensures that arguments are not evaluated. Elimination of such expressions proceeds first with     static members and then with instance members, as follows:</li> <li>Static members: <code>Type.M(args)</code> =&gt; <code>()</code></li> <li>Instance members: <code>expr.M(args)</code> =&gt; <code>()</code></li> </ul>"},{"location":"inference-procedures/#1443-implicit-insertion-of-flexibility-for-uses-of-functions-and-members","title":"14.4.3 Implicit Insertion of Flexibility for Uses of Functions and Members","text":"<p>At each use of a data constructor, named function, or member that forms an expression, flexibility is implicitly added to the expression. This flexibility is associated with the use of the function or member, according to the inferred type of the expression. The added flexibility allows the item to accept arguments that are statically known to be subtypes of argument types to a function without requiring explicit upcasts</p> <p>The flexibility is added by adjusting each expression <code>expr</code> which represents a use of a function or member as follows:</p> <ul> <li> <p>The type of the function or member is decomposed to the following form:</p> <pre><code>ty11 * ... * ty1n -&gt; ... -&gt; tym1 * ... * tymn -&gt; rty\n</code></pre> </li> <li> <p>If the type does not decompose to this form, no flexibility is added.</p> </li> <li>The positions <code>tyij</code> are called the \u201cparameter positions\u201d for the type. For each parameter position     where <code>tyij</code> is not a sealed type, and is not a variable type, the type is replaced by a fresh type     variable <code>ty'ij</code> with a coercion constraint <code>ty'ij :&gt; tyij</code>.</li> <li> <p>After the addition of flexibility, the expression elaborates to an expression of type</p> <pre><code>ty'11 * ... * ty'1n -&gt; ... -&gt; ty'm1 * ... * ty'mn -&gt; rty\n</code></pre> <p>but otherwise is semantically equivalent to <code>expr</code> by creating an anonymous function expression and inserting appropariate coercions on arguments where necessary.</p> </li> </ul> <p>This means that F# functions whose inferred type includes an unsealed type in argument position may be passed subtypes when called, without the need for explicit upcasts. For example:</p> <pre><code>type Base() =\n    member b.X = 1\n\ntype Derived(i : int) =\n    inherit Base()\n    member d.Y = i\n\nlet d = new Derived(7)\n\nlet f (b : Base) = b.X\n\n// Call f: Base -&gt; int with an instance of type Derived\nlet res = f d\n\n// Use f as a first-class function value of type : Derived -&gt; int\nlet res2 = (f : Derived -&gt; int)\n</code></pre> <p>The F# compiler determines whether to insert flexibility after explicit instantiation, but before any arguments are checked. For example, given the following:</p> <pre><code>let M&lt;'b&gt;(c :'b, d :'b) = 1\nlet obj = new obj()\nlet str = \"\"\n</code></pre> <p>these expressions pass type-checking:</p> <pre><code>M&lt;obj&gt;(obj, str)\nM&lt;obj&gt;(str, obj)\nM&lt;obj&gt;(obj, obj)\nM&lt;obj&gt;(str, str)\nM(obj, obj)\nM(str, str)\n</code></pre> <p>These expressions do not, because the target type is a variable type:</p> <pre><code>M(obj, str)\nM(str, obj)\n</code></pre>"},{"location":"inference-procedures/#145-constraint-solving","title":"14.5 Constraint Solving","text":"<p>Constraint solving involves processing (\u201csolving\u201d) non-primitive constraints to reduce them to primitive, normalized constraints on type variables. The F# compiler invokes constraint solving every time it adds a constraint to the set of current inference constraints at any point during type checking.</p> <p>Given a type inference environment, the normalized form of constraints is a list of the following primitive constraints where <code>typar</code> is a type inference variable:</p> <pre><code>typar :&gt; type\ntypar : null\n( type or ... or type ) : ( member-sig )\ntypar : (new : unit -&gt; 'T)\ntypar : struct\ntypar : unmanaged\ntypar : comparison\ntypar : equality\ntypar : not struct\ntypar : enum&lt; type &gt;\ntypar : delegate&lt; type, type &gt;\n</code></pre> <p>Each newly introduced constraint is solved as described in the following sections.</p>"},{"location":"inference-procedures/#1451-solving-equational-constraints","title":"14.5.1 Solving Equational Constraints","text":"<p>New equational constraints in the form <code>typar = type</code> or <code>type = typar</code> , where <code>typar</code> is a type inference variable, cause <code>type</code> to replace <code>typar</code> in the constraint problem; <code>typar</code> is eliminated. Other constraints that are associated with <code>typar</code> are then no longer primitive and are solved again.</p> <p>New equational constraints of the form <code>type&lt;tyarg11,..., tyarg1n&gt; = type&lt;tyarg21, ..., tyarg2n&gt;</code> are reduced to a series of constraints <code>tyarg1i = tyarg2i</code> on identical named types and solved again.</p>"},{"location":"inference-procedures/#1452-solving-subtype-constraints","title":"14.5.2 Solving Subtype Constraints","text":"<p>Primitive constraints in the form <code>typar :&gt; obj</code> are discarded.</p> <p>New constraints in the form <code>type1 :&gt; type2</code>, where <code>type2</code> is a sealed type, are reduced to the constraint <code>type1</code> = <code>type2</code> and solved again.</p> <p>New constraints in either of these two forms are reduced to the constraints <code>tyarg11 = tyarg 21 ... tyarg1n = tyarg2n</code> and solved again:</p> <pre><code>type&lt;tyarg11, ..., tyarg1n&gt; :&gt; type&lt;tyarg21, ..., tyarg2n&gt;\ntype&lt;tyarg11, ..., tyarg1n&gt; = type&lt;tyarg21, ..., tyarg2n&gt;\n</code></pre> <p>Note: F# generic types do not support covariance or contravariance. That is, although single-dimensional array types in the CLI are effectively covariant, F# treats these types as invariant during constraint solving. Likewise, F# considers CLI delegate types as invariant and ignores any CLI variance type annotations on generic interface types and generic delegate types.</p> <p>New constraints of the form <code>type1&lt;tyarg11, ..., tyarg1n&gt; :&gt; type2&lt;tyarg21, ..., tyarg2n&gt;</code> where <code>type1</code> and <code>type2</code> are hierarchically related, are reduced to an equational constraint on two instantiations of <code>type2</code> according to the subtype relation between <code>type1</code> and <code>type2</code>, and solved again.</p> <p>For example, if <code>MySubClass&lt;'T&gt;</code> is derived from <code>MyBaseClass&lt;list&lt;'T&gt;&gt;</code>, then the constraint</p> <pre><code>MySubClass&lt;'T&gt; :&gt; MyBaseClass&lt;int&gt;\n</code></pre> <p>is reduced to the constraint</p> <pre><code>MyBaseClass&lt;list&lt;'T&gt;&gt; :&gt; MyBaseClass&lt;list&lt;int&gt;&gt;\n</code></pre> <p>and solved again, so that the constraint <code>'T = int</code> will eventually be derived.</p> <p>Note : Subtype constraints on single-dimensional array types <code>ty[] :&gt; ty</code> are reduced to residual constraints, because these types are considered to be subtypes of <code>System.Array</code>, <code>System.Collections.Generic.IList&lt;'T&gt;</code>, <code>System.Collections.Generic.ICollection&lt;'T&gt;</code>, and <code>System.Collections.Generic.IEnumerable&lt;'T&gt;</code>. Multidimensional array types <code>ty[,...,]</code> are also subtypes of <code>System.Array</code>. Types from other CLI languages may, in theory, support multiple instantiations of the same interface type, such as <code>C : I&lt;int&gt;, I&lt;string&gt;</code>. Consequently, it is more difficult to solve a constraint such as <code>C :&gt; I&lt;'T&gt;</code>. Such constraints are rarely used in practice in F# coding. To solve this constraint, the F# compiler reduces it to a constraint <code>C :&gt; I&lt;'T&gt;</code>, where <code>I&lt;'T&gt;</code> is the first interface type that occurs in the tree of supported interface types, when the tree is ordered from most derived to least derived, and iterated left-to- right in the order of the declarations in the CLI metadata. The F# compiler ignores CLI variance type annotations on interfaces.</p> <p>New constraints of the form <code>type :&gt; 'b</code> are solved again as <code>type = 'b</code>.</p> <p>Note : Such constraints typically occur only in calls to generic code from other CLI languages where a method accepts a parameter of a \u201cnaked\u201d variable type\u2014for example, a C# 2.0 function with a signature such as <code>T Choose&lt;'T&gt;(T x, T y)</code>.</p>"},{"location":"inference-procedures/#1453-solving-nullness-struct-and-other-simple-constraints","title":"14.5.3 Solving Nullness, Struct, and Other Simple Constraints","text":"<p>New constraints in any of the following forms, where <code>type</code> is not a variable type, are reduced to further constraints:</p> <pre><code>type : null\ntype : (new : unit -&gt; 'T)\ntype : struct\ntype : not struct\ntype : enum&lt; type &gt;\ntype : delegate&lt; type, type &gt;\ntype : unmanaged\n</code></pre> <p>The compiler then resolves them according to the requirements for each kind of constraint listed in \u00a75.2 and \u00a75.4.8.</p>"},{"location":"inference-procedures/#1454-solving-member-constraints","title":"14.5.4 Solving Member Constraints","text":"<p>New constraints in the following form are solved as member constraints (\u00a75.2.3):</p> <pre><code>(type1 or ... or typen) : (member-sig)\n</code></pre> <p>A member constraint is satisfied if one of the types in the support set <code>type1 ... typen</code> satisfies the member constraint. A static type <code>type</code> satisfies a member constraint in the form <code>(static~opt member ident : arg-type1 * ... * arg-typen -&gt; ret-type)</code> if all of the following are true:</p> <ul> <li><code>type</code> is a named type whose type definition contains the following member, which takes <code>n</code>     arguments:     <code>static~opt member ident : formal-arg-type1 * ... * formal-arg-typen -&gt; ret-type</code></li> <li>The <code>type</code> and the constraint are both marked <code>static</code> or neither is marked <code>static</code>.</li> <li>The assertion of type inference constraints on the arguments and return types does not result in     a type inference error.</li> </ul> <p>As mentioned in \u00a75.2.3, a type variable may not be involved in the support set of more than one member constraint that has the same name, staticness, argument arity, and support set. If a type variable is in the support set of more than one such constraint, the argument and return types are themselves constrained to be equal.</p>"},{"location":"inference-procedures/#14541-simulation-of-solutions-for-member-constraints","title":"14.5.4.1 Simulation of Solutions for Member Constraints","text":"<p>Certain types are assumed to implicitly define static members even though the actual CLI metadata for types does not define these operators. This mechanism is used to implement the extensible conversion and math functions of the F# library including <code>sin</code>, <code>cos</code>, <code>int</code>, <code>float</code>, <code>(+)</code>, and <code>(-)</code>. The following table shows the static members that are implicitly defined for various types.</p> Type Implicitly defined static members Integral types: <code>byte</code>, <code>sbyte</code>, <code>int16</code>, <code>uint16</code>, <code>int32</code>, <code>uint32</code>, <code>int64</code>, <code>uint64</code>, <code>nativeint</code>, <code>unativeint</code> <code>op_BitwiseAnd</code>, <code>op_BitwiseOr</code>, <code>op_ExclusiveOr</code>, <code>op_LeftShift</code>, <code>op_RightShift</code>, <code>op_UnaryPlus</code>, <code>op_UnaryNegation</code>, <code>op_Increment</code>, <code>op_Decrement</code>, <code>op_LogicalNot</code>, <code>op_OnesComplement</code>, <code>op_Addition</code>, <code>op_Subtraction</code>, <code>op_Multiply</code>, <code>op_Division</code>, <code>op_Modulus</code>, <code>op_UnaryPlus</code><code>op_Explicit</code>: takes the type as an argument and returns <code>byte</code>, <code>sbyte</code>, <code>int16</code>, <code>uint16</code>, <code>int32</code>, <code>uint32</code>, <code>int64</code>, <code>uint64</code>, <code>float32</code>, <code>float</code>, <code>decimal</code>, <code>nativeint</code>, or <code>unativeint</code> Signed integral CLI types: <code>sbyte</code>, <code>int16</code>, <code>int32</code>, <code>int64</code> and <code>nativeint</code> <code>op_UnaryNegation</code>, <code>Sign</code>, <code>Abs</code> Floating-point CLI types:<code>float32</code> and <code>float</code> <code>Sin</code>, <code>Cos</code>, <code>Tan</code>, <code>Sinh</code>, <code>Cosh</code>, <code>Tanh</code>, <code>Atan</code>, <code>Acos</code>, <code>Asin</code>, <code>Exp</code>, <code>Ceiling</code>, <code>Floor</code>, <code>Round</code>, <code>Log10</code>, <code>Log</code>, <code>Sqrt</code>, <code>Atan2</code>, <code>Pow</code>, <code>op_Addition</code>, <code>op_Subtraction</code>, <code>op_Multiply</code>, <code>op_Division</code>, <code>op_Modulus</code>, <code>op_UnaryPlus</code>, <code>op_UnaryNegation</code>, <code>Sign</code>, <code>Abs</code> <code>op_Explicit</code>: takes the type as an argument and returns <code>byte</code>, <code>sbyte</code>, <code>int16</code>, <code>uint16</code>, <code>int32</code>, <code>uint32</code>, <code>int64</code>, <code>uint64</code>, <code>float32</code>, <code>float</code>, <code>decimal</code>, <code>nativeint</code>, or <code>unativeint</code> decimal type Note : The decimal type is included only for the Sign static member. This is deliberate: in the CLI, <code>System.Decimal</code> includes the definition of static members such as <code>op_Addition</code> and the F# compiler does not need to simulate the existence of these methods. <code>Sign</code> String type <code>string</code> <code>op_Addition</code> <code>op_Explicit</code>: takes the type as an argument and return <code>byte</code>, <code>sbyte</code>, <code>int16</code>, <code>uint16</code>, <code>int32</code>, <code>uint32</code>, <code>int64</code>, <code>uint64</code>, <code>float32</code>, <code>float</code> or <code>decimal</code>."},{"location":"inference-procedures/#1455-over-constrained-user-type-annotations","title":"14.5.5 Over-constrained User Type Annotations","text":"<p>An implementation of F# must give a warning if a type inference variable that results from a user type annotation is constrained to be a type other than another type inference variable. For example, the following results in a warning because <code>'T</code> has been constrained to be precisely <code>string</code>:</p> <pre><code>let f (x:'T) = (x:string)\n</code></pre> <p>During the resolution of overloaded methods, resolutions that do not give such a warning are preferred over resolutions that do give such a warning.</p>"},{"location":"inference-procedures/#146-checking-and-elaborating-function-value-and-member-definitions","title":"14.6 Checking and Elaborating Function, Value, and Member Definitions","text":"<p>This section describes how function, value, and member definitions are checked, generalized, and elaborated. These definitions occur in the following contexts:</p> <ul> <li>Module declarations</li> <li>Class type declarations</li> <li>Expressions</li> <li>Computation expressions</li> </ul> <p>Recursive definitions can also occur in each of these locations. In addition, member definitions in a mutually recursive group of type declarations are implicitly recursive.</p> <p>Each definition is one of the following:</p> <ul> <li> <p>A function definition :</p> <pre><code>inline~opt ident1 pat1 ... patn :~opt return-type~opt = rhs-expr\n</code></pre> </li> <li> <p>A value definition, which defines one or more values by matching a pattern against an expression:</p> <pre><code>mutable~opt pat :~opt type~opt = rhs-expr\n</code></pre> </li> <li> <p>A member definition:</p> <pre><code>static~opt member ident~opt ident pat1 ... patn = expr\n</code></pre> </li> </ul> <p>For a function, value, or member definition in a class:</p> <ol> <li>If the definition is an instance function, value or member, checking uses an environment to     which both of the following have been added:<ul> <li>The instance variable for the class, if one is present.</li> <li>All previous function and value definitions for the type, whether static or instance.</li> </ul> </li> <li>If the definition is static (that is, a static function, value or member defeinition), checking uses an     environment to which all previous static function, value, and member definitions for the type     have been added.</li> </ol>"},{"location":"inference-procedures/#1461-ambiguities-in-function-and-value-definitions","title":"14.6.1 Ambiguities in Function and Value Definitions","text":"<p>In one case, an ambiguity exists between the syntax for function and value definitions. In particular, <code>ident pat = expr</code> can be interpreted as either a function or value definition. For example, consider the following:</p> <pre><code>type OneInteger = Id of int\n\nlet Id x = x\n</code></pre> <p>In this case, the ambiguity is whether <code>Id x</code> is a pattern that matches values of type <code>OneInteger</code> or is the function name and argument list of a function called <code>Id</code>. In F# this ambiguity is always resolved as a function definition. In this case, to make a value definition, use the following syntax in which the ambiguous pattern is enclosed in parentheses:</p> <pre><code>let v = if 3 = 4 then Id \"yes\" else Id \"no\"\nlet (Id answer) = v\n</code></pre>"},{"location":"inference-procedures/#1462-mutable-value-definitions","title":"14.6.2 Mutable Value Definitions","text":"<p>Value definitions may be marked as mutable. For example:</p> <pre><code>let mutable v = 0\nwhile v &lt; 10 do\n    v &lt;- v + 1\n    printfn \"v = %d\" v\n</code></pre> <p>These variables are implicitly dereferenced when used.</p>"},{"location":"inference-procedures/#1463-processing-value-definitions","title":"14.6.3 Processing Value Definitions","text":"<p>A value definition <code>pat = rhs-expr</code> with optional pattern type <code>type</code> is processed as follows:</p> <ol> <li>The pattern <code>pat</code> is checked against a fresh initial type <code>ty</code> (or <code>type</code> if such a type is present). This     check results in zero or more identifiers <code>ident1 ... identm</code>, each of type <code>ty1</code> ... <code>tym</code>.</li> <li>The expression <code>rhs-expr</code> is checked against initial type <code>ty</code>, resulting in an elaborated form <code>expr</code>.</li> <li>Each <code>identi</code> (of type <code>tyi</code>) is then generalized (\u00a714.6.7) and yields generic parameters <code>&lt;typarsj&gt;</code>.</li> <li>The following rules are checked:<ul> <li>All <code>identj</code> must be distinct.</li> <li>Value definitions may not be <code>inline</code>.</li> </ul> </li> <li> <p>If <code>pat</code> is a single value pattern, the resulting elaborated definition is:</p> <pre><code>ident&lt;typars1&gt; = expr\nbody-expr\n</code></pre> </li> <li> <p>Otherwise, the resulting elaborated definitions are the following, where <code>tmp</code> is a fresh identifier     and each <code>expri</code> results from the compilation of the pattern <code>pat</code> (\u00a77.) against input <code>tmp</code>.</p> <pre><code>tmp&lt;typars1 ... typarsn&gt; = expr\nident1&lt;typars1&gt; = expr1\n...\nidentn&lt;typarsn&gt; = exprn\n</code></pre> </li> </ol>"},{"location":"inference-procedures/#1464-processing-function-definitions","title":"14.6.4 Processing Function Definitions","text":"<p>A function definition <code>ident1 pat1 ... patn = rhs-expr</code> is processed as follows:</p> <ol> <li>If <code>ident1</code> is an active pattern identifier then active pattern result tags are added to the     environment (\u00a710.2.4).</li> <li>The expression <code>(fun pat1 ... patn : return-type -&gt; rhs-expr)</code> is checked against a fresh initial     type <code>ty1</code> and reduced to an elaborated form <code>expr1</code>. The return type is omitted if the definition     does not specify it.</li> <li>The <code>ident1</code> (of type <code>ty1</code>) is then generalized (\u00a714.6.7) and yields generic parameters <code>&lt;typars1&gt;</code>.</li> <li> <p>The following rules are checked:</p> <ul> <li>Function definitions may not be <code>mutable</code>. Mutable function values should be written as follows:</li> </ul> <pre><code>let mutable f = (fun args -&gt; ...)`\n</code></pre> <ul> <li>The patterns of functions may not include optional arguments (\u00a78.13.6).</li> <li>The resulting elaborated definition is:</li> </ul> <pre><code>ident1&lt;typars1&gt; = expr1\n</code></pre> </li> </ol>"},{"location":"inference-procedures/#1465-processing-recursive-groups-of-definitions","title":"14.6.5 Processing Recursive Groups of Definitions","text":"<p>A group of functions and values may be declared recursive through the use of <code>let rec</code>. Groups of members in a recursive set of type definitions are also implicitly recursive. In this case, the defined values are available for use within their own definitions\u2014that is, within all the expressions on the right-hand side of the definitions.</p> <p>For example:</p> <pre><code>let rec twoForward count =\n    printfn \"at %d, taking two steps forward\" count\n    if count = 1000 then \"got there!\"\n    else oneBack (count + 2)\nand oneBack count =\n    printfn \"at %d, taking one step back \" count\n    twoForward (count \u2013 1)\n</code></pre> <p>When one or more definitions specifies a value, the recursive expressions are analyzed for safety (\u00a714.6.6). This analysis may result in warnings\u2014including some reported at compile time\u2014and runtime checks.</p> <p>Within recursive groups, each definition in the group is checked (\u00a714.6.7) and then the definitions are generalized incrementally. In addition, any use of an ungeneralized recursive definition results in immediate constraints on the recursively defined construct. For example, consider the following declaration:</p> <pre><code>let rec countDown count x =\n    if count &gt; 0 then\n        let a = countDown (count - 1) 1 // constrains \"x\" to be of type int\n        let b = countDown (count \u2013 1) \"Hello\" // constrains \"x\" to be of type string\n        a + b\n    else\n        1\n</code></pre> <p>In this example, the definition is not valid because the recursive uses of <code>f</code> result in inconsistent constraints on <code>x</code>.</p> <p>If a definition has a full signature, early generalization applies and recursive calls at different types are permitted (\u00a714.6.7). For example:</p> <pre><code>module M =\n    let rec f&lt;'T&gt; (x:'T) : 'T =\n        let a = f 1\n        let b = f \"Hello\"\n        x\n</code></pre> <p>In this example, the definition is valid because <code>f</code> is subject to early generalization, and so the recursive uses of <code>f</code> do not result in inconsistent constraints on <code>x</code>.</p>"},{"location":"inference-procedures/#1466-recursive-safety-analysis","title":"14.6.6 Recursive Safety Analysis","text":"<p>A set of recursive definitions may include value definitions. For example:</p> <pre><code>type Reactor = React of (int -&gt; React) * int\n\nlet rec zero = React((fun c -&gt; zero), 0)\n\nlet const n =\n    let rec r = React((fun c -&gt; r), n)\n    r\n</code></pre> <p>Recursive value definitions may result in invalid recursive cycles, such as the following:</p> <pre><code>let rec x = x + 1\n</code></pre> <p>The Recursive Safety Analysis process partially checks the safety of these definitions and convert thems to a form that uses lazy initialization, where runtime checks are inserted to check initialization.</p> <p>A right-hand side expression is safe if it is any of the following:</p> <ul> <li>A function expression, including those whose bodies include references to variables that are     defined recursively.</li> <li>An object expression that implements an interface, including interfaces whose member bodies     include references to variables that are being defined recursively.</li> <li>A <code>lazy</code> delayed expression.</li> <li>A record, tuple, list, or data construction expression whose field initialization expressions are all     safe.</li> <li>A value that is not being recursively bound.</li> <li>A value that is being recursively bound and appears in one of the following positions:</li> <li>As a field initializer for a field of a record type where the field is marked <code>mutable</code>.</li> <li> <p>As a field initializer for an immutable field of a record type that is defined in the current        assembly.        If record fields contain recursive references to values being bound, the record fields must be        initialized in the same order as their declared type, as described later in this section.</p> </li> <li> <p>Any expression that refers only to earlier variables defined by the sequence of recursive     definitions.</p> </li> </ul> <p>Other right-hand side expressions are elaborated by adding a new definition. If the original definition is</p> <pre><code>u = expr\n</code></pre> <p>then a fresh value (say v) is generated with the definition:</p> <pre><code>v = lazy expr\n</code></pre> <p>and occurrences of the original variable <code>u</code> on the right-hand side are replaced by <code>Lazy.force v</code>. The following definition is then added at the end of the definition list:</p> <pre><code>u = v .Force()\n</code></pre> <p>Note: This specification implies that recursive value definitions are executed as an initialization graph of delayed computations. Some recursive references may be checked at runtime because the computations that are involved in evaluating the definitions might actually execute the delayed computations. The F# compiler gives a warning for recursive value definitions that might involve a runtime check. If runtime self-reference does occur then an exception will be raised. Recursive value definitions that involve computation are useful when defining objects such as forms, controls, and services that respond to various inputs. For example, GUI elements that store and retrieve the state of the GUI elements as part of their specification typically involve recursive value definitions. A simple example is the following menu item, which prints out part of its state when invoked:</p> <pre><code>open System.Windows.Form\nlet rec menuItem : MenuItem =\n    new MenuItem(\"&amp;Say Hello\",\n                 new EventHandler(fun sender e -&gt;\n                     printfn \"Text = %s\" menuItem.Text),\n                 Shortcut.CtrlH)\n</code></pre> <p>This code results in a compiler warning because, in theory, the <code>new MenuItem(...)</code> constructor might evaluate the callback as part of the construction process. However, because the <code>System.Windows.Forms</code> library is well designed, in this example this does not happen in practice, and so the warning can be suppressed or ignored by using compiler options.</p> <p>The F# compiler performs a simple approximate static analysis to determine whether immediate cyclic dependencies are certain to occur during the evaluation of a set of recursive value definitions. The compiler creates a graph of definite references and reports an error if such a dependency cycle exists. All references within function expressions, object expressions, or delayed expressions are assumed to be indefinite, which makes the analysis an under-approximation. As a result, this check catches naive and direct immediate recursion dependencies, such as the following:</p> <pre><code>let rec A = B + 1\nand B = A + 1\n</code></pre> <p>Here, a compile-time error is reported. This check is necessarily approximate because dependencies under function expressions are assumed to be delayed, and in this case the use of a lazy initialization means that runtime checks and forces are inserted.</p> <p>Note: In F# 3 .1 this check does not apply to value definitions that are generic through generalization because a generic value definition is not executed immediately, but is instead represented as a generic method. For example, the following value definitions are generic because each right-hand-side is generalizable:</p> <pre><code>let rec a = b\nand b = a\n</code></pre> <p>In compiled code they are represented as a pair of generic methods, as if the code had been written as follows:</p> <pre><code>let rec a&lt;'T&gt;() = b&lt;'T&gt;()\nand b&lt;'T&gt;() = a&lt;'T&gt;()\n</code></pre> <p>As a result, the definitions are not executed immediately unless the functions are called. Such definitions indicate a programmer error, because executing such generic, immediately recursive definitions results in an infinite loop or an exception. In practice these definitions only occur in pathological examples, because value definitions are generalizable only when the right-hand-side is very simple, such as a single value. Where this issue is a concern, type annotations can be added to existing value definitions to ensure they are not generic. For example:</p> <pre><code>let rec a : int = b\nand b : int = a\n</code></pre> <p>In this case, the definitions are not generic. The compiler performs immediate dependency analysis and reports an error. In addition, record fields in recursive data expressions must be initialized in the order they are declared. For example:</p> <pre><code>type Foo = {\n    x: int\n    y: int\n    parent: Foo option\n    children: Foo list\n}\n\nlet rec parent = { x = 0; y = 0; parent = None; children = children }\nand children = [{ x = 1; y = 1; parent = Some parent; children = [] }]\n\nprintf \"%A\" parent\n</code></pre> <p>Here, if the order of the fields x and y is swapped, a type-checking error occurs.</p>"},{"location":"inference-procedures/#1467-generalization","title":"14.6.7 Generalization","text":"<p>Generalization is the process of inferring a generic type for a definition where possible, thereby making the construct reusable with multiple different types. Generalization is applied by default at all function, value, and member definitions, except where listed later in this section. Generalization also applies to member definitions that implement generic virtual methods in object expressions.</p> <p>Generalization is applied incrementally to items in a recursive group after each item is checked.</p> <p>Generalization takes a set of ungeneralized but type-checked definitions checked-defns that form part of a recursive group, plus a set of unchecked definitions unchecked-defns that have not yet been checked in the recursive group, and an environment env. Generalization involves the following steps:</p> <ol> <li> <p>Choose a subset <code>generalizable-defns</code> of <code>checked-defns</code> to generalize.</p> <p>A definition can be generalized if its inferred type is closed with respect to any inference variables that are present in the types of the <code>unchecked-defns</code> that are in the recursive group and that are not yet checked or which, in turn, cannot be generalized. A greatest-fixed-point computation repeatedly removes definitions from the set of <code>checked-defns</code> until a stable set of generalizable definitions remains. 2. Generalize all type inference variables that are not otherwise ungeneralizable and for which any of the following is true: - The variable is present in the inferred types of one or more of <code>generalizable-defns</code>. - The variable is a type parameter copied from the enclosing type definition (for members and    \u201clet\u201d definitions in classes). - The variable is explicitly declared as a generic parameter on an item.</p> </li> </ol> <p>The following type inference variables cannot be generalized:</p> <ul> <li>A type inference variable <code>^typar</code> that is part of the inferred or declared type of a definition,     unless the definition is marked <code>inline</code>.</li> <li>A type inference variable in an inferred type in the ExprItems or PatItems tables of <code>env</code> , or in     an inferred type of a module in the ModulesAndNamespaces table in <code>env</code>.</li> <li>A type inference variable that is part of the inferred or declared type of a definition in which     the elaborated right-hand side of the definition is not a generalizable expression, as     described later in this section.</li> <li>A type inference variable that appears in a constraint that itself refers to an ungeneralizable     type variable.</li> </ul> <p>Generalizable type variables are computed by a greatest-fixed-point computation, as follows:</p> <ol> <li> <p>Start with all variables that are candidates for generalization.</p> </li> <li> <p>Determine a set of variables <code>U</code> that cannot be generalized because they are free in the environment or present in ungeneralizable definitions.</p> </li> <li> <p>Remove the variables in U from consideration.</p> </li> <li> <p>Add to <code>U</code> any inference variables that have a constraint that involves a variable in <code>U</code>.</p> </li> <li> <p>Repeat steps 2 through 4.</p> </li> </ol> <p>Informally, generalizable expressions represent a subset of expressions that can be freely copied and instantiated at multiple types without affecting the typical semantics of an F# program. The following expressions are generalizable:</p> <ul> <li>A function expression</li> <li>An object expression that implements an interface</li> <li>A delegate expression</li> <li>A \u201clet\u201d definition expression in which both the right-hand side of the definition and the body of     the expression are generalizable</li> <li>A \u201clet rec\u201d definition expression in which the right-hand sides of all the definitions and the body     of the expression are generalizable</li> <li>A tuple expression, all of whose elements are generalizable</li> <li>A record expression, all of whose elements are generalizable, where the record contains no     mutable fields</li> <li>A union case expression, all of whose arguments are generalizable</li> <li>An exception expression, all of whose arguments are generalizable</li> <li>An empty array expression</li> <li>A simple constant expression</li> <li>An application of a type function that has the <code>GeneralizableValue</code> attribute.</li> </ul> <p>Explicit type parameter definitions on value and member definitions can affect the process of type inference and generalization. In particular, a declaration that includes explicit generic parameters will not be generalized beyond those generic parameters. For example, consider this function:</p> <pre><code>let f&lt;'T&gt; (x : 'T) y = x\n</code></pre> <p>During type inference, this will result in a function of the following type, where <code>'_b</code> is a type inference variable that is yet to be resolved.</p> <pre><code>f&lt;'T&gt; : 'T -&gt; '_b -&gt; '_b\n</code></pre> <p>To permit generalization at these definitions, either remove the explicit generic parameters (if they can be inferred), or use the required number of parameters, as the following example shows:</p> <pre><code>let throw&lt;'T,'U&gt; (x:'T) (y:'U) = x\n</code></pre>"},{"location":"inference-procedures/#1468-condensation-of-generalized-types","title":"14.6.8 Condensation of Generalized Types","text":"<p>After a function or member definition is generalized, its type is condensed by removing generic type parameters that apply subtype constraints to argument positions. (The removed flexibility is implicitly reintroduced at each use of the defined function; see \u00a714.4.3).</p> <p>Condensation decomposes the type of a value or member to the following form:</p> <pre><code>ty11 * ... * ty1n -&gt; ... -&gt; tym1 * ... * tymn -&gt; rty\n</code></pre> <p>The positions <code>tyij</code> are called the parameter positions for the type.</p> <p>Condensation applies to a type parameter <code>'a</code> if all of the following are true:</p> <ul> <li><code>'a</code> is not an explicit type parameter.</li> <li><code>'a</code> occurs at exactly one <code>tyij</code> parameter position.</li> <li><code>'a</code> has a single coercion constraint <code>'a :&gt; ty</code> and no other constraints. However, one additional     nullness constraint is permitted if <code>ty</code> satisfies the nullness constraint.</li> <li><code>'a</code> does not occur in any other <code>tyij</code>, nor in <code>rty</code>.</li> <li><code>'a</code> does not occur in the constraints of any condensed <code>typar</code>.</li> </ul> <p>Condensation is a greatest-fixed-point computation that initially assumes all generalized type parameters are condensed, and then progressively removes type parameters until a minimal set remains that satisfies the above rules.</p> <p>The compiler removes all condensed type parameters and replaces them with their subtype constraint <code>ty</code>. For example:</p> <pre><code>let F x = (x :&gt; System.IComparable).CompareTo(x)\n</code></pre> <p>After generalization, the function is inferred to have the following type:</p> <pre><code>F : 'a -&gt; int when 'a :&gt; System.IComparable\n</code></pre> <p>In this case, the actual inferred, generalized type for <code>F</code> is condensed to:</p> <pre><code>F : System.IComparable -&gt; R\n</code></pre> <p>Condensation does not apply to arguments of unconstrained variable type. For example:</p> <pre><code>let ignore x = ()\n</code></pre> <p>with type</p> <pre><code>ignore: 'a -&gt; unit\n</code></pre> <p>In particular, this is not condensed to</p> <pre><code>ignore: obj -&gt; unit\n</code></pre> <p>In rare cases, condensation affects the points at which value types are boxed. In the following example, the value <code>3</code> is now boxed at uses of the function:</p> <pre><code>F 3\n</code></pre> <p>If a function is not generalized, condensation is not applied. For example, consider the following:</p> <pre><code>let test1 =\n    let ff = Seq.map id &gt;&gt; Seq.length\n    (ff [1], ff [| 1 |]) // error here\n</code></pre> <p>In this example, <code>ff</code> is not generalized, because it is not defined by using a generalizable expression\u2014 computed functions such as <code>Seq.map id &gt;&gt; Seq.length</code> are not generalizable. This means that its inferred type, after processing the definition, is</p> <pre><code>F : '_a -&gt; int when '_a :&gt; seq&lt;'_b&gt;\n</code></pre> <p>where the type variables are not generalized and are unsolved inference variables. The application of <code>ff</code> to <code>[1]</code> equates <code>'a</code> with <code>int list</code>, making the following the type of <code>F</code>:</p> <pre><code>F : int list -&gt; int\n</code></pre> <p>The application of <code>ff</code> to an array type then causes an error. This is similar to the error returned by the following:</p> <pre><code>let test1 =\n    let ff = Seq.map id &gt;&gt; Seq.length\n    (ff [1], ff [\"one\"]) // error here\n</code></pre> <p>Again, <code>ff</code> is not generalized, and its use with arguments of type <code>int list</code> and <code>string list</code> is not permitted.</p>"},{"location":"inference-procedures/#147-dispatch-slot-inference","title":"14.7 Dispatch Slot Inference","text":"<p>The F# compiler applies Dispatch Slot Inference to object expressions and type definitions before it processes their members. For both object expressions and type definitions, the following are input to Dispatch Slot Inference:</p> <ul> <li>A type <code>ty0</code> that is being implemented.</li> <li>A set of members <code>override x.M(arg1 ... argN)</code>.</li> <li>A set of additional interface types <code>ty1 ... tyn</code>.</li> <li>A further set of members <code>override x.M(arg1 ... argN)</code> for each <code>tyi</code>.</li> </ul> <p>Dispatch slot inference associates each member with a unique abstract member or interface member that the collected types <code>tyi</code> define or inherit.</p> <p>The types <code>ty0 ... tyn</code> together imply a collection of required types R, each of which has a set of required dispatch slots SlotsR of the form <code>abstract M : aty1 ... atyN -&gt; atyrty</code>. Each dispatch slot is placed under the most-specific <code>tyi</code> relevant to that dispatch slot. If there is no most-specific type for a dispatch slot, an error occurs.</p> <p>For example, assume the following definitions:</p> <pre><code>type IA = interface abstract P : int end\ntype IB = interface inherit IA end\ntype ID = interface inherit IB end\n</code></pre> <p>With these definitions, the following object expression is legal. Type <code>IB</code> is the most-specific implemented type that encompasses <code>IA</code>, and therefore the implementation mapping for <code>P</code> must be listed under <code>IB</code>:</p> <pre><code>let x = { new ID\n          interface IB with\n            member x.P = 2 }\n</code></pre> <p>But given:</p> <pre><code>type IA = interface abstract P : int end\ntype IB = interface inherit IA end\ntype IC = interface inherit IB end\ntype ID = interface inherit IB inherit IC end\n</code></pre> <p>then the following object expression causes an error, because both <code>IB</code> and <code>IC</code> include the interface <code>IA</code>, and consequently the implementation mapping for <code>P</code> is ambiguous.</p> <pre><code>let x = { new ID\n          interface IB with\n            member x.P = 2\n          interface IC with\n            member x.P = 2 }\n</code></pre> <p>The ambiguity can be resolved by explicitly implementing interface <code>IA</code>.</p> <p>After dispatch slots are assigned to types, the compiler tries to associate each member with a dispatch slot based on name and number of arguments. This is called dispatch slot inference, and it proceeds as follows:</p> <ul> <li> <p>For each <code>member x.M(arg1 ... argN)</code> in type <code>tyi</code>, attempt to find a single dispatch slot in the form</p> <pre><code>abstract M : aty1 ... atyN -&gt; rty\n</code></pre> <p>with name <code>M</code>, argument count <code>N</code>, and most-specific implementing type <code>tyi</code>.</p> </li> <li> <p>To determine the argument counts, analyze the syntax of patterns and look specifically for     tuple and unit patterns. Thus, the following members have argument count 1, even though     the argument type is unit:</p> <pre><code>member obj.ToString(() | ()) = ...\nmember obj.ToString(():unit) = ...\nmember obj.ToString(_:unit) = ...\n</code></pre> </li> <li> <p>A member may have a return type, which is ignored when determining argument counts:</p> <pre><code>member obj.ToString() : string = ...\n</code></pre> </li> </ul> <p>For example, given</p> <pre><code>let obj1 =\n    { new System.Collections.Generic.IComparer&lt;int&gt; with\n        member x.Compare(a,b) = compare (a % 7) (b % 7) }\n</code></pre> <p>the types of <code>a</code> and <code>b</code> are inferred by looking at the signature of the implemented dispatch slot, and are hence both inferred to be <code>int</code>.</p>"},{"location":"inference-procedures/#148-dispatch-slot-checking","title":"14.8 Dispatch Slot Checking","text":"<p>Dispatch Slot Checking is applied to object expressions and type definitions to check consistency properties, such as ensuring that all abstract members are implemented.</p> <p>After the compiler checks all bodies of all methods, it checks that a one-to-one mapping exists between dispatch slots and implementing members based on exact signature matching.</p> <p>The interface methods and abstract method slots of a type are collectively known as dispatch slots. Each object expression and type definition results in an elaborated dispatch map. This map is keyed by dispatch slots, which are qualified by the declaring type of the slot. This means that a type that supports two interfaces <code>I</code> and <code>I2</code>, both of which contain the method m, may supply different implementations for <code>I.m()</code> and <code>I2.m()</code>.</p> <p>The construction of the dispatch map for any particular type is as follows:</p> <ul> <li>If the type definition or extension has an implementation of an interface, mappings are added     for each member of the interface,</li> <li>If the type definition or extension has a <code>default</code> or <code>override</code> member, a mapping is added for the     associated abstract member slot.</li> </ul>"},{"location":"inference-procedures/#149-byref-safety-analysis","title":"14.9 Byref Safety Analysis","text":"<p>Byref arguments are pointers that can be stack-bound and are used to pass values by reference to procedures in CLI languages, often to simulate multiple return values. Byref pointers are not often used in F#; more typically, tuple values are used for multiple return values. However, a byref value can result from calling or overriding a CLI method that has a signature that involves one or more byref values.</p> <p>To ensure the safety of byref arguments, the following checks are made:</p> <ul> <li>Byref types may not be used as generic arguments.</li> <li>Byref values may not be used in any of the following:</li> <li>The argument types or body of function expressions <code>(fun ... -&gt; ...)</code>.</li> <li>The member implementations of object expressions.</li> <li>The signature or body of let-bound functions in classes.</li> <li>The signature or body of let-bound functions in expressions.</li> </ul> <p>Note that function expressions occur in:</p> <ul> <li>The elaborated form of sequence expressions.</li> <li>The elaborated form of computation expressions.</li> <li>The elaborated form of partial applications of module-bound functions and members.</li> </ul> <p>In addition:</p> <ul> <li>A generic type cannot be instantiated by a byref type.</li> <li>An object field cannot have a byref type.</li> <li>A static field or module-bound value cannot have a byref type.</li> </ul> <p>As a result, a byref-typed expression can occur only in these situations:</p> <ul> <li> <p>As an argument to a call to a module-defined function or class-defined function.</p> </li> <li> <p>On the right-hand-side of a value definition for a byref-typed local.</p> </li> </ul> <p>These restrictions also apply to uses of the prefix &amp;&amp; operator for generating native pointer values.</p>"},{"location":"inference-procedures/#1410-promotion-of-escaping-mutable-locals-to-objects","title":"14.10 Promotion of Escaping Mutable Locals to Objects","text":"<p>Value definitions whose byref address would be subject to the restrictions on <code>byref&lt;_&gt;</code> listed in \u00a714.9 are treated as implicit declarations of reference cells. For example</p> <pre><code>let sumSquares n =\n    let mutable total = 0\n    [ 1 .. n ] |&gt; Seq.iter (fun x -&gt; total &lt;- total + x*x)\n    total\n</code></pre> <p>is considered equivalent to the following definition:</p> <pre><code>let sumSquares n =\n    let total = ref 0\n    [ 1 .. n ] |&gt; Seq.iter\n                    (fun x -&gt; total.contents &lt;- total.contents + x*x)\n    total.contents\n</code></pre> <p>because the following would be subject to byref safety analysis:</p> <pre><code>let sumSquares n =\n    let mutable total = 0\n    &amp;total\n</code></pre>"},{"location":"inference-procedures/#1411-arity-inference","title":"14.11 Arity Inference","text":"<p>During checking, members within types and function definitions within modules are inferred to have an arity. An arity includes both of the following:</p> <ul> <li>The number of iterated (curried) arguments <code>n</code></li> <li>A tuple length for these arguments <code>[A1; ...; An]</code>. A tuple length of zero indicates that the     corresponding argument is of type <code>unit</code>.</li> </ul> <p>Arities are inferred as follows. A function definition of the following form is given arity <code>[A1; ...; An]</code>, where each <code>Ai</code> is derived from the tuple length for the final inferred types of the patterns:</p> <pre><code>let ident pat 1 ... patn = ...\n</code></pre> <p>For example, the following is given arity [1; 2]:</p> <pre><code>let f x (y,z) = x + y + z\n</code></pre> <p>Arities are also inferred from function expressions that appear on the immediate right of a value definition. For example, the following has an arity of [1]:</p> <pre><code>let f = fun x -&gt; x + 1\n</code></pre> <p>Similarly, the following has an arity of [1;1]:</p> <pre><code>let f x = fun y -&gt; x + y\n</code></pre> <p>Arity inference is applied partly to help define the elaborated form of a function definition. This is the form that other CLI languages see. In particular:</p> <ul> <li>A function value <code>F</code> in a module that has arity <code>[A1 ; ...; An]</code> and the type     <code>ty1,1 * ... * ty1,A1 -&gt; ... -&gt; tyn,1 * ... * tyn,An - &gt; rty</code>     elaborates to a CLI static method definition with signature     <code>rty F(ty1,1, ..., ty1,A1, ..., tyn,1 , ..., tyn,An)</code>.</li> <li>F# instance (respectively static) methods that have arity <code>[A1 ; ...; An]</code> and type     <code>ty1,1 * ... * ty1,A1 -&gt; ... -&gt; tyn,1 * ... * tynAn -&gt; rty</code>     elaborate to a CLI instance (respectively static) method definition with signature     <code>rty F(ty1,1, ..., ty1,A1)</code>, subject to the syntactic restrictions that result from the patterns that     define the member, as described later in this section.</li> </ul> <p>For example, consider a function in a module with the following definition:</p> <pre><code>let AddThemUp x (y, z) = x + y + z\n</code></pre> <p>This function compiles to a CLI static method with the following C# signature:</p> <pre><code>int AddThemUp(int x, int y, int z);\n</code></pre> <p>Arity inference applies differently to function and member definitions. Arity inference on function definitions is fully type-directed. Arity inference on members is limited if parentheses or other patterns are used to specify the member arguments. For example:</p> <pre><code>module Foo =\n    // compiles as a static method taking 3 arguments\n    let test1 (a1: int, a2: float, a3: string) = ()\n\n    // compiles as a static method taking 3 arguments\n    let test2 (aTuple : int * float * string) = ()\n\n    // compiles as a static method taking 3 arguments\n    let test3 ( (aTuple : int * float * string) ) = ()\n\n    // compiles as a static method taking 3 arguments\n    let test4 ( (a1: int, a2: float, a3: string) ) = ()\n\n    // compiles as a static method taking 3 arguments\n    let test5 (a1, a2, a3 : int * float * string) = ()\n\ntype Bar() =\n    // compiles as a static method taking 3 arguments\n    static member Test1 (a1: int, a2: float, a3: string) = ()\n\n    // compiles as a static method taking 1 tupled argument\n    static member Test2 (aTuple : int * float * string) = ()\n\n    // compiles as a static method taking 1 tupled argument\n    static member Test3 ( (aTuple : int * float * string) ) = ()\n\n    // compiles as a static method taking 1 tupled argument\n    static member Test4 ( (a1: int, a2: float, a3: string) ) = ()\n\n    // compiles as a static method taking 1 tupled argument\n    static member Test5 (a1, a2, a3 : int * float * string) = ()\n</code></pre>"},{"location":"inference-procedures/#1412-additional-constraints-on-cli-methods","title":"14.12 Additional Constraints on CLI Methods","text":"<p>F# treats some CLI methods and types specially, because they are common in F# programming and cause extremely difficult-to-find bugs. For each use of the following constructs, the F# compiler imposes additional ad hoc constraints:</p> <p><code>x.Equals(yobj)</code> requires type <code>ty : equality</code> for the static type of <code>x</code></p> <p><code>x.GetHashCode()</code> requires type <code>ty : equality</code> for the static type of <code>x</code></p> <p><code>new Dictionary&lt;A,B&gt;()</code> requires <code>A : equality</code>, for any overload that does not take an <code>IEqualityComparer&lt;T&gt;</code></p> <p>No constraints are added for the following operations. Consider writing wrappers around these functions to improve the type safety of the operations.</p> <p><code>System.Array.BinarySearch&lt;T&gt;(array,value)</code> requiring <code>C : comparison</code>, for any overload that does not take an <code>IComparer&lt;T&gt;</code></p> <p><code>System.Array.IndexOf</code> requiring <code>C : equality</code></p> <p><code>System.Array.LastIndexOf(array,T)</code> requiring <code>C : equality</code></p> <p><code>System.Array.Sort&lt;'T&gt;(array)</code> requiring <code>C : comparison</code>, for any overload that does not take an <code>IEqualityComparer&lt;T&gt;</code></p> <p><code>new SortedList&lt;A,B&gt;()</code> requiring <code>A : comparison</code>, for any overload that does not take an <code>IEqualityComparer&lt;T&gt;</code></p> <p><code>new SortedDictionary&lt;A,B&gt;()</code> requiring <code>C : comparison</code>, for any overload that does not take an <code>IEqualityComparer&lt;_&gt;</code></p>"},{"location":"introduction/","title":"1. Introduction","text":"<p>F# is a scalable, succinct, type-safe, type-inferred, efficiently executing functional/imperative/object-oriented programming language. It aims to be the premier typed functional programming language for .NET and other implementations of the ECMA-335 Common Language Infrastructure (CLI) specification. F# was partly inspired by the OCaml language and shares some common core constructs with it.</p>"},{"location":"introduction/#11-a-first-program","title":"1.1 A First Program","text":"<p>Over the next few sections, we will look at some small F# programs, describing some important aspects of F# along the way. As an introduction to F#, consider the following program:</p> <pre><code>let numbers = [ 1 .. 10 ]\nlet square x = x * x\nlet squares = List.map square numbers\nprintfn \"N^2 = %A\" squares\n</code></pre> <p>To explore this program, you can:</p> <ul> <li>Compile it as a project in a development environment such as Visual Studio.</li> <li>Manually invoke the F# command line compiler fsc.exe.</li> <li>Use F# Interactive, the dynamic compiler that is part of the F# distribution.</li> </ul>"},{"location":"introduction/#111-lightweight-syntax","title":"1.1.1 Lightweight Syntax","text":"<p>The F# language uses simplified, indentation-aware syntactic constructs known as lightweight syntax. The lines of the sample program in the previous section form a sequence of declarations and are aligned on the same column. For example, the two lines in the following code are two separate declarations:</p> <pre><code>let squares = List.map square numbers\nprintfn \"N^2 = %A\" squares\n</code></pre> <p>Lightweight syntax applies to all the major constructs of the F# syntax. In the next example, the code is incorrectly aligned. The declaration starts in the first line and continues to the second and subsequent lines, so those lines must be indented to the same column under the first line:</p> <pre><code>let computeDerivative f x =\n    let p1 = f (x - 0.05)\n    let p2 = f (x + 0.05)\n        (p2 - p1) / 0.1\n</code></pre> <p>The following shows the correct alignment:</p> <pre><code>let computeDerivative f x =\n    let p1 = f (x - 0.05)\n    let p2 = f (x + 0.05)\n    (p2 - p1) / 0.1\n</code></pre> <p>The use of lightweight syntax is the default for all F# code in files with the extension .fs, .fsx, .fsi, or .fsscript.</p>"},{"location":"introduction/#112-making-data-simple","title":"1.1.2 Making Data Simple","text":"<p>The first line in our sample simply declares a list of numbers from one through ten.</p> <pre><code>let numbers = [1 .. 10]\n</code></pre> <p>An F# list is an immutable linked list, which is a type of data used extensively in functional programming. Some operators that are related to lists include <code>::</code> to add an item to the front of a list and <code>@</code> to concatenate two lists. If we try these operators in F# Interactive, we see the following results:</p> <pre><code>&gt; let vowels = ['e'; 'i'; 'o'; 'u'];;\nval vowels: char list = ['e'; 'i'; 'o'; 'u']\n\n&gt; ['a'] @ vowels;;\nval it: char list = ['a'; 'e'; 'i'; 'o'; 'u']\n\n&gt; vowels @ ['y'];;\nval it: char list = ['e'; 'i'; 'o'; 'u'; 'y']\n</code></pre> <p>Note that double semicolons delimit lines in F# Interactive, and that F# Interactive prefaces the result with val to indicate that the result is an immutable value, rather than a variable.</p> <p>F# supports several other highly effective techniques to simplify the process of modeling and manipulating data such as tuples, options, records, unions, and sequence expressions. A tuple is an ordered collection of values that is treated as an atomic unit. In many languages, if you want to pass around a group of related values as a single entity, you need to create a named type, such as a class or record, to store these values. A tuple allows you to keep things organized by grouping related values together, without introducing a new type.</p> <p>To define a tuple, you separate the individual components with commas:</p> <pre><code>&gt; let tuple = (1, false, \"text\");;\nval tuple : int * bool * string = (1, false, \"text\")\n\n&gt; let getNumberInfo (x : int) = (x, x.ToString(), x * x);;\nval getNumberInfo : int -&gt; int * string * int\n\n&gt; getNumberInfo 42;;\nval it : int * string * int = (42, \"42\", 1764)\n</code></pre> <p>A key concept in F# is immutability. Tuples and lists are some of the many types in F# that are immutable, and indeed most things in F# are immutable by default. Immutability means that once a value is created and given a name, the value associated with the name cannot be changed. Immutability has several benefits. Most notably, it prevents many classes of bugs, and immutable data is inherently thread-safe, which makes the process of parallelizing code simpler.</p>"},{"location":"introduction/#113-making-types-simple","title":"1.1.3 Making Types Simple","text":"<p>The next line of the sample program defines a function called <code>square</code>, which squares its input.</p> <pre><code>let square x = x * x\n</code></pre> <p>Most statically-typed languages require that you specify type information for a function declaration. However, F# typically infers this type information for you. This process is referred to as type inference.</p> <p>From the function signature, F# knows that <code>square</code> takes a single parameter named <code>x</code> and that the function returns <code>x * x</code>. The last thing evaluated in an F# function body is the return value; hence there is no \"return\" keyword here. Many primitive types support the multiplication (*) operator (such as <code>byte</code>, <code>uint64</code>, and <code>double</code>); however, for arithmetic operations, F# infers the type <code>int</code> (a signed 32-bit integer) by default.</p> <p>Although F# can typically infer types on your behalf, occasionally you must provide explicit type annotations in F# code. For example, the following code uses a type annotation for one of the parameters to tell the compiler the type of the input.</p> <pre><code>&gt; let concat (x : string) y = x + y;;\nval concat : string -&gt; string -&gt; string\n</code></pre> <p>Because <code>x</code> is stated to be of type <code>string</code>, and the only version of the <code>+</code> operator that accepts a left-hand argument of type <code>string</code> also takes a <code>string</code> as the right-hand argument, the F# compiler infers that the parameter <code>y</code> must also be a string. Thus, the result of <code>x + y</code> is the concatenation of the strings. Without the type annotation, the F# compiler would not have known which version of the <code>+</code> operator was intended and would have assumed <code>int</code> data by default.</p> <p>The process of type inference also applies automatic generalization to declarations. This automatically makes code generic when possible, which means the code can be used on many types of data. For example, the following code defines a function that returns a new tuple in which the two values are swapped:</p> <pre><code>&gt; let swap (x, y) = (y, x);;\nval swap : 'a * 'b -&gt; 'b * 'a\n\n&gt; swap (1, 2);;\nval it : int * int = (2, 1)\n\n&gt; swap (\"you\", true);;\nval it : bool * string = (true,\"you\")\n</code></pre> <p>Here the function <code>swap</code> is generic, and <code>'a</code> and <code>'b</code> represent type variables, which are placeholders for types in generic code. Type inference and automatic generalization greatly simplify the process of writing reusable code fragments.</p>"},{"location":"introduction/#114-functional-programming","title":"1.1.4 Functional Programming","text":"<p>Continuing with the sample, we have a list of integers named <code>numbers</code>, and the <code>square</code> function, and we want to create a new list in which each item is the result of a call to our function. This is called mapping our function over each item in the list. The F# library function <code>List.map</code> does just that:</p> <pre><code>let squares = List.map square numbers\n</code></pre> <p>Consider another example:</p> <pre><code>&gt; List.map (fun x -&gt; x % 2 = 0) [1 .. 5];;\nval it : bool list = [false; true; false; true; false]\n</code></pre> <p>The code <code>(fun x -&gt; x % 2 = 0)</code> defines an anonymous function, called a function expression, that takes a single parameter <code>x</code> and returns the result <code>x % 2 = 0</code>, which is a Boolean value that indicates whether <code>x</code> is even. The <code>-&gt;</code> symbol separates the argument list (<code>x</code>) from the function body (<code>x % 2 = 0</code>).</p> <p>Both of these examples pass a function as a parameter to another function \u2014 the first parameter to <code>List.map</code> is itself another function. Using functions as function values is a hallmark of functional programming.</p> <p>Another tool for data transformation and analysis is pattern matching. This powerful switch construct allows you to branch control flow and to bind new values. For example, we can match an F# list against a sequence of list elements.</p> <pre><code>let checkList alist =\n    match alist with\n    | [] -&gt; 0\n    | [a] -&gt; 1\n    | [a; b] -&gt; 2\n    | [a; b; c] -&gt; 3\n    | _ -&gt; failwith \"List is too big!\"\n</code></pre> <p>In this example, <code>alist</code> is compared with each potentially matching pattern of elements. When <code>alist</code> matches a pattern, the result expression is evaluated and is returned as the value of the match expression. Here, the <code>-&gt;</code> operator separates a pattern from the result that a match returns.</p> <p>Pattern matching can also be used as a control construct \u2014 for example, by using a pattern that performs a dynamic type test:</p> <pre><code>let getType (x : obj) =\n    match x with\n    | :? string -&gt; \"x is a string\"\n    | :? int -&gt; \"x is an int\"\n    | :? System.Exception -&gt; \"x is an exception\"\n</code></pre> <p>The <code>:?</code> operator returns true if the value matches the specified type, so if <code>x</code> is a string, <code>getType</code> returns <code>\"x is a string\"</code>.</p> <p>Function values can also be combined with the pipeline operator, <code>|&gt;</code>. For example, given these functions:</p> <pre><code>let square x = x * x\nlet toStr (x : int) = x.ToString()\nlet reverse (x : string) = new System.String(Array.rev (x.ToCharArray()))\n</code></pre> <p>We can use the functions as values in a pipeline:</p> <pre><code>&gt; let result = 32 |&gt; square |&gt; toStr |&gt; reverse;;\nval it : string = \"4201\"\n</code></pre> <p>Pipelining demonstrates one way in which F# supports compositionality, a key concept in functional programming. The pipeline operator simplifies the process of writing compositional code where the result of one function is passed into the next.</p>"},{"location":"introduction/#115-imperative-programming","title":"1.1.5 Imperative Programming","text":"<p>The next line of the sample program prints text in the console window.</p> <pre><code>printfn \"N^2 = %A\" squares\n</code></pre> <p>The F# library function <code>printfn</code> is a simple and type-safe way to print text in the console window. Consider this example, which prints an integer, a floating-point number, and a string:</p> <pre><code>&gt; printfn \"%d * %f = %s\" 5 0.75 ((5.0 * 0.75).ToString());;\n5 * 0.750000 = 3.75\nval it : unit = ()\n</code></pre> <p>The format specifiers <code>%d</code>, <code>%f</code>, and <code>%s</code> are placeholders for integers, floats, and strings. The <code>%A</code> format can be used to print arbitrary data types (including lists).</p> <p>The <code>printfn</code> function is an example of imperative programming, which means calling functions for their side effects. Other commonly used imperative programming techniques include arrays and dictionaries (also called hash tables). F# programs typically use a mixture of functional and imperative techniques.</p>"},{"location":"introduction/#116-net-interoperability-and-cli-fidelity","title":"1.1.6 .NET Interoperability and CLI Fidelity","text":"<p>The Common Language Infrastructure (CLI) function <code>System.Console.ReadKey</code> can be used to pause the program before the console window closes:</p> <pre><code>System.Console.ReadKey(true)\n</code></pre> <p>Because F# is built on top of CLI implementations, you can call any CLI library from F#. Furthermore, other CLI languages can easily use any F# component.</p>"},{"location":"introduction/#117-parallel-and-asynchronous-programming","title":"1.1.7 Parallel and Asynchronous Programming","text":"<p>F# is both a parallel and a reactive language. During execution, F# programs can have multiple parallel active evaluations and multiple pending reactions, such as callbacks and agents that wait to react to events and messages.</p> <p>One way to write parallel and reactive F# programs is to use F# async expressions. For example, the code below is similar to the original program in \u00a71.1 except that it computes the Fibonacci function (using a technique that will take some time) and schedules the computation of the numbers in parallel:</p> <pre><code>let rec fib x = if x &lt; 2 then 1 else fib(x-1) + fib(x-2)\n\nlet fibs =\n    Async.Parallel [ for i in 0..40 -&gt; async { return fib(i) } ]\n    |&gt; Async.RunSynchronously\n\nprintfn \"The Fibonacci numbers are %A\" fibs\n\nSystem.Console.ReadKey(true)\n</code></pre> <p>The preceding code sample shows multiple, parallel, CPU-bound computations.</p> <p>F# is also a reactive language. The following example requests multiple web pages in parallel, reacts to the responses for each request, and finally returns the collected results.</p> <pre><code>open System\nopen System.IO\nopen System.Net\n\nlet http url =\n    async {\n        let req = WebRequest.Create(Uri url)\n        use! resp = req.AsyncGetResponse()\n        use stream = resp.GetResponseStream()\n        use reader = new StreamReader(stream)\n        let contents = reader.ReadToEnd()\n        return contents\n    }\n\nlet sites =\n    [ \"http://www.bing.com\"\n      \"http://www.google.com\"\n      \"http://www.yahoo.com\"\n      \"http://www.search.com\" ]\n\nlet htmlOfSites =\n    Async.Parallel [ for site in sites -&gt; http site ]\n    |&gt; Async.RunSynchronously\n</code></pre> <p>By using asynchronous workflows together with other CLI libraries, F# programs can implement parallel tasks, parallel I/O operations, and message-receiving agents.</p>"},{"location":"introduction/#118-strong-typing-for-numerical-code","title":"1.1.8 Strong Typing for Numerical Code","text":"<p>F# applies type checking and type inference to numerically-intensive domains through units of measure inference and checking. This feature allows you to type-check programs that manipulate numerical values that represent physical and abstract quantities in a stronger way than other typed languages, without losing any performance in your compiled code. You can think of this feature as providing a type system for numerical code.</p> <p>Consider the following example:</p> <pre><code>[&lt;Measure&gt;] type kg\n[&lt;Measure&gt;] type m\n[&lt;Measure&gt;] type s\n\nlet gravityOnEarth = 9.81&lt;m/s^2&gt;\nlet heightOfTowerOfPisa = 55.86&lt;m&gt;\nlet speedOfImpact = sqrt(2.0 * gravityOnEarth * heightOfTowerOfPisa)\n</code></pre> <p>The <code>Measure</code> attribute tells F# that <code>kg</code>, <code>s</code>, and <code>m</code> are not really types in the usual sense of the word, but are used to build units of measure. Here <code>speedOfImpact</code> is inferred to have type <code>float&lt;m/s&gt;</code>.</p>"},{"location":"introduction/#119-object-oriented-programming-and-code-organization","title":"1.1.9 Object-Oriented Programming and Code Organization","text":"<p>The sample program shown at the start of this chapter is a script. Although scripts are excellent for rapid prototyping, they are not suitable for larger software components. F# supports the transition from scripting to structured code through several techniques.</p> <p>The most important of these is object-oriented programming through the use of class type definitions, interface type definitions, and object expressions. Object-oriented programming is a primary application programming interface (API) design technique for controlling the complexity of large software projects. For example, here is a class definition for an encoder/decoder object.</p> <pre><code>open System\n\n/// Build an encoder/decoder object that maps characters to an\n/// encoding and back. The encoding is specified by a sequence\n/// of character pairs, for example, [('a','Z'); ('Z','a')]\ntype CharMapEncoder(symbols: seq&lt;char*char&gt;) =\n    let swap (x, y) = (y, x)\n\n    /// An immutable tree map for the encoding\n    let fwd = symbols |&gt; Map.ofSeq\n\n    /// An immutable tree map for the decoding\n    let bwd = symbols |&gt; Seq.map swap |&gt; Map.ofSeq\n    let encode (s:string) =\n        String [| for c in s -&gt; if fwd.ContainsKey(c) then fwd.[c] else c |]\n\n    let decode (s:string) =\n        String [| for c in s -&gt; if bwd.ContainsKey(c) then bwd.[c] else c |]\n\n    /// Encode the input string\n    member x.Encode(s) = encode s\n\n    /// Decode the given string\n    member x.Decode(s) = decode s\n</code></pre> <p>You can instantiate an object of this type as follows:</p> <pre><code>let rot13 (c:char) =\n    char(int 'a' + ((int c - int 'a' + 13) % 26))\nlet encoder =\n    CharMapEncoder( [for c in 'a'..'z' -&gt; (c, rot13 c)])\n</code></pre> <p>And use the object as follows:</p> <pre><code>&gt; \"F# is fun!\" |&gt; encoder.Encode ;;\nval it : string = \"F# vf sha!\"\n\n&gt; \"F# is fun!\" |&gt; encoder.Encode |&gt; encoder.Decode ;;\nval it : String = \"F# is fun!\"\n</code></pre> <p>An interface type can encapsulate a family of object types:</p> <pre><code>open System\n\ntype IEncoding =\n    abstract Encode : string -&gt; string\n    abstract Decode : string -&gt; string\n</code></pre> <p>In this example, <code>IEncoding</code> is an interface type that includes both <code>Encode</code> and <code>Decode</code> object types.</p> <p>Both object expressions and type definitions can implement interface types. For example, here is an object expression that implements the <code>IEncoding</code> interface type:</p> <pre><code>let nullEncoder =\n    { new IEncoding with\n        member x.Encode(s) = s\n        member x.Decode(s) = s }\n</code></pre> <p>Modules are a simple way to encapsulate code during rapid prototyping when you do not want to spend the time to design a strict object-oriented type hierarchy. In the following example, we place a portion of our original script in a module.</p> <pre><code>module ApplicationLogic =\n    let numbers n = [1 .. n]\n    let square x = x * x\n    let squares n = numbers n |&gt; List.map square\n\nprintfn \"Squares up to 5 = %A\" (ApplicationLogic.squares 5)\nprintfn \"Squares up to 10 = %A\" (ApplicationLogic.squares 10)\nSystem.Console.ReadKey(true)\n</code></pre> <p>Modules are also used in the F# library design to associate extra functionality with types. For example, <code>List.map</code> is a function in a module.</p> <p>Other mechanisms aimed at supporting software engineering include signatures, which can be used to give explicit types to components, and namespaces, which serve as a way of organizing the name hierarchies for larger APIs.</p>"},{"location":"introduction/#1110-information-rich-programming","title":"1.1.10 Information-rich Programming","text":"<p>F# Information-rich programming addresses the trend toward greater availability of data, services, and information. The key to information-rich programming is to eliminate barriers to working with diverse information sources that are available on the Internet and in modern enterprise environments. Type providers and query expressions are a significant part of F# support for information-rich programming.</p> <p>The F# Type Provider mechanism allows you to seamlessly incorporate, in a strongly typed manner, data and services from external sources. A type provider presents your program with new types and methods that are typically based on the schemas of external information sources. For example, an F# type provider for Structured Query Language (SQL) supplies types and methods that allow programmers to work directly with the tables of any SQL database:</p> <pre><code>// Add References to FSharp.Data.TypeProviders, System.Data, and System.Data.Linq\ntype schema = SqlDataConnection&lt;\"Data Source=localhost;Integrated Security=SSPI;\"&gt;\n\nlet db = schema.GetDataContext()\n</code></pre> <p>The type provider connects to the database automatically and uses this for IntelliSense and type information.</p> <p>Query expressions (added in F# 3.0) add the established power of query-based programming against SQL, Open Data Protocol (OData), and other structured or relational data sources. Query expressions provide support for language-Integrated Query (LINQ) in F#, and several query operators enable you to construct more complex queries. For example, we can create a query to filter the customers in the data source:</p> <pre><code>let countOfCustomers =\n    query {\n        for customer in db.Customers do\n            where (customer.LastName.StartsWith(\"N\"))\n            select (customer.FirstName, customer.LastName)\n        }\n</code></pre> <p>Now it is easier than ever to access many important data sources\u2014including enterprise, web, and cloud\u2014by using a set of built-in type providers for SQL databases and web data protocols. Where necessary, you can create your own custom type providers or reference type providers that others have created. For example, assume your organization has a data service that provides a large and growing number of named data sets, each with its own stable data schema. You may choose to create a type provider that reads the schemas and presents the latest available data sets to the programmer in a strongly typed way.</p>"},{"location":"introduction/#12-notational-conventions-in-this-specification","title":"1.2 Notational Conventions in This Specification","text":"<p>This specification describes the F# language by using a mixture of informal and semiformal techniques. All examples in this specification use lightweight syntax, unless otherwise specified.</p> <p>Regular expressions are given in the usual notation, as shown in the table:</p> Notation Meaning regexp+ One or more occurrences regexp* Zero or more occurrences regexp? Zero or one occurrences [ char - char ] Range of ASCII characters [ ^ char - char ] Any characters except those in the range <p>Unicode character classes are referred to by their abbreviation as used in CLI libraries for regular expressions\u2014for example, <code>\\Lu</code> refers to any uppercase letter. The following characters are referred to using the indicated notation:</p> Character Name Notation \\b backspace ASCII/UTF-8/UTF-16/UTF-32 code 08 \\n newline ASCII/UTF-8/UTF-16/UTF-32 code 10 \\r return ASCII/UTF-8/UTF-16/UTF-32 code 13 \\t tab ASCII/UTF-8/UTF-16/UTF-32 code 09 <p>Strings of characters that are clearly not a regular expression are written verbatim. Therefore, the following string</p> <pre><code>abstract\n</code></pre> <p>matches precisely the characters <code>abstract</code>.</p> <p>Where appropriate, apostrophes and quotation marks enclose symbols that are used in the specification of the grammar itself, such as <code>'&lt;'</code> and <code>'|'</code>. For example, the following regular expression matches <code>(+)</code> or <code>(-)</code>:</p> <pre><code>'(' (+|-) ')'\n</code></pre> <p>This regular expression matches precisely the characters <code>#if</code>:</p> <pre><code>\"#if\"\n</code></pre> <p>Regular expressions are typically used to specify tokens.</p> <pre><code>token token-name = regexp\n</code></pre> <p>In the grammar rules, the notation <code>element-name?</code> indicates an optional element. The notation <code>...</code> indicates repetition of the preceding non-terminal construct and the separator token. For example, <code>expr ',' ... ',' expr</code> means a sequence of one or more <code>expr</code> elements separated by commas.</p>"},{"location":"lexical-analysis/","title":"3. Lexical Analysis","text":"<p>Lexical analysis converts an input stream of Unicode characters into a stream of tokens by iteratively processing the stream. If more than one token can match a sequence of characters in the source file, lexical processing always forms the longest possible lexical element. Some tokens, such as <code>block-comment-start</code>, are discarded after processing as described later in this section.</p>"},{"location":"lexical-analysis/#31-whitespace","title":"3.1 Whitespace","text":"<p>Whitespace consists of spaces and newline characters.</p> <pre><code>regexp whitespace = ' '+\nregexp newline = '\\n' | '\\r' '\\n'\ntoken whitespace-or-newline = whitespace | newline\n</code></pre> <p>Whitespace tokens <code>whitespace-or-newline</code> are discarded from the returned token stream.</p>"},{"location":"lexical-analysis/#32-comments","title":"3.2 Comments","text":"<p>Block comments are delimited by <code>(*</code> and <code>*)</code> and may be nested. Single-line comments begin with two backslashes (<code>//</code>) and extend to the end of the line.</p> <pre><code>token block-comment-start = \"(*\"\ntoken block-comment-end = \"*)\"\ntoken end-of-line-comment = \"//\" [^'\\n' '\\r']*\n</code></pre> <p>When the input stream matches a <code>block-comment-start</code> token, the subsequent text is tokenized recursively against the tokens that are described in \u00a73 until a <code>block-comment-end</code> token is found. The intermediate tokens are discarded.</p> <p>For example, comments can be nested, and strings that are embedded within comments are tokenized by the rules for <code>string</code>, <code>verbatim-string</code> , and <code>triple-quoted string</code>. In particular, strings that are embedded in comments are tokenized in their entirety, without considering closing <code>*)</code> marks. As a result of this rule, the following is a valid comment:</p> <pre><code>(* Here's a code snippet: let s = \"*)\" *)\n</code></pre> <p>However, the following construct, which was valid in F# 2.0, now produces a syntax error because a closing comment token *) followed by a triple-quoted mark is parsed as part of a string:</p> <pre><code>(* \"\"\" *)\n</code></pre> <p>For the purposes of this specification, comment tokens are discarded from the returned lexical stream. In practice, XML documentation tokens are <code>end-of-line-comments</code> that begin with ///. The delimiters are retained and are associated with the remaining elements to generate XML documentation.</p>"},{"location":"lexical-analysis/#33-conditional-compilation","title":"3.3 Conditional Compilation","text":"<p>The lexical preprocessing directives <code>#if ident /#else/#endif</code> delimit conditional compilation sections. The following describes the grammar for such sections:</p> <pre><code>token if-directive = \"#if\" whitespace if-expression-text\ntoken else-directive = \"#else\"\ntoken endif-directive = \"#endif\"\n\nif-expression-term =\n    ident-text\n    '(' if-expression ')'\n\nif-expression-neg =\n    if-expression-term\n    '!' if-expression-term\n\nif-expression-and =\n    if-expression-neg\n    if-expression-and &amp;&amp; if-expression-and\n\nif-expression-or =\n    if-expression-and\n    if-expression-or || if-expression-or\n\nif-expression = if-expression-or\n</code></pre> <p>A preprocessing directive always occupies a separate line of source code and always begins with a # character followed immediately by a preprocessing directive name, with no intervening whitespace. However, whitespace can appear before the # character. A source line that contains the <code>#if</code>, <code>#else</code>, or <code>#endif</code> directive can end with whitespace and a single-line comment. Multiple-line comments are not permitted on source lines that contain preprocessing directives.</p> <p>If an <code>if-directive</code> token is matched during tokenization, text is recursively tokenized until a corresponding <code>else-directive</code> or <code>endif-directive</code>. If the evaluation of the associated <code>if-expression-text</code> when parsed as an if-expression is true in the compilation environment defines (where each <code>ident-text</code> is evaluataed according to the values given by command line options such as <code>\u2013define</code>), the token stream includes the tokens between the <code>if-directive</code> and the corresponding <code>else-directive</code> or <code>endif-directive</code>. Otherwise, the tokens are discarded. The converse applies to the text between any corresponding <code>else-directive</code> and the <code>endif-directive</code>.</p> <ul> <li>In skipped text, <code>#if ident /#else/#endif</code> sections can be nested.</li> <li>Strings and comments are not treated as special</li> </ul>"},{"location":"lexical-analysis/#34-identifiers-and-keywords","title":"3.4 Identifiers and Keywords","text":"<p>Identifiers follow the specification in this section.</p> <pre><code>regexp digit-char = [0-9]\nregexp letter-char = '\\Lu' | '\\Ll' | '\\Lt' | '\\Lm' | '\\Lo' | '\\Nl'\nregexp connecting-char = '\\Pc'\nregexp combining-char = '\\Mn' | '\\Mc'\nregexp formatting-char = '\\Cf'\n\nregexp ident-start-char =\n    | letter-char\n    | _\n\nregexp ident-char =\n    | letter-char\n    | digit-char\n    | connecting-char\n    | combining-char\n    | formatting-char\n    | '\n    | _\n\nregexp ident-text = ident-start-char ident-char *\ntoken ident =\n    | ident-text For example, myName1\n    | `` ( [^'`' '\\n' '\\r' '\\t'] | '`' [^ '`' '\\n' '\\r' '\\t'] )+ ``\n         example, ``value.with odd#name``\n</code></pre> <p>Any sequence of characters that is enclosed in double-backtick marks (<code>`` ``</code>), excluding newlines, tabs, and double-backtick pairs themselves, is treated as an identifier. Note that when an identifier is used for the name of a types, union type case, module, or namespace, the following characters are not allowed even inside double-backtick marks:</p> <pre><code>\u2018.', '+', '$', '&amp;', '[', ']', '/', '\\\\', '*', '\\\"', '`'\n</code></pre> <p>All input files are currently assumed to be encoded as UTF-8. See the C# specification for a list of the Unicode characters that are accepted for the Unicode character classes \\Lu, \\Li, \\Lt, \\Lm, \\Lo, \\Nl, \\Pc, \\Mn, \\Mc, and \\Cf.</p> <p>The following identifiers are treated as keywords of the F# language:</p> <pre><code>token ident-keyword =\n    abstract and as assert base begin class const default delegate do done\n    downcast downto elif else end exception extern false finally fixed for\n    fun function global if in inherit inline interface internal lazy let\n    match member module mutable namespace new null of open or\n    override private public rec return sig static struct then to\n    true try type upcast use val void when while with yield\n</code></pre> <p>The following identifiers are reserved for future use:</p> <pre><code>token reserved-ident-keyword =\n    break checked component constraint\n    continue fori include\n    mixin parallel params process protected pure\n    sealed tailcall trait virtual\n</code></pre> <p>A future revision of the F# language may promote any of these identifiers to be full keywords.</p> <p>The following identifiers were previously reserved but can now be used:</p> <pre><code>token ident =\n    atomic constructor eager functor measure method\n    object recursive volatile\n</code></pre> <p>The following token forms are reserved, except when they are part of a symbolic keyword (\u00a73.6).</p> <pre><code>token reserved-ident-formats =\n    | ident-text ( '!' | '#')\n</code></pre> <p>In the remainder of this specification, we refer to the token that is generated for a keyword simply by using the text of the keyword itself.</p>"},{"location":"lexical-analysis/#35-strings-and-characters","title":"3.5 Strings and Characters","text":"<p>String literals may be specified for two types:</p> <ul> <li>Unicode strings, type <code>string = System.String</code></li> <li>Unsigned byte arrays, type <code>byte[] = bytearray</code></li> </ul> <p>Literals may also be specified by using C#-like verbatim forms that interpret <code>\\</code> as a literal character rather than an escape sequence. In a UTF-8-encoded file, you can directly embed the following in a string in the same way as in C#:</p> <ul> <li>Unicode characters, such as \u201c<code>\\u0041bc</code>\u201d</li> <li>Identifiers, as described in the previous section, such as \u201c<code>abc</code>\u201d</li> <li>Trigraph specifications of Unicode characters, such as \u201c<code>\\067</code>\u201d which represents \u201c<code>C</code>\u201d</li> </ul> <pre><code>regexp escape-char = '\\' [\"\\'ntbrafv]\nregexp non-escape-chars = '\\' [^\"\\'ntbrafv]\nregexp simple-char-char =\n    | (any char except '\\n' '\\t' '\\r' '\\b' '\\a' '\\f' '\\v' ' \\ \")\n\nregexp unicodegraph-short = '\\' 'u' hexdigit hexdigit hexdigit hexdigit\nregexp unicodegraph-long =  '\\' 'U' hexdigit hexdigit hexdigit hexdigit\n                                    hexdigit hexdigit hexdigit hexdigit\n\nregexp trigraph = '\\' digit-char digit-char digit-char\n\nregexp char-char =\n    | simple-char-char\n    | escape-char\n    | trigraph\n    | unicodegraph-short\n\nregexp string-char =\n    | simple-string-char\n    | escape-char\n    | non-escape-chars\n    | trigraph\n    | unicodegraph-short\n    | unicodegraph-long\n    | newline\n\nregexp string-elem =\n    | string-char\n    | '\\' newline whitespace * string-elem\n\ntoken char = ' char-char '\ntoken string = \" string-char * \"\n\nregexp verbatim-string-char =\n    | simple-string-char\n    | non-escape-chars\n    | newline\n    | \\\n    | \"\"\n\ntoken verbatim-string = @\" verbatim-string-char * \"\n\ntoken bytechar = ' simple-or-escape-char 'B\ntoken bytearray = \" string-char * \"B\ntoken verbatim-bytearray = @\" verbatim-string-char * \"B\ntoken simple-or-escape-char = escape-char | simple-char\ntoken simple-char = any char except newline,return,tab,backspace,',\\,\"\n\ntoken triple-quoted-string = \"\"\" simple-or-escape-char* \"\"\"\n</code></pre> <p>To translate a string token to a string value, the F# parser concatenates all the Unicode characters for the <code>string-char</code> elements within the string. Strings may include <code>\\n</code> as a newline character. However, if a line ends with <code>\\</code>, the newline character and any leading whitespace elements on the subsequent line are ignored. Thus, the following gives <code>s</code> the value <code>\"abcdef\"</code>:</p> <pre><code>let s = \"abc\\\n    def\"\n</code></pre> <p>Without the backslash, the resulting string includes the newline and whitespace characters. For example:</p> <pre><code>let s = \"abc\n    def\"\n</code></pre> <p>In this case, s has the value <code>abc\\010    def</code> where <code>\\010</code> is the embedded control character for <code>\\n</code>, which has Unicode UTF-16 value 10.</p> <p>Verbatim strings may be specified by using the <code>@</code> symbol preceding the string as in C#. For example, the following assigns the value <code>\"abc\\def\"</code> to <code>s</code>.</p> <pre><code>let s = @\"abc\\def\"\n</code></pre> <p>String-like and character-like literals can also be specified for unsigned byte arrays (type <code>byte[]</code>). These tokens cannot contain Unicode characters that have surrogate-pair UTF-16 encodings or UTF- 16 encodings greater than 127.</p> <p>A triple-quoted string is specified by using three quotation marks (<code>\"\"\"</code>) to ensure that a string that includes one or more escaped strings is interpreted verbatim. For example, a triple-quoted string can be used to embed XML blobs:</p> <pre><code>let catalog = \"\"\"\n&lt;?xml version=\"1.0\"?&gt;\n&lt;catalog&gt;\n    &lt;book id=\"book\"&gt;\n        &lt;author&gt;Author&lt;/author&gt;\n        &lt;title&gt;F#&lt;/title&gt;\n        &lt;genre&gt;Computer&lt;/genre&gt;\n        &lt;price&gt;44.95&lt;/price&gt;\n        &lt;publish_date&gt;2012- 10 - 01&lt;/publish_date&gt;\n        &lt;description&gt;An in-depth look at creating applications in F#&lt;/description&gt;\n    &lt;/book&gt;\n&lt;/catalog&gt;\n\"\"\"\n</code></pre>"},{"location":"lexical-analysis/#36-symbolic-keywords","title":"3.6 Symbolic Keywords","text":"<p>The following symbolic or partially symbolic character sequences are treated as keywords:</p> <pre><code>token symbolic-keyword =\n    let! use! do! yield! return! match!\n    | -&gt; &lt;- . : ( ) [ ] [&lt; &gt;] [| |] { }\n    ' # :?&gt; :? :&gt; .. :: := ;; ; =\n    _? ?? (*) &lt;@ @&gt; &lt;@@ @@&gt;\n</code></pre> <p>The following symbols are reserved for future use:</p> <pre><code>token reserved-symbolic-sequence =\n    ~ `\n</code></pre>"},{"location":"lexical-analysis/#37-symbolic-operators","title":"3.7 Symbolic Operators","text":"<p>User-defined and library-defined symbolic operators are sequences of characters as shown below, except where the sequence of characters is a symbolic keyword (\u00a73.6).</p> <pre><code>regexp first-op-char = !%&amp;*+-./&lt;=&gt;@^|~\nregexp op-char = first-op-char | [?:]\n\ntoken quote-op-left =\n    | &lt;@ &lt;@@\n\ntoken quote-op-right =\n    | @&gt; @@&gt;\n\ntoken symbolic-op =\n    | ?\n    | ?&lt;-\n    | first-op-char op-char *\n    | quote-op-left\n    | quote-op-right\n</code></pre> <p>For example, <code>&amp;&amp;&amp;</code> and <code>|||</code> are valid symbolic operators. Only the operators <code>?</code> and <code>?&lt;-</code> may start with <code>?</code>.</p> <p>The <code>quote-op-left</code> and <code>quote-op-right</code> operators are used in quoted expressions (\u00a76.8).</p> <p>For details about the associativity and precedence of symbolic operators in expression forms, see \u00a74.4.</p>"},{"location":"lexical-analysis/#38-numeric-literals","title":"3.8 Numeric Literals","text":"<p>The lexical specification of numeric literals is as follows:</p> <pre><code>regexp digit = [0-9]\nregexp hexdigit = digit | [A-F] | [a-f]\nregexp octaldigit = [0-7]\nregexp bitdigit = [0-1]\n\nregexp int =\n    | digit+                                     For example, 34\n    | int _ int                                  For example, 123_456_789\n\nregexp hexint =\n    | hexdigit+                                  For example, 1f\n    | hexint _ hexint                            For example, abc_456_78\n\nregexp octalint =\n    | octaldigit+                                For example, 34\n    | octalint _ octalint                        For example, 123_4_711\n\nregexp bitint =\n    | bitdigit+                                  For example, 11\n    | bitint _ bitint                            For example, 1110_0101_0100\n\nregexp xint =\n    | 0 (x|X) hexint                             For example, 0x22_1f\n    | 0 (o|O) octalint                           For example, 0o42\n    | 0 (b|B) bitint                             For example, 0b10010\n\ntoken sbyte = ( int | xint ) 'y'                 For example, 34y\ntoken byte = ( int | xint ) ' uy'                For example, 34uy\ntoken int16 = ( int | xint ) 's'                 For example, 34s\ntoken uint16 = ( int | xint ) 'us'               For example, 34us\ntoken int32 = ( int | xint ) 'l'                 For example, 34l\ntoken uint32 = ( int | xint ) 'ul'               For example, 34ul\n             | ( int | xint ) 'u'                For example, 34u\ntoken nativeint = ( int | xint ) 'n'             For example, 34n\ntoken unativeint = ( int | xint ) 'un'           For example, 34un\ntoken int64 = ( int | xint ) 'L'                 For example, 34L\ntoken uint64 = ( int | xint ) 'UL'               For example, 34UL\n             | ( int | xint ) 'uL'               For example, 34uL\n\ntoken float =\n    int . int?\n    int (. int?)? (e|E) (+|-)? int\n\ntoken ieee32 =\n    | (float | int) [Ff]                         For example, 3.0F, 3.0f or 3f\n    | xint 'lf'                                  For example, 0x00000000lf\ntoken ieee64 =\n    | float                                      For example, 3.0\n    | xint 'LF'                                  For example, 0x0000000000000000LF\n\ntoken bignum = int ('Q' | ' R' | 'Z' | 'I' | 'N' | 'G')\n                                                 For example, 34742626263193832612536171N\n\ntoken decimal = ( float | int ) [Mm]\n</code></pre>"},{"location":"lexical-analysis/#381-post-filtering-of-adjacent-prefix-tokens","title":"3.8.1 Post-filtering of Adjacent Prefix Tokens","text":"<p>Negative integers are specified using the <code>\u2013</code> token; for example, <code>-3</code>. The token steam is post-filtered according to the following rules:</p> <ul> <li>If the token stream contains the adjacent tokens <code>\u2013 token</code>:</li> </ul> <p>If <code>token</code> is a constant numeric literal, the pair of tokens is merged. For example, adjacent tokens   <code>-</code> and <code>3</code> becomes the single token <code>-3</code>. Otherwise, the tokens remain separate. However the <code>-</code>   token is marked as an <code>ADJACENT_PREFIX_OP</code> token.</p> <p>This rule does not apply to the sequence <code>token1 - token2</code>, if all three tokens are adjacent and   <code>token1</code> is a terminating token from expression forms that have lower precedence than the   grammar production <code>expr = MINUS expr</code>.</p> <p>For example, the <code>\u2013</code> and <code>b</code> tokens in the following sequence are not merged if all three tokens   are adjacent:</p> <pre><code>    a-b\n</code></pre> <ul> <li>Otherwise, the usual grammar rules apply to the uses of <code>\u2013</code> and <code>+</code>, with an addition for   <code>ADJACENT_PREFIX_OP</code>:</li> </ul> <pre><code>  expr = expr MINUS expr\n      | MINUS expr\n      | ADJACENT_PREFIX_OP expr\n</code></pre>"},{"location":"lexical-analysis/#382-post-filtering-of-integers-followed-by-adjacent","title":"3.8.2 Post-filtering of Integers Followed by Adjacent \u201c..\u201d","text":"<p>Tokens of the form</p> <pre><code>token intdotdot = int..\n</code></pre> <p>such as <code>34..</code> are post-filtered to two tokens: one <code>int</code> and one <code>symbolic-keyword</code> , \u201c<code>..</code>\u201d.</p> <p>This rule allows \u201c<code>..</code>\u201d to immediately follow an integer. This construction is used in expressions of the form <code>[for x in 1..2 -&gt; x + x ]</code>. Without this rule, the longest-match rule would consider this sequence to be a floating-point number followed by a \u201c<code>.</code>\u201d.</p>"},{"location":"lexical-analysis/#383-reserved-numeric-literal-forms","title":"3.8.3 Reserved Numeric Literal Forms","text":"<p>The following token forms are reserved for future numeric literal formats:</p> <pre><code>token reserved-literal-formats =\n    | (xint | ieee32 | ieee64) ident-char+\n</code></pre>"},{"location":"lexical-analysis/#384-shebang","title":"3.8.4 Shebang","text":"<p>A shebang (#!) directive may exist at the beginning of F# source files. Such a line is treated as a comment. This allows F# scripts to be compatible with the Unix convention whereby a script indicates the interpreter to use by providing the path to that interpreter on the first line, following the #! directive.</p> <pre><code>#!/bin/usr/env fsharpi --exec\n</code></pre>"},{"location":"lexical-analysis/#39-line-directives","title":"3.9 Line Directives","text":"<p>Line directives adjust the source code filenames and line numbers that are reported in error messages, recorded in debugging symbols, and propagated to quoted expressions. F# supports the following line directives:</p> <pre><code>token line-directive =\n    # int\n    # int string\n    # int verbatim-string\n    #line int\n    #line int string\n    #line int verbatim-string\n</code></pre> <p>A line directive applies to the line that immediately follows the directive. If no line directive is present, the first line of a file is numbered 1.</p>"},{"location":"lexical-analysis/#310-hidden-tokens","title":"3.10 Hidden Tokens","text":"<p>Some hidden tokens are inserted by lexical filtering (\u00a7 15 ) or are used to replace existing tokens. See \u00a7 15 for a full specification and for the augmented grammar rules that take these into account.</p>"},{"location":"lexical-analysis/#311-identifier-replacements","title":"3.11 Identifier Replacements","text":"<p>The following table lists identifiers that are automatically replaced by expressions.</p> Identifier Replacement <code>__SOURCE_DIRECTORY__</code> A literal verbatim string that specifies the name of the directory that contains the  current file. For example:<code>C:\\source</code>The name of the current file is derived from the most recent line directive in the file. If no line directive has appeared, the name is derived from the name that was specificed to the command-line compiler in combination with <code>System.IO.Path.GetFullPath</code>. In F# Interactive, the name <code>stdin</code> is used. When F# Interactive is used from tools such as Visual Studio, a line directive is implicitly added before the interactive execution of each script fragment. <code>__SOURCE_FILE__</code> A literal verbatim string that contains the name of the current file. For example:<code>file.fs</code> <code>__LINE__</code> A literal string that specifies the line number in the source file, after taking into account adjustments from line directives."},{"location":"lexical-filtering/","title":"15. Lexical Filtering","text":""},{"location":"lexical-filtering/#151-lightweight-syntax","title":"15.1 Lightweight Syntax","text":"<p>F# supports lightweight syntax, in which whitespace makes indentation significant.</p> <p>The lightweight syntax option is a conservative extension of the explicit language syntax, in the sense that it simply lets you leave out certain tokens such as <code>in</code> and <code>;;</code> because the parser takes indentation into account. Indentation can make a surprising difference in the readability of code. Compiling your code with the indentation-aware syntax option is useful even if you continue to use explicit tokens, because the compiler reports many indentation problems with your code and ensures a regular, clear formatting style.</p> <p>In the processing of lightweight syntax, comments are considered pure whitespace. This means that the compiler ignores the indentation position of comments. Comments act as if they were replaced by whitespace characters. Tab characters cannot be used in F# files.</p>"},{"location":"lexical-filtering/#1511-basic-lightweight-syntax-rules-by-example","title":"15.1.1 Basic Lightweight Syntax Rules by Example","text":"<p>The basic rules that the F# compiler applies when it processes lightweight syntax are shown below, illustrated by example.</p>"},{"location":"lexical-filtering/#15111-delimiter","title":"15.1.1.1 ;; delimiter","text":"<p>When the lightweight syntax option is enabled, top level expressions do not require the <code>;;</code> delimiter because every construct that starts in the first column is implicitly a new declaration. The <code>;;</code> delimiter is still required to terminate interactive entries to fsi.exe, but not when using F# Interactive from Visual Studio.</p> <p>Lightweight Syntax</p> <pre><code>printf \"Hello\"\nprintf \"World\"\n</code></pre> <p>Normal Syntax</p> <pre><code>printf \"Hello\";;\nprintf \"World\";;\n</code></pre>"},{"location":"lexical-filtering/#15112-in-keyword","title":"15.1.1.2 in keyword","text":"<p>When the lightweight syntax option is enabled, the <code>in</code> keyword is optional. The token after the <code>=</code> in a <code>let</code> definition begins a new block, and the pre-parser inserts an implicit separating <code>in</code> token between each definition that begins at the same column as that token.</p> <p>Lightweight Syntax</p> <pre><code>let SimpleSample() =\n    let x = 10 + 12 - 3\n    let y = x * 2 + 1\n    let r1,r2 = x/3, x%3\n    (x,y,r1,r2)\n</code></pre> <p>Normal Syntax</p> <pre><code>#indent \"off\"\nlet SimpleSample() =\n    let x = 10 + 12 - 3 in\n    let y = x * 2 + 1 in\n    let r1,r2 = x/3, x%3 in\n    (x,y,r1,r2)\n</code></pre>"},{"location":"lexical-filtering/#15113-done-keyword","title":"15.1.1.3 done keyword","text":"<p>When the lightweight syntax option is enabled, the <code>done</code> keyword is optional. Indentation establishes the scope of structured constructs such as <code>match</code>, <code>for</code>, <code>while</code> and <code>if</code>/<code>then</code>/<code>else</code>.</p> <p>Lightweight Syntax</p> <pre><code>let FunctionSample() =\n    let tick x = printfn \"tick %d\" x\n    let tock x = printfn \"tock %d\" x\n    let choose f g h x =\n        if f x then g x else h x\n    for i = 0 to 10 do\n        choose (fun n -&gt; n%2 = 0) tick tock i\n    printfn \"done!\"\n</code></pre> <p>Normal Syntax</p> <pre><code>#indent \"off\"\nlet FunctionSample() =\n    let tick x = printfn \"tick %d\" x in\n    let tock x = printfn \"tock %d\" x in\n    let choose f g h x =\n        if f x then g x else h x in\n    for i = 0 to 10 do\n        choose (fun n -&gt; n%2 = 0) tick tock i\n    done;\n    printfn \"done!\"\n</code></pre>"},{"location":"lexical-filtering/#15114-if-then-else-scope","title":"15.1.1.4 if / then / else Scope","text":"<p>When the lightweight syntax option is enabled, the scope of <code>if</code>/<code>then</code>/<code>else</code> is implicit from indentation. Without the lightweight syntax option, <code>begin</code>/<code>end</code> or parentheses are often required to delimit such constructs.</p> <p>Lightweight Syntax</p> <pre><code>let ArraySample() =\n    let numLetters = 26\n    let results = Array.create numLetters 0\n    let data = \"The quick brown fox\"\n    for i = 0 to data.Length - 1 do\n        let c = data.Chars(i)\n        let c = Char.ToUpper(c)\n        if c &gt;= 'A' &amp;&amp; c &lt;= 'Z' then\n            let i = Char.code c - Char.code 'A'\n            results.[i] &lt;- results.[i] + 1\n    printfn \"done!\"\n</code></pre> <p>Normal Syntax</p> <pre><code>#indent \"off\"\nlet ArraySample() =\n    let numLetters = 26 in\n    let results = Array.create numLetters 0 in\n    let data = \"The quick brown fox\" in\n    for i = 0 to data.Length - 1 do\n        let c = data.Chars(i) in\n        let c = Char.ToUpper(c) in\n        if c &gt;= 'A' &amp;&amp; c &lt;= 'Z' then begin\n            let i = Char.code c - Char.code 'A' in\n            results.[i] &lt;- results.[i] + 1\n        end\n    done;\n    printfn \"done!\"\n</code></pre>"},{"location":"lexical-filtering/#1512-inserted-tokens","title":"15.1.2 Inserted Tokens","text":"<p>Lexical filtering inserts the following hidden tokens :</p> <pre><code>token $in       // Note: also called ODECLEND\ntoken $done     // Note: also called ODECLEND\ntoken $begin    // Note: also called OBLOCKBEGIN\ntoken $end      // Note: also called OEND, OBLOCKEND and ORIGHT_BLOCK_END\ntoken $sep      // Note: also called OBLOCKSEP\ntoken $app      // Note: also called HIGH_PRECEDENCE_APP\ntoken $tyapp    // Note: also called HIGH_PRECEDENCE_TYAPP\n</code></pre> <p>Note: The following tokens are also used in the Microsoft F# implementation. They are translations of the corresponding input tokens and help provide better error messages for lightweight syntax code: <code>tokens $let $use $let! $use! $do $do! $then $else $with $function $fun</code></p>"},{"location":"lexical-filtering/#1513-grammar-rules-including-inserted-tokens","title":"15.1.3 Grammar Rules Including Inserted Tokens","text":"<p>Additional grammar rules take into account the token transformations performed by lexical filtering:</p> <pre><code>expr +:=\n    | let function-defn $ in expr\n    | let value-defn $ in expr\n    | let rec function-or-value-defns $ in expr\n    | while expr do expr $done\n    | if expr then $begin expr $end\n    | for pat in expr do expr $done\n    | for expr to expr do expr $done\n    | try expr $end with expr $done\n    | try expr $end finally expr $done\n\n    | expr $app expr            // equivalent to \" expr ( expr )\"\n    | expr $sep expr            // equivalent to \" expr ; expr \"\n    | expr $tyapp &lt; types &gt;     // equivalent to \" expr &lt; types &gt;\"\n    | $begin expr $end          // equivalent to \u201c expr \u201d\n\nelif-branch +:=\n    | elif expr then $begin expr $end\n\nelse-branch +:=\n    | else $begin expr $end\n\nclass-or-struct-type-body +:=\n    | $begin class-or-struct-type-body $end\n                                // equivalent to class-or-struct-type-body\n\nmodule-elems +:=\n    | $begin module-elem ... module-elem $end\n\nmodule-abbrev +:=\n    | module ident = $begin long-ident $end\n\nmodule-defn +:=\n    | module ident = $begin module-defn-body $end\n\nmodule-signature-elements +:=\n    | $begin module-signature-element ... module-signature-element $end\n\nmodule-signature +:=\n    | module ident = $begin module-signature-body $end\n</code></pre>"},{"location":"lexical-filtering/#1514-offside-lines","title":"15.1.4 Offside Lines","text":"<p>Lightweight syntax is sometimes called the \u201coffside rule\u201d. In F# code, offside lines occur at column positions. For example, an <code>=</code> token associated with <code>let</code> introduces an offside line at the column of the first non-whitespace token after the <code>=</code> token.</p> <p>Other structured constructs also introduce offside lines at the following places:</p> <ul> <li>The column of the first token after <code>then</code> in an <code>if</code>/<code>then</code>/<code>else</code> construct.</li> <li>The column of the first token after <code>try</code>, <code>else</code>, <code>-&gt;</code>, <code>with</code> (in a <code>match</code>/<code>with</code> or <code>try</code>/<code>with</code>), or <code>with</code> (in a     type extension).</li> <li>The column of the first token of a <code>(</code>, <code>{</code> or <code>begin</code> token.</li> <li>The start of a <code>let</code>, if or <code>module</code> token.</li> </ul> <p>Here are some examples of how the offside rule applies to F# code. In the first example, <code>let</code> and <code>type</code> declarations are not properly aligned, which causes F# to generate a warning.</p> <pre><code>// \"let\" and \"type\" declarations in\n// modules must be precisely aligned.\nlet x = 1\n let y = 2   // unmatched 'let'\nlet z = 3    // warning FS0058: possible\n             // incorrect indentation: this token is offside of\n             // context at position (2:1)\n</code></pre> <p>In the second example, the <code>|</code> markers in the match patterns do not align properly:</p> <pre><code>// The \"|\" markers in patterns must align.\n// The first \"|\" should always be inserted.\nlet f () =\n    match 1+1 with\n    | 2 -&gt; printf \"ok\"\n  | _ -&gt; failwith \"no!\"     // syntax error\n</code></pre>"},{"location":"lexical-filtering/#1515-the-pre-parse-stack","title":"15.1.5 The Pre-Parse Stack","text":"<p>F# implements the lightweight syntax option by preparsing the token stream that results from a lexical analysis of the input text according to the lexical rules in \u00a715.1.3. Pre-parsing for lightweight syntax uses a stack of contexts.</p> <ul> <li>When a column position becomes an offside line, a context is pushed.</li> <li>The closing bracketing tokens <code>)</code>, <code>}</code>, and <code>end</code> terminate offside contexts up to and including the     context that the corresponding opening token introduced.</li> </ul>"},{"location":"lexical-filtering/#1516-full-list-of-offside-contexts","title":"15.1.6 Full List of Offside Contexts","text":"<p>This section describes the full list of offside contexts that is kept on the pre-parse stack.</p> <p>The SeqBlock context is the primary context of the analysis.It indicates a sequence of items that must be column-aligned. Where necessary for parsing, the compiler automatically inserts a delimiter that replaces the regular <code>in</code> and <code>;</code> tokens between the syntax elements. The SeqBlock context is pushed at the following times:</p> <ul> <li>Immediately after the start of a file, excluding lexical directives such as <code>#if</code>.</li> <li>Immediately after an = token is encountered in a Let or Member context.</li> <li>Immediately after a Paren , Then , Else , WithAugment, Try , Finally , Do context is pushed.</li> <li>Immediately after an infix token is encountered.</li> <li>Immediately after a -&gt; token is encountered in a MatchClauses context.</li> <li>Immediately after an <code>interface</code>, <code>class</code>, or <code>struct</code> token is encountered in a type declaration.</li> <li>Immediately after an <code>=</code> token is encountered in a record expression when the subsequent token     either (a) occurs on the next line or (b) is one of try , match , if , let , for , while or use.</li> <li>Immediately after a <code>&lt;-</code> token is encoutered when the subsequent token either (a) does not occur     on the same line or (b) is one of try , match , if , let , for , while or use.</li> </ul> <p>Here \u201cimmediately after\u201d refers to the fact that the column position associated with the SeqBlock is the first token following the significant token.</p> <p>In the last two rules, a new line is significant. For example, the following do not start a SeqBlock on the right-hand side of the \u201c&lt;-\u201c token, so it does not parse correctly:</p> <pre><code>let mutable x = 1\n// The subsequent token occurs on the same line.\nX &lt;- printfn \"hello\"\n    2 + 2\n</code></pre> <p>To start a SeqBlock on the right, either parentheses or a new line should be used:</p> <pre><code>// The subsequent token does not occur on the same line, so a SeqBlock is pushed.\nX &lt;-\n    printfn \"hello\"\n    2 + 2\n</code></pre> <p>The following contexts are associated with nested constructs that are introduced by the specified keywords:</p> Context Pushed when the token stream contains... Let The <code>let</code> keyword If The <code>if</code> or <code>elif</code> keyword Try The <code>try</code> keyword Lazy The <code>lazy</code> keyword Fun The <code>fun</code> keyword Function The <code>function</code> keyword WithLet The <code>with</code> keyword as part of a record expression or an object expression whose members use the syntax <code>{ new Foo with M() = 1 and N() = 2 }</code> WithAugment The <code>with</code> keyword as part of an extension, interface, or object expression whose members use the syntax <code>{ new Foo member x.M() = 1 member x. N() = 2 }</code> Match the <code>match</code> keyword For the <code>for</code> keyword While The <code>while</code> keyword Then The <code>then</code> keyword Else The <code>else</code> keyword Do The <code>do</code> keyword Type The <code>type</code> keyword Namespace The <code>namespace</code> keyword Module The <code>module</code> keyword Member The <code>member</code>, <code>abstract</code>, <code>default</code>, or <code>override</code> keyword, if the Member context is not already active, because multiple tokens may be present.- or -<code>(</code> is the next token after the <code>new</code> keyword. This distinguishes the member declaration <code>new(x) = ... from the expression new x()</code> Paren(token) <code>(</code>, <code>begin</code>, <code>struct</code>, <code>sig</code>, <code>{</code>, <code>[</code>, <code>[\\|</code>, or <code>quote-op-left</code> MatchClauses The <code>with</code> keyword in a Try or Match context immediately after a <code>function</code> keyword. Vanilla An otherwise unprocessed keyword in a SeqBlock context."},{"location":"lexical-filtering/#1517-balancing-rules","title":"15.1.7 Balancing Rules","text":"<p>When the compiler processes certain tokens, it pops contexts off the offside stack until the stack reaches a particular condition. When it pops a context, the compiler may insert extra tokens to indicate the end of the construct. This procedure is called balancing the stack.</p> <p>The following table lists the contexts that the compiler pops and the balancing condition for each:</p> Token Contexts Popped and Balancing Conditions: <code>End</code> Enclosing context is one of the following: <code>WithAugment</code> <code>Paren(interface)</code> <code>Paren(class)</code> <code>Paren(sig)</code> <code>Paren(struct)</code> <code>Paren(begin)</code> <code>;;</code> Pop all contexts from stack <code>else</code> <code>If</code> <code>elif</code> <code>If</code> <code>done</code> <code>Do</code> <code>in</code> <code>For</code> or <code>Let</code> <code>with</code> <code>Match</code>, <code>Member</code>, <code>Interface</code>, <code>Try</code>, <code>Type</code> <code>finally</code> <code>Try</code> <code>)</code> <code>Paren(()</code> <code>}</code> <code>Paren({)</code> <code>]</code> <code>Paren([)</code> <code>\\|]</code> <code>Paren([\\|)</code> <code>quote-op-right</code> <code>Paren(quote-op-left)</code>"},{"location":"lexical-filtering/#1518-offside-tokens-token-insertions-and-closing-contexts","title":"15.1.8 Offside Tokens, Token Insertions, and Closing Contexts","text":"<p>The offside limit for the current offside stack is the rightmost offside line for the offside contexts on the context stack. The following example shows the offside limits:</p> <pre><code>let FunctionSample() =\n    let tick x = printfn \"tick %d\" x\n    let tock x = printfn \"tock %d\" x\n    let choose f g h x =\n        if f x then g x else h x\n    for i = 0 to 10 do\n        choose (fun n - &gt; n% 2 = 0 ) tick tock i\n    printfn \"done!\"\n//      ^ Offside limit for inner `let` and `for` contexts\n//  ^ Offside limit for outer `let` context\n</code></pre> <p>When a token occurs on or before the offside limit for the current offside stack, and a permitted undentation does not apply, enclosing contexts are closed until the token is no longer offside. This may result in the insertion of extra delimiting tokens.</p> <p>Contexts are closed as follows:</p> <ul> <li>When a Fun context is closed, the <code>$end</code> token is inserted.</li> <li>When a SeqBlock , MatchClauses , Let , or Do context is closed, the <code>$end</code> token is inserted, with the     exception of the first SeqBlock pushed for the start of the file.</li> <li>When a While or For context is closed, and the offside token that forced the close is not <code>done</code>,     the <code>$done</code> token is inserted.</li> <li>When a Member context is closed, the <code>$end</code> token is inserted.</li> <li>When a WithAugment context is closed, the <code>$end</code> token is inserted.</li> </ul> <p>If a token is offside and a context cannot be closed, then an \u201cundentation\u201d warning or error is issued to indicate that the construct is badly formatted.</p> <p>Tokens are also inserted in the following situations:</p> <ul> <li>When a SeqBlock context is pushed, the <code>$begin</code> token is inserted, with the exception of the first     SeqBlock pushed for the start of the file.</li> <li>When a token other than <code>and</code> appears directly on the offside line of Let context, and the next     surrounding context is a SeqBlock , the <code>$in</code> token is inserted.</li> <li> <p>When a token occurs directly on the offside line of a SeqBlock on the second or subsequent lines     of the block, the <code>$sep</code> token is inserted. This token plays the same role as <code>;</code> in the grammar rules.     For example, consider this source text:</p> <pre><code>   let x = 1\n   x\n</code></pre> </li> </ul> <p>The raw token stream contains <code>let</code>, <code>x</code>, <code>=</code>, <code>1</code>, <code>x</code> and the end-of-file marker <code>eof</code>. An initial SeqBlock is pushed immediately after the start of the file, at the first token in the file, with an offside line on column 0. The <code>let</code> token pushes a Let context. The <code>=</code> token in a Let context pushes a SeqBlock context and inserts a <code>$begin</code> token. The <code>1</code> pushes a Vanilla context. The final token, <code>x</code>, is offside from the Vanilla context, which pops that context. It is also offside from the SeqBlock context, which pops the context and inserts <code>$end</code>. It is also offside from the Let context, which inserts another <code>$end</code> token. It is directly aligned with the SeqBlock context, so a <code>$seq</code> token is inserted.</p>"},{"location":"lexical-filtering/#1519-exceptions-to-the-offside-rules","title":"15.1.9 Exceptions to the Offside Rules","text":"<p>The compiler makes some exceptions to the offside rules when it analyzes a token to determine whether it is offside from the current context.</p> <ul> <li> <p>In a SeqBlock context, an infix token may be offside by the size of the token plus one.</p> <pre><code>let x =\n        expr + expr\n      + expr + expr\nlet x =\n        expr\n     |&gt; f expr\n     |&gt; f expr\n</code></pre> </li> <li> <p>In a SeqBlock context, an infix token may align precisely with the offside line of the SeqBlock.</p> <p>In the following example, the infix <code>|&gt;</code> token that begins the last line is not considered as a new element in the sequence block on the right-hand side of the definition. The same also applies to <code>end</code>, <code>and</code>, <code>with</code>, <code>then</code>, and <code>right-parenthesis</code> operators.</p> <pre><code>let someFunction(someCollection) =\n    someCollection\n    |&gt; List.map (fun x -&gt; x + 1)\n</code></pre> <p>In the example below, the first <code>)</code> token does not indicate a new element in a sequence of items, even though it aligns precisely with the sequence block that starts at the beginning of the argument list.</p> <pre><code>new MenuItem(\"&amp;Open...\",\n  new EventHandler(fun _ _ -&gt;\n                           // ...\n             ))\n</code></pre> </li> <li> <p>In a Let context, the <code>and</code> token may align precisely with the <code>let</code> keyword.</p> <pre><code>let rec x = 1\nand y = 2\nx + y\n</code></pre> </li> <li> <p>In a Type context, the <code>}</code>, <code>end</code>, <code>and</code>, and <code>|</code> tokens may align precisely with the <code>type</code> keyword.</p> <pre><code>type X =\n| A\n| B\nwith\n    member x.Seven = 21 / 3\nend\nand Y = {\n    x : int\n}\nand Z() = class\n    member x.Eight = 4 + 4\nend\n</code></pre> </li> <li> <p>In a For context, the <code>done</code> token may align precisely with the <code>for</code> keyword.</p> <pre><code>for i = 1 to 3 do\n    expr\ndone\n</code></pre> </li> <li> <p>In a Match context, on the right-hand side of an arrow for a match expression, a token may align precisely with the <code>match</code> keyword. This exception allows the last expression to align with the <code>match</code>, so that a long series of matches does not increase indentation.</p> <pre><code>match x with\n| Some(_) -&gt; 1\n| None -&gt;\nmatch y with\n| Some(_) -&gt; 2\n| None -&gt;\n3\n</code></pre> </li> <li> <p>In an Interface context, the <code>end</code> token may align precisely with the <code>interface</code> keyword.</p> <pre><code>interface IDisposable with\n    member x.Dispose() = printfn disposing!\"\nend\n</code></pre> </li> <li> <p>In an If context, the <code>then</code>, <code>elif</code>, and <code>else</code> tokens may align precisely with the <code>if</code> keyword.</p> <pre><code>if big\nthen callSomeFunction()\nelif small\nthen callSomeOtherFunction()\nelse doSomeCleanup()\n</code></pre> </li> <li> <p>In a Try context, the <code>finally</code> and <code>with</code> tokens may align precisely with the <code>try</code> keyword.</p> <p>Example 1:</p> <pre><code>try\n    callSomeFunction()\nfinally\n    doSomeCleanup()\n</code></pre> <p>Example 2:</p> <pre><code>try\n    callSomeFunction()\nwith Failure(s) -&gt;\n    doSomeCleanup()\n</code></pre> </li> <li> <p>In a Do context, the <code>done</code> token may align precisely with the <code>do</code> keyword.</p> <pre><code>for i = 1 to 3\n    do\n        expr\n    done\n</code></pre> </li> </ul>"},{"location":"lexical-filtering/#15110-permitted-undentations","title":"15.1.10 Permitted Undentations","text":"<p>As a general rule, incremental indentation requires that nested expressions occur at increasing column positions in indentation-aware code. Warnings or syntax errors are issued when this is not the case. However, undentation is permitted for the following constructs:</p> <ul> <li>Bodies of function expressions</li> <li>Branches of if/then/else expressions</li> <li>Bodies of modules and module types</li> </ul>"},{"location":"lexical-filtering/#151101-undentation-of-bodies-of-function-expressions","title":"15.1.10.1 Undentation of Bodies of Function Expressions","text":"<p>The bodies of functions may be undented from the <code>fun</code> or <code>function</code> symbol. As a result, the compiler ignores the symbol when determining whether the body of the function satisfies the incremental indentation rule. For example, the <code>printf</code> expression in the following example is undented from the fun symbol that delimits the function definition:</p> <pre><code>let HashSample(tab: Collections.HashTable&lt;_,_&gt;) =\n    tab.Iterate (fun c v -&gt;\n        printfn \"Entry (%O,%O)\" c v)\n</code></pre> <p>However, the block must not undent past other offside lines. The following is not permitted because the second line breaks the offside line established by the <code>=</code> in the first line:</p> <pre><code>let x = (function (s, n) -&gt;\n    (fun z -&gt;\n        s+n+z))\n</code></pre> <p>Constructs enclosed in brackets may be undented.</p>"},{"location":"lexical-filtering/#151102-undentation-of-branches-of-ifthenelse-expressions","title":"15.1.10.2 Undentation of Branches of If/Then/Else Expressions","text":"<p>The body of a <code>(</code> ... <code>)</code> or <code>begin</code> ... <code>end</code> block in an <code>if</code>/<code>then</code>/<code>else</code> expression may be undented when the body of the block follows the <code>then</code> or <code>else</code> keyword but may not undent further than the <code>if</code> keyword. In this example, the parenthesized block follows <code>then</code>, so the body can be undented to the offside line established by <code>if</code>:</p> <pre><code>let IfSample(day: System.DayOfWeek) =\n    if day = System.DayOfWeek.Monday then (\n        printf \"I don't like Mondays\"\n    )\n</code></pre>"},{"location":"lexical-filtering/#151103-undentation-of-bodies-of-modules-and-module-types","title":"15.1.10.3 Undentation of Bodies of Modules and Module Types","text":"<p>The bodies of modules and module types that are delimited by <code>begin</code> and <code>end</code> may be undented. For example, in the following example the two let statements that comprise the module body are undented from the <code>=</code>.</p> <pre><code>module MyNestedModule = begin\n    let one = 1\n    let two = 2\nend\n</code></pre> <p>Similarly, the bodies of classes, interfaces, and structs delimited by <code>{</code> ... <code>}</code>, <code>class</code> ... <code>end</code>, <code>struct</code> ... <code>end</code>, or <code>interface</code> ... <code>end</code> may be undented to the offside line established by the <code>type</code> keyword. For example:</p> <pre><code>type MyNestedModule = interface\n    abstract P : int\nend\n</code></pre>"},{"location":"lexical-filtering/#151104-undentation-of-bodies-of-collection-and-computation-expressions","title":"15.1.10.4 Undentation of Bodies of Collection and Computation Expressions","text":"<p>The bodies of collection and computation expressions delimited by <code>[</code> ... <code>]</code>,  <code>[|</code> ... <code>|]</code>, <code>seq {</code> ... <code>}</code>, <code>anyBuilder {</code> ... <code>}</code> may be undented to the offside line established by the enclosing expression, specifically ignoring the SeqBlock introduced by <code>(</code> or <code>=</code>.</p> <pre><code>Class.Method(seq {\n    ...\n})\n\nClass.Method(Array.ofSeq (seq {\n    ...\n}))\n\nClass.Method(arg1=expr1, arg2=expr2, seq {\n    ...\n})\n\nClass.Method [\n    ...\n]\n\nClass.Method([|\n    ...\n|])\n\nClass.Method(Array.ofList [\n    ...\n])\n\nClass.Method(arg1=expr1, arg2=expr2, [\n    ...\n])\n</code></pre> <p>In each of these cases the offside line of <code>Class.Method</code> defines the undentation permitted after <code>seq {</code>, <code>[</code>, and <code>[|</code>.</p>"},{"location":"lexical-filtering/#152-high-precedence-application","title":"15.2 High Precedence Application","text":"<p>The entry <code>f x</code> in the precedence table in \u00a74.4.2 refers to a function application in which the function and argument are separated by spaces. The entry <code>\"f(x)\"</code> indicates that in expressions and patterns, identifiers that are followed immediately by a left parenthesis without intervening whitespace form a \u201chigh precedence\u201d application. Such expressions are parsed with higher precedence than prefix and dot-notation operators. Conceptually this means that</p> <pre><code>B(e)\n</code></pre> <p>is analyzed lexically as</p> <pre><code>B $app (e)\n</code></pre> <p>where <code>$app</code> is an internal symbol inserted by lexical analysis. We do not show this symbol in the remainder of this specification and simply show the original source text.</p> <p>This means that the following two statements</p> <pre><code>B(e).C\nB (e).C\n</code></pre> <p>are parsed as</p> <pre><code>(B(e)).C\nB ((e).C)\n</code></pre> <p>respectively.</p> <p>Furthermore, arbitrary chains of method applications, property lookups, indexer lookups (<code>.[]</code>), field lookups, and function applications can be used in sequence if the arguments of method applications are parenthesized and immediately follow the method name, with no intervening spaces. For example:</p> <pre><code>e.Meth1(arg1,arg2).Prop1.[3].Prop2.Meth2()\n</code></pre> <p>Although the grammar and these precedence rules technically allow the use of high-precedence application expressions as direct arguments, an additional check prevents such use. Instead, such expressions must be surrounded by parentheses. For example,</p> <pre><code>f e.Meth1(arg1,arg2) e.Meth2(arg1,arg2)\n</code></pre> <p>must be written</p> <pre><code>f (e.Meth1(arg1,arg2)) (e.Meth2(arg1,arg2))\n</code></pre> <p>However, indexer, field, and property dot-notation lookups may be used as arguments without adding parentheses. For example:</p> <pre><code>f e.Prop1 e.Prop2.[3]\n</code></pre>"},{"location":"lexical-filtering/#153-lexical-analysis-of-type-applications","title":"15.3 Lexical Analysis of Type Applications","text":"<p>The entry <code>f&lt;types&gt; x</code> in the precedence table (\u00a74.4.2) refers to any identifier that is followed immediately by a <code>&lt;</code> symbol and a sequence of all of the following:</p> <ul> <li><code>_</code>, <code>,</code>, <code>*</code>, <code>'</code>, <code>[</code>, <code>]</code>, whitespace, or identifier tokens.</li> <li>A parentheses <code>(</code> or <code>&lt;</code> token followed by any tokens until a matching parentheses <code>)</code> or <code>&gt;</code> is     encountered.</li> <li>A final <code>&gt;</code> token.</li> </ul> <p>During this analysis, any token that is composed only of the <code>&gt;</code> character (such as <code>&gt;</code>, <code>&gt;&gt;</code>, or <code>&gt;&gt;&gt;</code>) is treated as a series of individual <code>&gt;</code> tokens. Likewise, any token composed only of <code>&gt;</code> characters followed by a period (such as <code>&gt;.</code>, <code>&gt;&gt;.</code>, or <code>&gt;&gt;&gt;.</code>) is treated as a series of individual &gt; tokens followed by a period.</p> <p>If such a sequence of tokens follows an identifier, lexical analysis marks the construct as a high precedence type application and subsequent grammar rules ensure that the enclosed text is parsed as a type. Conceptually this means that</p> <pre><code>B&lt;int&gt;.C&lt;int&gt;(e).C\n</code></pre> <p>is returned as the following stream of tokens:</p> <pre><code>B $app &lt;int&gt; .C $app &lt;int&gt;(e).C\n</code></pre> <p>where <code>$app</code> is an internal symbol inserted by lexical analysis. We do not show this symbol elsewhere in this specification and simply show the original source text.</p> <p>The lexical analysis of type applications does not apply to the character sequence \u201c<code>&lt;&gt;</code>\u201d. A character sequence such as \u201c<code>&lt; &gt;</code>\u201d with intervening whitespace should be used to indicate an empty list of generic arguments.</p> <pre><code>type Foo() =\n    member this.Value = 1\nlet b = new Foo&lt; &gt;() // valid\nlet c = new Foo&lt;&gt;() // invalid\n</code></pre>"},{"location":"namespace-and-module-signatures/","title":"11. Namespace and Module Signatures","text":"<p>A signature file contains one or more namespace or module signatures, and specifies the functionality that is implemented by its corresponding implementation file. It also can hide functionality that the corresponding implementation file contains.</p> <pre><code>namespace-decl-group-signature :=\n    namespace long-ident module-signature-elements\n\nmodule-signature :=\n    module ident = module-signature-body\n\nmodule-signature-element :=\n    val mutable~opt curried-sig     -- value signature\n    val value-defn                  -- literal value signature\n    type type-signatures            -- type(s) signature\n    exception exception-signature   -- exception signature\n    module-signature                -- submodule signature\n    module-abbrev                   -- local alias for a module\n    import-decl                     -- locally import contents of a module\n\nmodule-signature-elements := module-signature-element ... module-signature-element\n\nmodule-signature-body :=\n    begin module-signature-elements end\n\ntype-signature :=\n    abbrev-type-signature\n    record-type-signature\n    union-type-signature\n    anon-type-signature\n    class-type-signature\n    struct-type-signature\n    interface-type-signature\n    enum-type-signature\n    delegate-type-signature\n    type-extension-signature\n\ntype-signatures := type-signature ... and ... type-signature\n\ntype-signature-element :=\n    attributesopt access~opt new : uncurried-sig        -- constructor signature\n    attributesopt member acces~opt member-sig           -- member signature\n    attributesopt abstract access~opt member-sig        -- member signature\n    attributesopt override member-sig                   -- member signature\n    attributesopt default member-sig                    -- member signature\n    attributes~opt static member access~opt member-sig  -- static member signature\n    interface type                                      -- interface signature\n\nabbrev-type-signature := type-name '=' type\n\nunion-type-signature := type-name '=' union-type-cases type-extension-elements-\n    signature~opt\n\nrecord-type-signature := type-name '=' '{' record-fields '}' type-extension-\n    elements-signature~opt\n\nanon-type-signature := type-name '=' begin type-elements-signature end\n\nclass-type-signature := type-name '=' class type-elements-signature end\n\nstruct-type-signature := type-name '=' struct type-elements-signature end\n\ninterface-type-signature := type-name '=' interface type-elements-signature end\n\nenum-type-signature := type-name ' =' enum-type-cases\n\ndelegate-type-signature := type-name ' =' delegate-sig\n\ntype-extension-signature := type-name type-extension-elements-signature\n\ntype-extension-elements-signature := with type-elements-signature end\n</code></pre> <p>The <code>begin</code> and <code>end</code> tokens are optional when lightweight syntax is used.</p> <p>Like module declarations, signature declarations are processed sequentially rather than simultaneously, so that later signature declarations are not in scope when earlier ones are processed.</p> <pre><code>namespace Utilities.Part1\n\n    module Module1 =\n        val x : Utilities.Part2.StorageCache // error (Part2 not yet declared)\n\nnamespace Utilities.Part2\n\n    type StorageCache =\n        new : unit -&gt; unit\n</code></pre>"},{"location":"namespace-and-module-signatures/#111-signature-elements","title":"11.1 Signature Elements","text":"<p>A namespace or module signature declares one or more value signatures and one or more type definition signatures. A type definition signature may include one or more member signatures , in addition to other elements of type definitions that are specified in the signature grammar at the start of this chapter.</p>"},{"location":"namespace-and-module-signatures/#1111-value-signatures","title":"11.1.1 Value Signatures","text":"<p>A value signature indicates that a value exists in the implementation. For example, in the signature of a module, the following declares two value signatures:</p> <pre><code>module MyMap =\n    val mapForward : index1: int * index2: int -&gt; string\n    val mapBackward : name: string -&gt; (int * int)\n</code></pre> <p>The corresponding implementation file might contain the following implementation:</p> <pre><code>module MyMap =\n    let mapForward (index1:int, index2:int) = string index1 + \",\" + string index2\n    let mapBackward (name:string) = (0, 0)\n</code></pre>"},{"location":"namespace-and-module-signatures/#1112-type-definition-and-member-signatures","title":"11.1.2 Type Definition and Member Signatures","text":"<p>A type definition signature indicates that a corresponding type definition appears in the implementation. For example, in an interface type, the following declares a type definition signature for <code>Forward</code> and <code>Backward</code>:</p> <pre><code>type IMap =\n    interface\n        abstract Forward : index1: int * index2: int -&gt; string\n        abstract Backward : name: string -&gt; (int * int)\n    end\n</code></pre> <p>A member signature indicates that a corresponding member appears on the corresponding type definition in the implementation. Member specifications must specify argument and return types, and can optionally specify names and attributes for parameters.</p> <p>For example, the following declares a type definition signature for a type with one constructor member, one property member <code>Kind</code> and one method member <code>Purr</code>:</p> <pre><code>type Cat =\n    new : kind:string -&gt; Cat\n    member Kind : string\n    member Purr : unit -&gt; Cat\n</code></pre> <p>The corresponding implementation file might contain the following implementation:</p> <pre><code>type Cat(kind: string) =\n    member x.Meow() = printfn \"meow\"\n    member x.Purr() = printfn \"purr\"\n    member x.Kind = kind\n</code></pre>"},{"location":"namespace-and-module-signatures/#112-signature-conformance","title":"11.2 Signature Conformance","text":"<p>Values, types, and members that are present in implementations can be omitted in signatures, with the following exceptions:</p> <ul> <li>Type abbreviations may not be hidden by signatures. That is, a type abbreviation <code>type T = ty</code> in     an implementation does not match type <code>T</code> (without an abbreviation) in a signature.</li> <li>Any type that is represented as a record or union must reveal either all or none of its fields or     cases, in the same order as that specified in the implementation. Types that are represented as     classes may reveal some, all, or none of their fields in a signature.</li> <li>Any type that is revealed to be an interface, or a type that is a class or struct with one or more     constructors may not hide its <code>inherit</code> declaration, abstract dispatch slot declarations, or abstract     interface declarations.</li> </ul> <p>Note: This section does not yet document all checks made by the F# 3.1 language implementation.</p>"},{"location":"namespace-and-module-signatures/#1121-signature-conformance-for-functions-and-values","title":"11.2.1 Signature Conformance for Functions and Values","text":"<p>If both a signature and an implementation contain a function or value definition with a given name, the signature and implementation must conform as follows:</p> <ul> <li>The declared accessibilities, <code>inline</code>, and <code>mutable</code> modifiers must be identical in both the     signature and the implementation.</li> <li>If either the signature or the implementation has the <code>[&lt;Literal&gt;]</code> attribute, both must have this     attribute. Furthermore, the declared literal values must be identical.</li> <li>The number of generic parameters\u2014both inferred and explicit\u2014must be identical.</li> <li>The types and type constraints must be identical up to renaming of inferred and/or explicit     generic parameters. For example, assume a signature is written <code>val head : seq&lt;'T&gt; -&gt; 'T</code> and     the compiler could infer the type <code>val head : seq&lt;'a&gt; -&gt; 'a</code> from the implementation. These     are considered identical up to renaming the generic parameters.</li> <li>The arities must match, as described in the next section.</li> </ul>"},{"location":"namespace-and-module-signatures/#11211-arity-conformance-for-functions-and-values","title":"11.2.1.1 Arity Conformance for Functions and Values","text":"<p>Arities of functions and values must conform between implementation and signature. Arities of values are implicit in module signatures. A signature that contains the following results in the arity <code>[A1 ... An]</code> for <code>F</code>:</p> <pre><code>val F : ty11 * ... * ty1A1 - &gt; ... -&gt; tyn1 * ... * tynAn - &gt; rty\n</code></pre> <p>Arities in a signature must be equal to or shorter than the corresponding arities in an implementation, and the prefix must match. This means that F# makes a deliberate distinction between the following two signatures:</p> <pre><code>val F: int -&gt; int\n</code></pre> <p>and</p> <pre><code>val F: (int -&gt; int)\n</code></pre> <p>The parentheses indicate a top-level function, which might be a first-class computed expression that computes to a function value, rather than a compile-time function value.</p> <p>The first signature can be satisfied only by a true function; that is, the implementation must be a lambda value as in the following:</p> <pre><code>let F x = x + 1\n</code></pre> <p>Note: Because arity inference also permits right-hand-side function expressions, the implementation may currently also be: <code>let F = fun x -&gt; x + 1</code></p> <p>The second signature</p> <pre><code>val F: (int -&gt; int)\n</code></pre> <p>can be satisfied by any value of the appropriate type. For example:</p> <pre><code>let f =\n    let myTable = new System.Collections.Generic.Dictionary&lt;int,int&gt;(4)\n    fun x -&gt;\n        if myTable.ContainsKey x then\n            myTable.[x]\n        else\n            let res = x * x\n            myTable.[x] &lt;- res\n            res\n</code></pre> <p>\u2014or\u2014</p> <pre><code>let f = fun x -&gt; x + 1\n</code></pre> <p>\u2014or\u2014</p> <pre><code>// throw an exception as soon as the module initialization is triggered\nlet f : int -&gt; int = failwith \"failure\"\n</code></pre> <p>For both the first and second signatures, you can still use the functions as first-class function values from client code\u2014the parentheses simply act as a constraint on the implementation of the value.</p> <p>The reason for this interpretation of types in value and member signatures is that CLI interoperability requires that F# functions compile to methods, rather than to fields that are function values. Thus, signatures must contain enough information to reveal the desired arity of a method as it is revealed to other CLI programming languages.</p>"},{"location":"namespace-and-module-signatures/#11212-signature-conformance-for-type-functions","title":"11.2.1.2 Signature Conformance for Type Functions","text":"<p>If a value is a type function, then its corresponding value signature must have explicit type arguments. For example, the implementation</p> <pre><code>let empty&lt;'T&gt; : list&lt;'T&gt; = printfn \"hello\"; []\n</code></pre> <p>conforms to this signature:</p> <pre><code>val empty&lt;'T&gt; : list&lt;'T&gt;\n</code></pre> <p>but not to this signature:</p> <pre><code>val empty : list&lt;'T&gt;\n</code></pre> <p>The reason for this rule is that the second signature indicates that the value is, by default, generalizable (\u00a714.6.7).</p>"},{"location":"namespace-and-module-signatures/#1122-signature-conformance-for-members","title":"11.2.2 Signature Conformance for Members","text":"<p>If both a signature and an implementation contain a member with a given name, the signature and implementation must conform as follows:</p> <ul> <li>If one is an extension member, both must be extension members.</li> <li>If one is a constructor, then both must be constructors.</li> <li> <p>If one is a property, then both must be properties.</p> </li> <li> <p>The types must be identical up to renaming of inferred or explicit type parameters (as for     functions and values).</p> </li> <li>The <code>static</code>, <code>abstract</code>, and <code>override</code> qualifiers must match precisely.</li> <li>Abstract members must be present in the signature if a representation is given for a type.</li> </ul> <p>Note: This section does not yet document all checks made by the F# 3 .1 language implementation.</p>"},{"location":"namespaces-and-modules/","title":"10. Namespaces and Modules","text":"<p>F# is primarily an expression-based language. However, F# source code units are made up of declarations , some of which can contain further declarations. Declarations are grouped using namespace declaration groups , type definitions , and module definitions. These also have corresponding forms in signatures. For example, a file may contain multiple namespace declaration groups, each of which defines types and modules, and the types and modules may contain member, function, and value definitions, which contain expressions.</p> <p>Declaration elements are processed in the context of an environment. The definition of the elements of an environment is found in \u00a714.1.</p> <pre><code>namespace-decl-group :=\n    namespace long-ident module-elems       -- elements within a namespace\n    namespace global module-elems           -- elements within no namespace\n\nmodule-defn :=\n    attributesopt module accessopt ident = module-defn-body\n\nmodule-defn-body :=\n    begin module-elemsopt end\n\nmodule-elem :=\n    module-function-or-value-defn           -- function or value definitions\n    type-defns                              -- type definitions\n    exception-defn                          -- exception definitions\n    module-defn                             -- module definitions\n    module-abbrev                           -- module abbreviations\n    import-decl                             -- import declarations\n    compiler-directive-decl                 -- compiler directives\n\nmodule-function-or-value-defn :=\n    attributesopt let function-defn\n    attributesopt let value-defn\n    attributesopt let rec opt function-or-value-defns\n    attributesopt do expr\n\nimport-decl := open long-ident\n\nmodule-abbrev := module ident = long-ident\n\ncompiler-directive-decl := # ident string ... string\n\nmodule-elems := module-elem ... module-elem\n\naccess :=\n    private\n    internal\n    public\n</code></pre>"},{"location":"namespaces-and-modules/#101-namespace-declaration-groups","title":"10.1 Namespace Declaration Groups","text":"<p>Modules and types in an F# program are organized into namespaces, which encompass the identifiers that are defined in the modules and types. New components may contribute entities to existing namespaces. Each such contribution to a namespace is called a namespace declaration group.</p> <p>In the following example, the <code>MyCompany.MyLibrary</code> namespace contains <code>Values</code> and <code>x</code>:</p> <pre><code>namespace MyCompany.MyLibrary\n\n    module Values1 =\n        let x = 1\n</code></pre> <p>A namespace declaration group is the basic declaration unit within an F# implementation file and is of the form</p> <pre><code>namespace long-ident\n\nmodule-elems\n</code></pre> <p>The <code>long-ident</code> must be fully qualified. Each such group contains a series of module and type definitions that contribute to the indicated namespace. An implementation file may contain multiple namespace declaration groups, as in this example:</p> <pre><code>namespace MyCompany.MyOtherLibrary\n\n    type MyType() =\n        let x = 1\n            member v.P = x + 2\n\n    module MyInnerModule =\n        let myValue = 1\n\nnamespace MyCompany.MyOtherLibrary.Collections\n\n    type MyCollection(x : int) =\n        member v.P = x\n</code></pre> <p>Namespace declaration groups may not be nested.</p> <p>A namespace declaration group can contain type and module definitions, but not function or value definitions. For example:</p> <pre><code>namespace MyCompany.MyLibrary\n\n// A type definition in a namespace\ntype MyType() =\n    let x = 1\n    member v.P = x+2\n\n// A module definition in a namespace\n    module MyInnerModule =\n        let myValue = 1\n\n// The following is not allowed: value definitions are not allowed in namespaces\nlet addOne x = x + 1\n</code></pre> <p>When a namespace declaration group <code>N</code> is checked in an environment <code>env</code> , the individual declarations are checked in order and an overall namespace declaration group signature <code>Nsig</code> is inferred for the module. An entry for <code>N</code> is then added to the ModulesAndNamespaces table in the environment <code>env</code> (see \u00a714.1.3).</p> <p>Like module declarations, namespace declaration groups are processed sequentially rather than simultaneously, so that later namespace declaration groups are not in scope when earlier ones are processed. This prevents invalid recursive definitions.</p> <p>In the following example, the declaration of <code>x</code> in <code>Module1</code> generates an error because the <code>Utilities.Part2</code> namespace is not in scope:</p> <pre><code>namespace Utilities.Part1\n\nmodule Module1 =\n    let x = Utilities.Part2.Module2.x + 1 // error (Part2 not yet declared)\n\nnamespace Utilities.Part2\n\n    module Module2 =\n        let x = Utilities.Part1.Module1.x + 2\n</code></pre> <p>Within a namespace declaration group, the namespace itself is implicitly opened if any preceding namespace declaration groups or referenced assemblies contribute to it. For example:</p> <pre><code>namespace MyCompany.MyLibrary\n\n    module Values1 =\n        let x = 1\n\nnamespace MyCompany.MyLibrary\n\n    // Here, the implicit open of MyCompany.MyLibrary brings Values1 into scope\n    module Values2 =\n        let x = Values1.x\n</code></pre>"},{"location":"namespaces-and-modules/#102-module-definitions","title":"10.2 Module Definitions","text":"<p>A module definition is a named collection of declarations such as values, types, and function values. Grouping code in modules helps keep related code together and helps avoid name conflicts in your program. For example:</p> <pre><code>module MyModule =\n    let x = 1\n    type Foo = A | B\n    module MyNestedModule =\n        let f y = y + 1\n        type Bar = C | D\n</code></pre> <p>When a module definition <code>M</code> is checked in an environment <code>env0</code>, the individual declarations are checked in order and an overall module signature <code>Msig</code> is inferred for the module. An entry for <code>M</code> is then added to the ModulesAndNamespaces table to environment <code>env0</code> to form the new environment used for checking subsequent modules.</p> <p>Like namespace declaration groups, module definitions are processed sequentially rather than simultaneously, so that later modules are not in scope when earlier ones are processed.</p> <pre><code>module Part1 =\n\n    let x = Part2.StorageCache() // error (Part2 not yet declared)\n\nmodule Part2 =\n\n    type StorageCache() =\n        member cache.Clear() = ()\n</code></pre> <p>No two types or modules may have identical names in the same namespace. If a type and a module in the same assembly and namespace are given the same name, the compiler will automatically append <code>Module</code> as a suffix to the compiled name. The <code>[&lt;CompilationRepresentation(CompilationRepresentationFlags.ModuleSuffix)&gt;]</code> attribute can be used to cause a module name to always be appended with <code>Module</code>.</p> <pre><code>type Cat(kind: string) =\n    member x.Meow() = printfn \"meow\"\n    member x.Purr() = printfn \"purr\"\n    member x.Kind = kind\n\n[&lt;CompilationRepresentation(CompilationRepresentationFlags.ModuleSuffix)&gt;]\nmodule Cat = // Cat is explicitly compiled as CatModule\n\n    let tabby = Cat \"Tabby\"\n    let purr (c:Cat) = c.Purr(); c\n    let purrTwice (c:Cat) = purr (purr c)\n\nCat.tabby |&gt; Cat.purr |&gt; Cat.purrTwice\n\ntype Dog(kind: string) =\n    member x.Bark() = printfn \"woof\"\n    member x.Wag() = printfn \"wag\"\n    member x.Kind = kind\n\nmodule Dog = // Dog is implicitly compiled as DogModule\n\n    let beagle = Dog \"Beagle\"\n    let bark (d:Dog) = d.Bark(); d\n    let barkTwice (d:Dog) = bark (bark d)\n\nDog.beagle |&gt; Dog.bark |&gt; Dog.barkTwice\n\ntype Cage&lt;'Pet&gt;(pet: 'Pet) =\n    member x.Pet = pet\n\nmodule Cage = // Cage is compiled as Cage because Cage&lt;'Pet&gt; is a generic type so the name does not conflict\n    let putInCage pet = Cage pet\n    let getPet (cage: Cage&lt;'Pet&gt;) = cage.Pet\n\nlet catCage = Cage.putInCage Cat.tabby\nlet dogCage = Cage.putInCage Dog.beagle\n\ncatCage |&gt; Cage.getPet |&gt; Cat.purr\ndogCage |&gt; Cage.getPet |&gt; Dog.bark\n</code></pre>"},{"location":"namespaces-and-modules/#1021-function-and-value-definitions-in-modules","title":"10.2.1 Function and Value Definitions in Modules","text":"<p>Function and value definitionsin modules introduce named values and functions.</p> <pre><code>let rec~opt function-or-value-defn1 and ... and function-or-value-defnn\n</code></pre> <p>The following example defines value <code>x</code> and functions <code>id</code> and <code>fib</code>:</p> <pre><code>module M =\n    let x = 1\n    let id x = x\n    let rec fib x = if x &lt;= 2 then 1 else fib (n - 1) + fib (n - 2)\n</code></pre> <p>Function and value definitions in modules may declare explicit type variables and type constraints:</p> <pre><code>let pair&lt;'T&gt;(x : 'T) = (x, x)\nlet dispose&lt;'T when 'T :&gt; System.IDisposable&gt;(x : 'T) = x.Dispose()\nlet convert&lt;'T, 'U&gt;(x) = unbox&lt;'U&gt;(box&lt;'T&gt;(x))\n</code></pre> <p>A value definition that has explicit type variables is called a type function (\u00a710.2.3).</p> <p>Function and value definitions may specify attributes:</p> <pre><code>// A value definition with the System.Obsolete attribute\n[&lt;System.Obsolete(\"Don't use this\")&gt;]\nlet oneTwoPair = ( 1 , 2 )\n\n// A function definition with an attribute\n[&lt;System.Obsolete(\"Don't use this either\")&gt;]\nlet pear v = (v, v)\n</code></pre> <p>By the use of pattern matching, a value definition can define more than one value. In such cases, the attributes apply to each value.</p> <pre><code>// A value definition that defines two values, each with an attribute\n[&lt;System.Obsolete(\"Don't use this\")&gt;]\nlet (a, b) = (1, 2)\n</code></pre> <p>Values may be declared mutable:</p> <pre><code>// A value definition that defines a mutable value\nlet mutable count = 1\nlet freshName() = (count &lt;- count + 1; count)\n</code></pre> <p>Function and value definitions in modules are processed in the same way as function and value definitions in expressions (\u00a714.6), with the following adjustments:</p> <ul> <li>Each defined value may have an accessibility annotation (\u00a710.5). By default, the accessibility     annotation of a function or value definition in a module is <code>public</code>.</li> <li>Each defined value is externally accessible if its accessibility annotation is <code>public</code> and it is not     hidden by an explicit signature. Externally accessible values are guaranteed to have compiled CLI     representations in compiled CLI binaries.</li> <li>Each defined value can be used to satisfy the requirements of any signature for the module     (\u00a711.2).</li> <li>Each defined value is subject to arity analysis (\u00a714.11).</li> <li>Values may have attributes, including the <code>ThreadStatic</code> or <code>ContextStatic</code> attribute.</li> </ul>"},{"location":"namespaces-and-modules/#1022-literal-definitions-in-modules","title":"10.2.2 Literal Definitions in Modules","text":"<p>Value definitions in modules may have the <code>Literal</code> attribute. This attribute causes the value to be compiled as a constant. For example:</p> <pre><code>[&lt;Literal&gt;]\nlet PI = 3.141592654\n</code></pre> <p>Literal values may be used in custom attributes and pattern matching. For example:</p> <pre><code>[&lt;Literal&gt;]\nlet StartOfWeek = System.DayOfWeek.Monday\n\n[&lt;MyAttribute(StartOfWeek)&gt;]\nlet feeling(day) =\n    match day with\n    | StartOfWeek -&gt; \"rough\"\n    | _ -&gt; \"great\"\n</code></pre> <p>A value that has the <code>Literal</code> attribute is subject to the following restrictions:</p> <ul> <li>It may not be marked <code>mutable</code> or <code>inline</code>.</li> <li>It may not also have the <code>ThreadStatic</code> or <code>ContextStatic</code> attributes.</li> <li>The right-hand side expression must be a literal constant expression that is both a valid     expression after checking, and is made up of either:</li> <li>A simple constant expression, with the exception of <code>()</code>, native integer literals, unsigned native        integer literals, byte array literals, BigInteger literals, and user-defined numeric literals.</li> </ul> <p>\u2014 OR \u2014</p> <ul> <li>A reference to another literal</li> </ul> <p>\u2014 OR \u2014</p> <ul> <li>A bitwise combination of literal constant expressions</li> </ul> <p>\u2014 OR \u2014</p> <ul> <li>A <code>+</code> concatenation of two literal constant expressions which are strings</li> </ul> <p>\u2014 OR \u2014</p> <ul> <li><code>enum x</code> or <code>LanguagePrimitives.EnumOfValue x</code> where <code>x</code> is a literal constant expression.</li> </ul>"},{"location":"namespaces-and-modules/#1023-type-function-definitions-in-modules","title":"10.2.3 Type Function Definitions in Modules","text":"<p>Value definitions within modules may have explicit generic parameters. For example, <code>\u2018T</code> is a generic parameter to the value <code>empty</code>:</p> <pre><code>let empty&lt;'T&gt; : (list&lt;'T&gt; * Set&lt;'T&gt;) = ([], Set.empty)\n</code></pre> <p>A value that has explicit generic parameters but has arity <code>[]</code> (that is, no explicit function parameters) is called a type function. The following are some example type functions from the F# library:</p> <pre><code>val typeof&lt;'T&gt; : System.Type\nval sizeof&lt;'T&gt; : int\nmodule Set =\n    val empty&lt;'T&gt; : Set&lt;'T&gt;\nmodule Map =\n    val empty&lt;'Key,'Value&gt; : Map&lt;'Key,'Value&gt;\n</code></pre> <p>Type functions are rarely used in F# programming, although they are convenient in certain situations. Type functions are typically used for:</p> <ul> <li>Pure functions that compute type-specific information based on the supplied type arguments.</li> <li>Pure functions whose result is independent of inferred type arguments, such as empty sets and     maps.</li> </ul> <p>Type functions receive special treatment during generalization (\u00a714.6.7) and signature conformance (\u00a711.2). They typically have either the <code>RequiresExplicitTypeArguments</code> attribute or the <code>GeneralizableValue</code> attribute. Type functions may not be defined inside types, expressions, or computation expressions.</p> <p>In general, type functions should be used only for computations that do not have observable side effects. However, type functions may still perform computations. In this example, <code>r</code> is a type function that calculates the number of times it has been called</p> <pre><code>let mutable count = 1\nlet r&lt;'T&gt; = (count &lt;- count + 1); ref ([] : 'T list);;\n// count = 1\nlet x1 = r&lt;int&gt;\n// count = 2\nlet x2 = r&lt;int&gt;\n// count = 3\nlet z0 = x1\n// count = 3\n</code></pre> <p>The elaborated form of a type function is that of a function definition that takes one argument of type <code>unit</code>. That is, the elaborated form of</p> <pre><code>let ident typar-defns = expr\n</code></pre> <p>is the same as the compiled form for the following declaration:</p> <pre><code>let ident typar-defns () = expr\n</code></pre> <p>References to type functions are elaborated to invocations of such a function.</p>"},{"location":"namespaces-and-modules/#1024-active-pattern-definitions-in-modules","title":"10.2.4 Active Pattern Definitions in Modules","text":"<p>A value definition within a module that has an <code>active-pattern-op-name</code> introduces pattern-matching tags into the environment when the module is accessed or opened. For example,</p> <pre><code>let (|A|B|C|) x = if x &lt; 0 then A elif x = 0 then B else C\n</code></pre> <p>introduces pattern tags <code>A</code>, <code>B</code>, and <code>C</code> into the PatItems table in the name resolution environment.</p>"},{"location":"namespaces-and-modules/#1025-do-statements-in-modules","title":"10.2.5 \u201cdo\u201d statements in Modules","text":"<p>A <code>do</code> statement within a module has the following form:</p> <pre><code>do expr\n</code></pre> <p>The expression <code>expr</code> is checked with an arbitrary initial type <code>ty</code>. After checking <code>expr</code>, <code>ty</code> is asserted to be equal to <code>unit</code>. If the assertion fails, a warning rather than an error is reported. This warning is suppressed for plain expressions without do in script files (that is, .fsx and .fsscript files).</p> <p>A <code>do</code> statement may have attributes. In this example, the <code>STAThread</code> attribute specifies that main uses the single-threaded apartment (STA) threading model of COM:</p> <pre><code>let main() =\n    let form = new System.Windows.Forms.Form()\n    System.Windows.Forms.Application.Run(form)\n\n[&lt;STAThread&gt;]\ndo main()\n</code></pre>"},{"location":"namespaces-and-modules/#103-import-declarations","title":"10.3 Import Declarations","text":"<p>Namespace declaration groups and module definitions can include import declarations in the following form:</p> <pre><code>open long-ident\n</code></pre> <p>Import declarations make elements of other namespace declaration groups and modules accessible by the use of unqualified names. For example:</p> <pre><code>open FSharp.Collections\nopen System\n</code></pre> <p>Import declarations can be used in:</p> <ul> <li>Module definitions and their signatures.</li> <li>Namespace declaration groups and their signatures.</li> </ul> <p>An import declaration is processed by first resolving the <code>long-ident</code> to one or more namespace declaration groups and/or modules [ <code>F1</code>, ..., <code>Fn</code> ] by Name Resolution in Module and Namespace Paths (\u00a714.1.2). For example, <code>System.Collections.Generic</code> may resolve to one or more namespace declaration groups\u2014one for each assembly that contributes a namespace declaration group in the current environment. Next, each <code>Fi</code> is added to the environment successively by using the technique specified in \u00a714.1.3. An error occurs if any <code>Fi</code> is a module that has the <code>RequireQualifiedAccess</code> attribute.</p>"},{"location":"namespaces-and-modules/#104-module-abbreviations","title":"10.4 Module Abbreviations","text":"<p>A module abbreviation defines a local name for a module long identifier, as follows:</p> <pre><code>module ident = long-ident\n</code></pre> <p>For example:</p> <pre><code>module Ops = FSharp.Core.Operators\n</code></pre> <p>Module abbreviations can be used in:</p> <ul> <li>Module definitions and their signatures.</li> <li>Namespace declaration groups and their signatures.</li> </ul> <p>Module abbreviations are implicitly private to the module or namespace declaration group in which they appear.</p> <p>A module abbreviation is processed by first resolving the <code>long-ident</code> to a list of modules by Name Resolution in Module and Namespace Paths (see \u00a714.1). The list is then appended to the set of names that are associated with <code>ident</code> in the ModulesAndNamespaces table.</p> <p>Module abbreviations may not be used to abbreviate namespaces.</p>"},{"location":"namespaces-and-modules/#105-accessibility-annotations","title":"10.5 Accessibility Annotations","text":"<p>Accessibilities may be specified on declaration elements in namespace declaration groups and modules, and on members in types. The table lists the accessibilities that can appear in user code:</p> Accessibility Description <code>public</code> No restrictions on access. <code>private</code> Access is permitted only from the enclosing type, module, or namespace declaration group. <code>internal</code> Access is permitted only from within the enclosing assembly, or from assemblies whose name is listed using the <code>InternalsVisibleTo</code> attribute in the current assembly. <p>The default accessibilities are <code>public</code>. Specifically:</p> <ul> <li>Function definitions, value definitions, type definitions, and exception definitions in modules are     public.</li> <li>Modules, type definitions, and exception definitions in namespaces are public.</li> <li>Members in type definitions are public.</li> </ul> <p>Some function and value definitions may not be given an accessibility and, by their nature, have restricted lexical scope. In particular:</p> <ul> <li>Function and value definitions in classes are lexically available only within the class being     defined, and only from the point of their definition onward.</li> <li>Module type abbreviations are lexically available only within the module or namespace     declaration group being defined, and only from their point of their definition onward.</li> </ul> <p>Note that:</p> <ul> <li><code>private</code> on a member means \u201cprivate to the enclosing type or module.\u201d</li> <li><code>private</code> on a function or value definition in a module means \u201cprivate to the module or     namespace declaration group.\u201d</li> <li><code>private</code> on a type, module, or type representation in a module means \u201cprivate to the module.\u201d</li> </ul> <p>The CLI compiled form of all non-public entities is <code>internal</code>.</p> <p>Note: The <code>family</code> and <code>protected</code> specifications are not supported in this version of the F# language.</p> <p>Accessibility modifiers can appear only in the locations summarized in the following table.</p> Component Location Example Function or value definition in module Precedes identifier <code>let private x = 1</code><code>let inline private f x = 1</code><code>let mutable private x = 1</code> Module definition Precedes identifier <code>module private M =</code><code>let x = 1</code> Type definition Precedes identifier <code>type private C = A \\| B</code><code>type private C&lt;'T&gt; = A \\| B</code> <code>val</code> definition in a class Precedes identifier <code>val private x : int</code> Explicit constructor Precedes identifier <code>private new () = { inherit Base }</code> Implicit constructor Precedes identifier <code>type C private() = ...</code> Member definition Precedes identifier, but cannot appear on <code>inherit</code> definitions, <code>interface</code> definitions, <code>abstract</code> definitions, individual union cases. Accessibility for <code>inherit</code>, <code>interface</code>, and <code>abstract</code> definitions is always the same as that of the enclosing class. <code>member private x.X = 1</code> Explicit property get or set in a class Precedes identifier <code>member __.Item</code> <code>with private get i = 1</code> <code>and private set i v = ()</code> Type representation Precedes identifier <code>type Cases = private \\| A \\| B</code>"},{"location":"patterns/","title":"7. Patterns","text":"<p>Patterns are used to perform simultaneous case analysis and decomposition on values together with the <code>match</code>, <code>try...with</code>, <code>function</code>, <code>fun</code>, and <code>let</code> expression and declaration constructs. Rules are attempted in order from top to bottom and left to right. The syntactic forms of patterns are shown in the subsequent table.</p> <pre><code>rule :=\n    pat pattern-guard~opt -&gt; expr       -- pattern, optional guard and action\n\npattern-guard := when expr\n\npat :=\n    const                               -- constant pattern\n    long-ident pat-param~opt pat~opt    -- named pattern\n    _ -- wildcard pattern\n    pat as ident                        -- \"as\" pattern\n    pat '|' pat                         -- disjunctive pattern\n    pat '&amp;' pat                         -- conjunctive pattern\n    pat :: pat                          -- \"cons\" pattern\n    pat : type                          -- pattern with type constraint\n    pat , ... , pat                     -- tuple pattern\n    struct (pat , ... , pat)            -- struct tuple pattern\n    ( pat )                             -- parenthesized pattern\n    list-pat                            -- list pattern\n    array-pat                           -- array pattern\n    record-pat                          -- record pattern\n    :? atomic-type                      -- dynamic type test pattern\n    :? atomic-type as ident             -- dynamic type test pattern\n    null                                -- null-test pattern\n    attributes pat                      -- pattern with attributes\n\nlist-pat :=\n    [ ]\n    [ pat ; ... ; pat ]\n\narray-pat :=\n    [| |]\n    [| pat ; ... ; pat |]\n\nrecord-pat :=\n    { field-pat ; ... ; field-pat }\n\natomic-pat :=\n    pat : one of\n            const long-ident list-pat record-pat array-pat ( pat )\n            :? atomic-type\n            null _\n\nfield-pat := long-ident = pat\n\npat-param :=\n    | const\n    | long-ident\n    | [ pat-param ; ... ; pat-param ]\n    | ( pat-param , ..., pat-param )\n    | long-ident pat-param\n    | pat-param : type\n    | &lt;@ expr @&gt;\n    | &lt;@@ expr @@&gt;\n    | null\n\npats := pat , ... , pat\nfield-pats := field-pat ; ... ; field-pat\nrules := '|'~opt rule '|' ... '|' rule\n</code></pre> <p>Patterns are elaborated to expressions through a process called pattern match compilation. This reduces pattern matching to decision trees which operate on an input value, called the pattern input. The decision tree is composed of the following constructs:</p> <ul> <li>Conditionals on integers and other constants</li> <li>Switches on union cases</li> <li>Conditionals on runtime types</li> <li>Null tests</li> <li>Value definitions</li> <li>An array of pattern-match targets referred to by index</li> </ul>"},{"location":"patterns/#71-simple-constant-patterns","title":"7.1 Simple Constant Patterns","text":"<p>The pattern <code>const</code> is a constant pattern which matches values equal to the given constant. For example:</p> <pre><code>let rotate3 x =\n    match x with\n    | 0 -&gt; \"two\"\n    | 1 -&gt; \"zero\"\n    | 2 -&gt; \"one\"\n    | _ -&gt; failwith \"rotate3\"\n</code></pre> <p>In this example, the constant patterns are 0, 1, and 2. Any constant listed in \u00a76.3.1 may be used as a constant pattern except for integer literals that have the suffixes <code>Q</code>, <code>R</code>, <code>Z</code>, <code>I</code>, <code>N</code>, <code>G</code>.</p> <p>Simple constant patterns have the corresponding simple type. Such patterns elaborate to a call to the F# structural equality function <code>FSharp.Core.Operators.(=)</code> with the pattern input and the constant as arguments. The match succeeds if this call returns <code>true</code>; otherwise, the match fails.</p> <p>Note: The use of <code>FSharp.Core.Operators.(=)</code> means that CLI floating-point equality is used to match floating-point values, and CLI ordinal string equality is used to match strings.</p>"},{"location":"patterns/#72-named-patterns","title":"7.2 Named Patterns","text":"<p>Patterns in the following forms are named patterns :</p> <pre><code>Long-ident\nLong-ident pat\nLong-ident pat-params pat\n</code></pre> <p>If <code>long-ident</code> is a single identifier that does not begin with an uppercase character, it is interpreted as a variable pattern. During checking, the variable is assigned the same value and type as the pattern input.</p> <p>If <code>long-ident</code> is more than one-character long or begins with an uppercase character (that is, if <code>System.Char.IsUpperInvariant</code> is <code>true</code> and <code>System.Char.IsLowerInvariant</code> is <code>false</code> on the first character), it is resolved by using Name Resolution in Patterns (\u00a714.1.6). This algorithm produces one of the following:</p> <ul> <li>A union case</li> <li>An exception label</li> <li>An active pattern case name</li> <li>A literal value</li> </ul> <p>Otherwise, <code>long-ident</code> must be a single uppercase identifier <code>ident</code>. In this case, <code>pat</code> is a variable pattern. An F# implementation may optionally generate a warning if the identifier is uppercase. Such a warning is recommended if the length of the identifier is greater than two.</p> <p>After name resolution, the subsequent treatment of the named pattern is described in the following sections.</p>"},{"location":"patterns/#721-union-case-patterns","title":"7.2.1 Union Case Patterns","text":"<p>If <code>long-ident</code> from \u00a77.2 resolves to a union case, the pattern is a union case pattern. If <code>long-ident</code> resolves to a union case <code>Case</code> , then <code>long-ident</code> and <code>long-ident pat</code> are patterns that match pattern inputs that have union case label <code>Case</code>. The <code>long-ident</code> form is used if the corresponding case takes no arguments, and the <code>long-ident pat</code> form is used if it takes arguments.</p> <p>At runtime, if the pattern input is an object that has the corresponding union case label, the data values carried by the union are matched against the given argument patterns.</p> <p>For example:</p> <pre><code>type Data =\n    | Kind1 of int * int\n    | Kind2 of string * string\n\nlet data = Kind1(3, 2)\n\nlet result =\n    match data with\n    | Kind1 (a, b) -&gt; a + b\n    | Kind2 (s1, s2) -&gt; s1.Length + s2.Length\n</code></pre> <p>In this case, result is given the value 5.</p> <p>When a union case has named fields, these names may be referenced in a union case pattem. When using pattern matching with multiple fields, semicolons are used to delimit the named fields. For example</p> <pre><code>type Shape =\n    | Rectangle of width: float * height: float\n    | Square of width: float\n\nlet getArea (s: Shape) =\n    match s with\n    | Rectangle (width = w; height = h) -&gt; w*h\n    | Square (width = w) -&gt; w*w\n</code></pre>"},{"location":"patterns/#722-literal-patterns","title":"7.2.2 Literal Patterns","text":"<p>If <code>long-ident</code> from \u00a77.2 resolves to a literal value, the pattern is a literal pattern. The pattern is equivalent to the corresponding constant pattern.</p> <p>In the following example, the <code>Literal</code> attribute (\u00a710.2.2) is first used to define two literals, and these literals are used as identifiers in the match expression:</p> <pre><code>[&lt;Literal&gt;]\nlet Case1 = 1\n\n[&lt;Literal&gt;]\nlet Case2 = 100\n\nlet result =\n    match 1 00 with\n    | Case1 -&gt; \"Case1\"\n    | Case2 -&gt; \"Case 2 \"\n    | _ -&gt; \"Some other case\"\n</code></pre> <p>In this case, <code>result</code> is given the value <code>Case2</code>.</p>"},{"location":"patterns/#723-active-patterns","title":"7.2.3 Active Patterns","text":"<p>If <code>long-ident</code> from \u00a77.2 resolves to an active pattern case name <code>CaseNamei</code> then the pattern is an active pattern. The rules for name resolution in patterns (\u00a714.1.6) ensure that <code>CaseNamei</code> is associated with an active pattern function <code>f</code> in one of the following forms:</p> <ul> <li><code>(| CaseName |) inp</code></li> </ul> <p>Single case. The function accepts one argument (the value being matched) and can return any type.</p> <ul> <li><code>(| CaseName |_|) inp</code></li> </ul> <p>Partial. The function accepts one argument (the value being matched) and must return a value of type <code>FSharp.Core.option&lt;_&gt;</code></p> <ul> <li><code>(| CaseName1 | ...| CaseNamen |) inp</code></li> </ul> <p>Multi-case. The function accepts one argument (the value being matched), and must return a value of type <code>FSharp.Core.Choice&lt;_,...,_&gt;</code> based on the number of case names. In F#, the limitation n \u2264 7 applies.</p> <ul> <li><code>(| CaseName |) arg1 ... argn inp</code></li> </ul> <p>Single case with parameters. The function accepts <code>n+1</code> arguments, where the last argument (<code>inp</code>) is the value to match, and can return any type.</p> <ul> <li><code>(| CaseName |_|) arg1 ... argn inp</code></li> </ul> <p>Partial with parameters. The function accepts n +1 arguments, where the last argument (<code>inp</code>) is the value to match, and must return a value of type <code>FSharp.Core.option&lt;_&gt;</code>.</p> <p>Other active pattern functions are not permitted. In particular, multi-case, partial functions such as the following are not permitted:</p> <pre><code>(|CaseName1| ... |CaseNamen|_|)\n</code></pre> <p>When an active pattern function takes arguments, the <code>pat-params</code> are interpreted as expressions that are passed as arguments to the active pattern function. The <code>pat-params</code> are converted to the syntactically identical corresponding expression forms and are passed as arguments to the active pattern function <code>f</code>.</p> <p>At runtime, the function <code>f</code> is applied to the pattern input, along with any parameters. The pattern matches if the active pattern function returns <code>v</code> , <code>ChoicekOfN v</code> , or Some <code>v</code> , respectively, when applied to the pattern input. If the pattern argument <code>pat</code> is present, it is then matched against <code>v</code>.</p> <p>The following example shows how to define and use a partial active pattern function:</p> <pre><code>let (|Positive|_|) inp = if inp &gt; 0 then Some(inp) else None\nlet (|Negative|_|) inp = if inp &lt; 0 then Some(-inp) else None\n\nmatch 3 with\n| Positive n -&gt; printfn \"positive, n = %d\" n\n| Negative n -&gt; printfn \"negative, n = %d\" n\n| _ -&gt; printfn \"zero\"\n</code></pre> <p>The following example shows how to define and use a multi-case active pattern function:</p> <pre><code>let (|A|B|C|) inp = if inp &lt; 0 then A elif inp = 0 then B else C\n\nmatch 3 with\n| A -&gt; \"negative\"\n| B -&gt; \"zero\"\n| C - &gt; \"positive\"\n</code></pre> <p>The following example shows how to define and use a parameterized active pattern function:</p> <pre><code>let (|MultipleOf|_|) n inp = if inp%n = 0 then Some (inp / n) else None\n\nmatch 16 with\n| MultipleOf 4 n -&gt; printfn \"x = 4*%d\" n\n| _ -&gt; printfn \"not a multiple of 4\"\n</code></pre> <p>An active pattern function is executed only if a left-to-right, top-to-bottom reading of the entire pattern indicates that execution is required. For example, consider the following active patterns:</p> <pre><code>let (|A|_|) x =\n    if x = 2 then failwith \"x is two\"\n    elif x = 1 then Some()\n    else None\n\nlet (|B|_|) x =\n    if x=3 then failwith \"x is three\" else None\n\nlet (|C|) x = failwith \"got to C\"\n\nlet f x =\n    match x with\n    | 0 -&gt; 0\n    | A -&gt; 1\n    | B -&gt; 2\n    | C -&gt; 3\n    | _ -&gt; 4\n</code></pre> <p>These patterns evaluate as follows:</p> <pre><code>f 0 // 0\nf 1 // 1\nf 2 // failwith \"x is two\"\nf 3 // failwith \"x is three\"\nf 4 // failwith \"got to C\"\n</code></pre> <p>An active pattern function may be executed multiple times against the same pattern input during resolution of a single overall pattern match. The precise number of times that the active pattern function is executed against a particular pattern input is implementation-dependent.</p>"},{"location":"patterns/#73-as-patterns","title":"7.3 \u201cAs\u201d Patterns","text":"<p>An \u201cas\u201d pattern is of the following form:</p> <pre><code>pat as ident\n</code></pre> <p>The \u201cas\u201d pattern defines <code>ident</code> to be equal to the pattern input and matches the pattern input against <code>pat</code>. For example:</p> <pre><code>let t1 = (1, 2)\nlet (x, y) as t2 = t1\nprintfn \"%d-%d-%A\" x y t2 // 1- 2 - (1, 2)\n</code></pre> <p>This example binds the identifiers <code>x</code>, <code>y</code>, and <code>t1</code> to the values <code>1</code> , <code>2</code> , and <code>(1,2)</code>, respectively.</p>"},{"location":"patterns/#74-wildcard-patterns","title":"7.4 Wildcard Patterns","text":"<p>The pattern <code>_</code> is a wildcard pattern and matches any input. For example:</p> <pre><code>let categorize x =\n    match x with\n    | 1 - &gt; 0\n    | 0 -&gt; 1\n    | _ -&gt; 0\n</code></pre> <p>In the example, if <code>x</code> is <code>0</code>, the match returns <code>1</code>. If <code>x</code> has any other value, the match returns <code>0</code>.</p>"},{"location":"patterns/#75-disjunctive-patterns","title":"7.5 Disjunctive Patterns","text":"<p>A disjunctive pattern matches an input value against one or the other of two patterns:</p> <pre><code>pat | pat\n</code></pre> <p>At runtime, the pattern input is matched against the first pattern. If that fails, the pattern input is matched against the second pattern. Both patterns must bind the same set of variables with the same types. For example:</p> <pre><code>type Date = Date of int * int * int\n\nlet isYearLimit date =\n    match date with\n    | (Date (year, 1, 1) | Date (year, 12, 31)) -&gt; Some year\n    | _ -&gt; None\n\nlet result = isYearLimit (Date (2010,12,31))\n</code></pre> <p>In this example, <code>result</code> is given the value <code>true</code>, because the pattern input matches the second pattern.</p>"},{"location":"patterns/#76-conjunctive-patterns","title":"7.6 Conjunctive Patterns","text":"<p>A conjunctive pattern matches the pattern input against two patterns.</p> <pre><code>pat1 &amp; pat2\n</code></pre> <p>For example:</p> <pre><code>let (|MultipleOf|_|) n inp = if inp%n = 0 then Some (inp / n) else None\n\nlet result =\nmatch 56 with\n    | MultipleOf 4 m &amp; MultipleOf 7 n -&gt; m + n\n    | _ -&gt; false\n</code></pre> <p>In this example, <code>result</code> is given the value <code>22</code> (= 16 + 8), because the pattern input match matches both patterns.</p>"},{"location":"patterns/#77-list-patterns","title":"7.7 List Patterns","text":"<p>The pattern <code>pat :: pat</code> is a union case pattern that matches the \u201ccons\u201d union case of F# list values.</p> <p>The pattern <code>[]</code> is a union case pattern that matches the \u201cnil\u201d union case of F# list values.</p> <p>The pattern <code>[ pat1 ; ... ; patn ]</code> is shorthand for a series of <code>::</code> and empty list patterns <code>pat1 :: ... :: patn :: []</code>.</p> <p>For example:</p> <pre><code>let rec count x =\n    match x with\n    | [] -&gt; 0\n    | h :: t -&gt; h + count t\n\nlet result1 = count [1;2;3]\n\nlet result2 =\n    match [1;2;3] with\n    | [a;b;c] -&gt; a + b + c\n    | _ -&gt; 0\n</code></pre> <p>In this example, both <code>result1</code> and <code>result2</code> are given the value <code>6</code>.</p>"},{"location":"patterns/#78-type-annotated-patterns","title":"7.8 Type-annotated Patterns","text":"<p>A type-annotated pattern specifies the type of the value to match to a pattern.</p> <pre><code>pat : type\n</code></pre> <p>For example:</p> <pre><code>let rec sum xs =\n    match xs with\n    | [] -&gt; 0\n    | (h : int) :: t -&gt; h + sum t\n</code></pre> <p>In this example, the initial type of <code>h</code> is asserted to be equal to <code>int</code> before the pattern <code>h</code> is checked. Through type inference, this in turn implies that <code>xs</code> and <code>t</code> have static type <code>int list</code>, and <code>sum</code> has static type <code>int list -&gt; int</code>.</p>"},{"location":"patterns/#79-dynamic-type-test-patterns","title":"7.9 Dynamic Type-test Patterns","text":"<p>Dynamic type-test patterns have the following two forms:</p> <pre><code>:? type\n:? type as ident\n</code></pre> <p>A dynamic type-test pattern matches any value whose runtime type is <code>type</code> or a subtype of <code>type</code>. For example:</p> <pre><code>let message (x : System.Exception) =\n    match x with\n    | :? System.OperationCanceledException -&gt; \"cancelled\"\n    | :? System.ArgumentException -&gt; \"invalid argument\"\n    | _ -&gt; \"unknown error\"\n</code></pre> <p>If the type-test pattern is of the form <code>:? type as ident</code>, then the value is coerced to the given type and <code>ident</code> is bound to the result. For example:</p> <pre><code>let findLength (x : obj) =\nmatch x with\n    | :? string as s -&gt; s.Length\n    | _ -&gt; 0\n</code></pre> <p>In the example, the identifier <code>s</code> is bound to the value <code>x</code> with type <code>string</code>.</p> <p>If the pattern input has type <code>tyin</code>, pattern checking uses the same conditions as both a dynamic type- test expression <code>e :? type</code> and a dynamic coercion expression <code>e :?&gt; type</code> where <code>e</code> has type <code>tyin</code>. An error occurs if <code>type</code> cannot be statically determined to be a subtype of the type of the pattern input. A warning occurs if the type test will always succeed based on <code>type</code> and the static type of the pattern input.</p> <p>A warning is issued if an expression contains a redundant dynamic type-test pattern, after any coercion is applied. For example:</p> <pre><code>match box \"3\" with\n| :? string -&gt; 1\n| :? string -&gt; 1 // a warning is reported that this rule is \"never matched\"\n| _ -&gt; 2\n\nmatch box \"3\" with\n| :? System.IComparable -&gt; 1\n| :? string -&gt; 1 // a warning is reported that this rule is \"never matched\"\n| _ -&gt; 2\n</code></pre> <p>At runtime, a dynamic type-test pattern succeeds if and only if the corresponding dynamic type-test expression <code>e :? ty</code> would return true where <code>e</code> is the pattern input. The value of the pattern is bound to the results of a dynamic coercion expression <code>e :?&gt; ty</code>.</p>"},{"location":"patterns/#710-record-patterns","title":"7.10 Record Patterns","text":"<p>The following is a record pattern :</p> <pre><code>{ long-ident1 = pat1 ; ... ; long-identn = patn }\n</code></pre> <p>For example:</p> <pre><code>type Data = { Header:string; Size: int; Names: string list }\n\nlet totalSize data =\n    match data with\n    | { Header = \"TCP\"; Size = size; Names = names } -&gt; size + names.Length * 12\n    | { Header = \"UDP\"; Size = size } -&gt; size\n    | _ -&gt; failwith \"unknown header\"\n</code></pre> <p>The <code>long-identi</code> are resolved in the same way as field labels for record expressions and must together identify a single, unique F# record type. Not all record fields for the type need to be specified in the pattern.</p>"},{"location":"patterns/#711-array-patterns","title":"7.11 Array Patterns","text":"<p>An array pattern matches an array of a partciular length:</p> <pre><code>[| pat ; ... ; pat |]\n</code></pre> <p>For example:</p> <pre><code>let checkPackets data =\n    match data with\n    | [| \"HeaderA\"; data1; data2 |] -&gt; (data1, data2)\n    | [| \"HeaderB\"; data2; data1 |] -&gt; (data1, data2)\n    | _ -&gt; failwith \"unknown packet\"\n</code></pre>"},{"location":"patterns/#712-null-patterns","title":"7.12 Null Patterns","text":"<p>The null pattern null matches values that are represented by the CLI value null. For example:</p> <pre><code>let path =\n    match System.Environment.GetEnvironmentVariable(\"PATH\") with\n    | null -&gt; failwith \"no path set!\"\n    | res -&gt; res\n</code></pre> <p>Most F# types do not use <code>null</code> as a representation; consequently, the null pattern is generally used to check values passed in by CLI method calls and properties. For a list of F# types that use <code>null</code> as a representation, see \u00a75.4.8.</p>"},{"location":"patterns/#713-guarded-pattern-rules","title":"7.13 Guarded Pattern Rules","text":"<p>Guarded pattern rules have the following form:</p> <pre><code>pat when expr\n</code></pre> <p>For example:</p> <pre><code>let categorize x =\n    match x with\n    | _ when x &lt; 0 -&gt; - 1\n    | _ when x &lt; 0 -&gt; 1\n    | _ -&gt; 0\n</code></pre> <p>The guards on a rule are executed only after the match value matches the corresponding pattern. For example, the following evaluates to <code>2</code> with no output.</p> <pre><code>match (1, 2) with\n| (3, x) when (printfn \"not printed\"; true) -&gt; 0\n| (_, y) -&gt; y\n</code></pre>"},{"location":"program-structure-and-execution/","title":"12. Program Structure and Execution","text":"<p>F# programs are made up of a collection of assemblies. F# assemblies are made up of static references to existing assemblies, called the referenced assemblies , and an interspersed sequence of signature (<code>.fsi</code>) files, implementation (<code>.fs</code>) files, script (<code>.fsx</code> or <code>.fsscript</code>) files, and interactively executed code fragments.</p> <pre><code>implementation-file :=\n    namespace-decl-group ... namespace-decl-group\n    named-module\n    anonynmous-module\n\nscript-file := implementation-file  -- script file, additional directives allowed\n\nsignature-file :=\n    namespace-decl-group-signature ... namespace-decl-group-signature\n    anonynmous-module-signature\n    named-module-signature\n\nnamed-module :=\n    module long-ident module-elems\n\nanonymous-module :=\n    module-elems\n\nnamed-module-signature :=\n    module long-ident module-signature-elements\n\nanonymous-module-signature :=\n    module-signature-elements\n\nscript-fragment :=\n    module-elems                    -- interactively entered code fragment\n</code></pre> <p>A sequence of implementation and signature files is checked as follows.</p> <ol> <li> <p>Form an initial environment <code>sig-env0</code> and <code>impl-env0</code> by adding all assembly references to the     environment in the order in which they are supplied to the compiler. This means that the     following procedure is applied for each referenced assembly:</p> <ul> <li>Add the top level types, modules, and namespaces to the environment.</li> <li>For each <code>AutoOpen</code> attribute in the assembly, find the types, modules, and namespaces that    the attribute references and add these to the environment.</li> </ul> <p>The resulting environment becomes the active environment for the first file to be processed. 2. For each file: - If the <code>i</code>th file is a signature file <code>file.fsi</code>:</p> <pre><code>a. Check it against the current signature environment `sig-envi1`, which generates the\nsignature `Sigfile` for the current file.\n\nb. Add `Sigfile` to `sig-envi-1` to produce `sig-envi` to make it available for use in later\nsignature files.\n\nThe processing of the signature file has no effect on the implementation environment, so\n</code></pre> <p><code>impl-envi</code> is identical to <code>impl-envi-1</code>.</p> <ul> <li>If the file is an implementation file <code>file.fs</code>, check it against the environment <code>impl-envi-1</code>, which gives elaborated namespace declaration groups <code>Implfile</code>.</li> </ul> <p>a. If a corresponding signature <code>Sigfile</code> exists, check <code>Implfile</code> against <code>Sigfile</code> during this       process (\u00a711.2). Then add <code>Sigfile</code> to <code>impl-envi-1</code> to produce <code>impl-envi</code>. This step makes       the signature-constrained view of the implementation file available for use in later       implementation files. The processing of the implementation file has no effect on the       signature environment, so <code>sig-envi</code> is identical to <code>sig-envi-1</code>.</p> <p>b. If the implementation file has no signature file, add <code>Implfile</code> to both <code>sig-envi-1</code> and <code>impl-envi-1</code>,       to produce <code>sig-envi</code> and <code>impl-envi</code>. This makes the contents of the       implementation available for use in both later signature and implementation files.</p> </li> </ol> <p>The signature file for a particular implementation must occur before the implementation file in the compilation order. For every signature file, a corresponding implementation file must occur after the file in the compilation order. Script files may not have signatures.</p>"},{"location":"program-structure-and-execution/#121-implementation-files","title":"12.1 Implementation Files","text":"<p>Implementation files consist of one or more namespace declaration groups. For example:</p> <pre><code>namespace MyCompany.MyOtherLibrary\n\n    type MyType() =\n        let x = 1\n        member v.P = x + 2\n\n    module MyInnerModule =\n        let myValue = 1\n\nnamespace MyCompany. MyOtherLibrary.Collections\n\n    type MyCollection(x : int) =\n        member v.P = x\n</code></pre> <p>An implementation file that begins with a <code>module</code> declaration defines a single namespace declaration group with one module. For example:</p> <pre><code>module MyCompany.MyLibrary.MyModule\n\nlet x = 1\n</code></pre> <p>is equivalent to:</p> <pre><code>namespace MyCompany.MyLibrary\n\nmodule MyModule =\n    let x = 1\n</code></pre> <p>The final identifier in the <code>long-ident</code> that follows the <code>module</code> keyword is interpreted as the module name, and the preceding identifiers are interpreted as the namespace.</p> <p>Anonymous implementation files do not have either a leading <code>module</code> or <code>namespace</code> declaration. Only the scripts and the last file within an implementation group for an executable image (.exe) may be anonymous. An anonymous implementation file contains module definitions that are implicitly placed in a module. The name of the module is generated from the name of the source file by capitalizing the first letter and removing the filename extensionIf the filename contains characters that are not valid in an F# identifier, the resulting module name is unusable and a warning occurs.</p> <p>Given an initial environment <code>env0</code>, an implementation file is checked as follows:</p> <ul> <li>Create a new constraint solving context.</li> <li>Check the namespace declaration groups in the file against the existing environment <code>envi-1</code> and     incrementally add them to the environment (\u00a710.1) to create a new environment <code>envi</code>.</li> <li>Apply default solutions to any remaining type inference variables that include <code>default</code>     constraints. The defaults are applied in the order that the type variables appear in the type-     annotated text of the checked namespace declaration groups.</li> <li>Check the inferred signature of the implementation file against any required signature by using     Signature Conformance (\u00a711.2). The resulting signature of an implementation file is the required     signature, if it is present; otherwise it is the inferred signature.</li> <li>Report a \u201cvalue restriction\u201d error if the resulting signature of any item that is not a member,     constructor, function, or type function contains any free inference type variables.</li> <li>Choose solutions for any remaining type inference variables in the elaborated form of an     expression. Process any remaining type variables in the elaborated form from left-to-right to     find a minimal type solution that is consistent with constraints on the type variable. If no unique     minimal solution exists for a type variable, report an error.</li> </ul> <p>The result of checking an implementation file is a set of elaborated namespace declaration groups.</p>"},{"location":"program-structure-and-execution/#122-signature-files","title":"12.2 Signature Files","text":"<p>Signature files specify the functionality that is implemented by a corresponding implementation file. Each signature file contains a sequence of <code>namespace-decl-group-signature</code> elements. The inclusion of a signature file in compilation implicitly applies that signature type to the contents of a corresponding implementation file.</p> <p>Anonymous signature files do not have either a leading <code>module</code> or <code>namespace</code> declaration. Anonymous signature files contain <code>module-elems</code> that are implicitly placed in a module. The name of the module is generated from the name of the source file by capitalizing the first letter and removing the filename extension. If the filename contains characters that are not valid in an F# identifier, the resulting module name is unusable and a warning occurs.</p> <p>Given an initial environment <code>env</code> , a signature file is checked as follows:</p> <ul> <li>Create a new constraint solving context.</li> <li>Check each <code>namespace-decl-group-signaturei</code> in <code>envi-1</code> and add the result to that environment to     create a new environment <code>envi</code>.</li> </ul> <p>The result of checking a signature file is a set of elaborated namespace declaration group types.</p>"},{"location":"program-structure-and-execution/#123-script-files","title":"12.3 Script Files","text":"<p>Script files have the <code>.fsx</code> or <code>.fsscript</code> filename extension. They are processed in the same way as files that have the <code>.fs</code> extension, with the following exceptions:</p> <ul> <li>Side effects from all scripts are executed at program startup.</li> <li>For script files, the namespace <code>FSharp.Compiler.Interactive.Settings</code> is opened by default.</li> <li>F# Interactive references the assembly <code>FSharp.Compiler.Interactive.Settings.dll</code> by default,     but the F# compiler does not. If the script uses the script helper <code>fsi</code> object, then the script     should explicitly reference <code>FSharp.Compiler.Interactive.Settings.dll</code>.</li> </ul> <p>Script files may add to the set of referenced assemblies by using the <code>#r</code> directive (\u00a712.4).</p> <p>Script files may add other signature, implementation, and script files to the list of sources by using the <code>#load</code> directive. Files are compiled in the same order that was passed to the compiler, except that each script is searched for <code>#load</code> directives and the loaded files are placed before the script, in the order they appear in the script. If a filename appears in more than one <code>#load</code> directive, the file is placed in the list only once, at the position it first appeared.</p> <p>Script files may have <code>#nowarn</code> directives, which disable a warning for the entire compilation.</p> <p>The F# compiler defines the <code>COMPILED</code> compilation symbol for input files that it has processed. F# Interactive defines the <code>INTERACTIVE</code> symbol.</p> <p>Script files may not have corresponding signature files.</p>"},{"location":"program-structure-and-execution/#124-compiler-directives","title":"12.4 Compiler Directives","text":"<p>Compiler directives are declarations in non-nested modules or namespace declaration groups in the following form:</p> <pre><code># id string ... string\n</code></pre> <p>The lexical preprocessor directives <code>#if</code>, <code>#else</code>, <code>#endif</code> and <code>#indent \"off\"</code> are similar to compiler directives. For details on <code>#if</code>, <code>#else</code>, <code>#endif</code>, see \u00a73.3. The <code>#indent \"off\"</code> directive is described in \u00a719.4.</p> <p>The following directives are valid in all files:</p> Directive Example Short Description <code>#nowarn</code> <code>#nowarn \"54\"</code> For signature (<code>.fsi</code>) files and implementation (<code>.fs</code>) files, turns off warnings within this lexical scope.For script (<code>.fsx</code> or <code>.fsscript</code>) files, turns off warnings globally. <p>The following directives are valid in script files:</p> Directive Example Short Description <code>#r</code><code>#reference</code> <code>#r \"System.Core\"</code><code>#r @\"Nunit.Core.dll\"</code>&lt;br<code>#r @\"c:\\NUnit\\Nunit.Core.dll\"</code><code>#r \"nunit.core, Version=2.2.2.0, Culture=neutral,PublicKeyToken=96d09a1eb7f44a77\"</code> References a DLL within this entire script. <code>#I</code><code>#Include</code> <code>#I @\"c:\\Projects\\Libraries\\Bin\"</code> Adds a path to the search paths for DLLs that are referenced within this entire script.` <code>#load #load \"library.fs\"</code> <code>#load \"core.fsi\" \"core.fs\"</code> Loads a set of signature and implementation files into the script execution engine. <code>#time</code> <code>#time</code><code>#time \"on\"</code><code>#time \"off\"</code> Enables or disables the display of performance information, including elapsed real time, CPU time, and garbage collection information for each section of code that is interpreted and executed. <code>#help</code> <code>#help</code> Asks the script execution environment for help. <code>#q</code><code>#quit</code> <code>#q</code><code>#quit</code> Requests the script execution environment to halt execution and exit."},{"location":"program-structure-and-execution/#125-program-execution","title":"12.5 Program Execution","text":"<p>Execution of F# code occurs in the context of an executing CLI program into which one or more compiled F# assemblies or script fragments is loaded. During execution, the CLI program can use the functions, values, static members, and object constructors that the assemblies and script fragments define.</p>"},{"location":"program-structure-and-execution/#1251-execution-of-static-initializers","title":"12.5.1 Execution of Static Initializers","text":"<p>Each implementation file, script file, and script fragment involves a static initializer. The execution of the static initializer is triggered as follows:</p> <ul> <li>For executable (.exe) files that have an explicit entry point function, the static initializer for the     last file that appears on the command line is forced immediately as the first action in the     execution of the entry point function.</li> <li>For executable files that have an implicit entry point, the static initializer for the last file that     appears on the command line is the body of the implicit entry point function.</li> <li>For scripts, F# Interactive executes the static initializer for each program fragment immediately.</li> <li>For all other implementation files, the static initializer for the file is executed on first access of a     value that has observable initialization according to the rules that follow, or first access to any     member of any type in the file that has at least one \u201cstatic let\u201d or \u201cstatic do\u201d declaration.</li> </ul> <p>At runtime, the static initializer evaluates, in order, the definitions in the file that have observable initialization according to the rules that follow. Definitions with observable initialization in nested modules and types are included in the static initializer for the overall file.</p> <p>All definitions have observable initialization except for the following definitions in modules:</p> <ul> <li>Function definitions</li> <li>Type function definitions</li> <li>Literal definitions</li> <li>Value definitions that are generalized to have one or more type variables</li> <li>Non-mutable, non-thread-local values that are bound to an initialization constant expression ,     which is an expression whose elaborated form is one of the following:</li> <li>A simple constant expression.</li> <li>A null expression.</li> <li>A use of the <code>typeof&lt;_&gt;</code> or <code>sizeof&lt;_&gt;</code> operator from <code>FSharp.Core.Operators</code>, or the        <code>defaultof&lt;_&gt;</code> operator from <code>FSharp.Core.Operators.Unchecked</code>.</li> <li>A let expression where the constituent expressions are initialization constant expressions.</li> <li>A match expression where the input is an initialization constant expression, each case is a        test against a constant, and each target is an initialization constant expression.</li> <li>A use of one of the unary or binary operators <code>=</code>, <code>&lt;&gt;</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>, <code>+</code>, <code>-</code>, <code>*</code> , <code>&lt;&lt;&lt;</code>, <code>&gt;&gt;&gt;</code>, <code>|||</code>, <code>&amp;&amp;&amp;</code>, <code>^^^</code>,        <code>~~~</code>, <code>enum&lt;_&gt;</code>, <code>not</code>, <code>compare</code>, prefix <code>\u2013</code>, and prefix <code>+</code> from <code>FSharp.Core.Operators</code> on one or two        arguments, respectively. The arguments themselves must be initialization constant        expressions, but cannot be operations on decimals or strings. Note that the operators are        unchecked for arithmetic operations, and that the operators <code>%</code> and <code>/</code> are not included        because their use can raise division-by-zero exceptions.</li> <li>A use of a <code>[&lt;Literal&gt;]</code> value.</li> <li>A use of a case from an enumeration type.</li> <li>A use of a null case from a union type.</li> <li>A use of a value that is defined in the same assembly and does not have observable        initialization, or the use of a value that is defined by a <code>let</code> or <code>match</code> expression within the        expression itself.</li> </ul> <p>If the execution environment supports the concurrent execution of multiple threads of F# code, each static initializer runs as a mutual exclusion region. The use of a mutual exclusion region ensures that if another thread attempts to access a value that has observable initialization, that thread pauses until static initialization is complete. A static initializer runs only once, on the first thread that acquires entry to the mutual exclusion region.</p> <p>Values that have observable initialization have implied CLI fields that are private to the assembly. If such a field is accessed by using CLI reflection before the execution of the corresponding initialization code, then the default value for the type of the field will be returned.</p> <p>Within implementation files, generic types that have static value definitions receive a static initializer for each generic instantiation. These initializers are executed immediately before the first dereference of the static fields for the generic type, subject to any limitations present in the specific CLI implementation in used. If the static initializer for the enclosing file is first triggered during execution of the static initializer for a generic instantiation, references to static values definition in the generic class evaluate to the default value.</p> <p>For example, if external code accesses <code>data</code> in this example, the static initializer runs and the program prints \u201chello\u201d:</p> <pre><code>module LibraryModule\nprintfn \"hello\"\nlet data = new Dictionary&lt;int,int&gt;()\n</code></pre> <p>That is, the side effect of printing \u201chello\u201d is guaranteed to be triggered by an access to the value <code>data</code>.</p> <p>If external code calls <code>id</code> or accesses <code>size</code> in the following example, the execution of the static initializer is not yet triggered. However if external code calls <code>f()</code>, the execution of the static initializer is triggered because the body refers to the value <code>data</code>, which has observable initialization.</p> <pre><code>module LibraryModule\nprintfn \"hello\"\nlet data = new Dictionary&lt;int,int&gt;()\nlet size = 3\nlet id x = x\nlet f() = data\n</code></pre> <p>All of the following represent definitions that do not have observable initialization because they are initialization constant expressions.</p> <pre><code>let x = System.DayOfWeek.Friday\nlet x = 1.0\nlet x = \"two\"\nlet x = enum&lt;System.DayOfWeek&gt;(0)\nlet x = 1 + 1\nlet x : int list = []\nlet x : int option = None\nlet x = compare 1 1\nlet x = match true with true -&gt; 1 | false -&gt; 2\nlet x = true &amp;&amp; true\nlet x = 42 &gt;&gt;&gt; 2\nlet x = typeof&lt;int&gt;\nlet x = Unchecked.defaultof&lt;int&gt;\nlet x = Unchecked.defaultof&lt;string&gt;\nlet x = sizeof&lt;int&gt;\n</code></pre>"},{"location":"program-structure-and-execution/#1252-explicit-entry-point","title":"12.5.2 Explicit Entry Point","text":"<p>The last file that is specified in the compilation order for an executable file may contain an explicit entry point. The entry point is indicated by annotating a function in a module with <code>EntryPoint</code> attribute:</p> <ul> <li>The <code>EntryPoint</code> attribute applies only to a \u201clet\u201d-bound function in a module. The function cannot     be a member.</li> <li>This attribute can apply to only one function, and the function must be the last declaration in the     last file processed on the command line. The function may be in a nested module.</li> <li>The function is asserted to have type <code>string[] -&gt; int</code> before type checking. If the assertion fails,     an error occurs.</li> <li>At runtime, the entry point is passed one argument at startup: an array that contains the same     entries as <code>System.Environment.GetCommandLineArgs()</code>, minus the first entry in that array.</li> </ul> <p>The function becomes the entry point to the program. At startup, F# immediately forces execution of the static initializer for the file in which the function is declared, and then evaluates the body of the function.</p>"},{"location":"program-structure/","title":"2. Program Structure","text":"<p>The inputs to the F# compiler or the F# Interactive dynamic compiler consist of:</p> <ul> <li>Source code files, with extensions <code>.fs</code>, <code>.fsi</code>, <code>.fsx</code>, or <code>.fsscript</code>.</li> <li>Files with extension <code>.fs</code> must conform to grammar element <code>implementation-file</code> in \u00a712.1.</li> <li>Files with extension <code>.fsi</code> must conform to grammar element <code>signature-file</code> in \u00a712.2.</li> <li>Files with extension <code>.fsx</code> or <code>.fsscript</code> must conform to grammar element <code>script-file</code> in       \u00a712.3.</li> <li>Script fragments (for F# Interactive). These must conform to grammar element <code>script-fragment</code>.   Script fragments can be separated by <code>;;</code> tokens.</li> <li>Assembly references that are specified by command line arguments or interactive directives.</li> <li>Compilation parameters that are specified by command line arguments or interactive directives.</li> <li>Compiler directives such as <code>#time</code>.</li> </ul> <p>The <code>COMPILED</code> compilation symbol is defined for input that the F# compiler has processed. The <code>INTERACTIVE</code> compilation symbol is defined for input that F# Interactive has processed.</p> <p>Processing the source code portions of these inputs consists of the following steps:</p> <ol> <li>Decoding. Each file and source code fragment is decoded into a stream of Unicode characters, as    described in the C# specification, sections 2.3 and 2.4. The command-line options may specify a    code page for this process.</li> <li>Tokenization. The stream of Unicode characters is broken into a token stream by the lexical    analysis described in \u00a73.</li> <li>Lexical Filtering. The token stream is filtered by a state machine that implements the rules    described in \u00a715. Those rules describe how additional (artificial) tokens are inserted into the    token stream and how some existing tokens are replaced with others to create an augmented    token stream.</li> <li>Parsing. The augmented token stream is parsed according to the grammar specification in this    document.</li> <li>Importing. The imported assembly references are resolved to F# or CLI assembly specifications,    which are then imported. From the F# perspective, this results in the pre-definition of numerous    namespace declaration groups (\u00a712.1), types and type provider instances. The namespace    declaration groups are then combined to form an initial name resolution environment (\u00a714.1).</li> <li>Checking. The results of parsing are checked one by one. Checking involves such procedures as    Name Resolution (\u00a714.1), Constraint Solving (\u00a714.5), and Generalization (\u00a714.6.7), as well as the    application of other rules described in this specification.    Type inference uses variables to represent unknowns in the type inference problem. The various    checking processes maintain tables of context information including a name resolution    environment and a set of current inference constraints. After the processing of a file or program    fragment is complete, all such variables have been either generalized or resolved and the type    inference environment is discarded.</li> <li>Elaboration. One result of checking is an elaborated program fragment that contains elaborated    declarations, expressions, and types. For most constructs, such as constants, control flow, and    data expressions, the elaborated form is simple. Elaborated forms are used for evaluation, CLI    reflection, and the F# expression trees that are returned by quoted expressions (\u00a76.8).</li> <li>Execution. Elaborated program fragments that are successfully checked are added to a    collection of available program fragments. Each fragment has a static initializer. Static initializers    are executed as described in (\u00a712.5).</li> </ol>"},{"location":"provided-types/","title":"16. Provided Types","text":"<p>Type providers are extensions provided to an F# compiler or interpreter which provide information about types available in the environment for the F# code being analysed.</p> <p>The compilation context is augmented with a set of <code>type provider instances</code>. A type provider instance is interrogated for information through <code>type provider invocations</code> (TPI). Type provider invocations are all executed at compile-time. The type provider instance is not required at runtime.</p> <p>Wherever an operation on a provided namespace, provided type definition or provided member is mentioned in this section, it is assumed to be a compile-time type provider invocation. The exact protocol used to implement type provider invocations and communicate between an F# compiler/interpreter and type provider instances is implementation dependent. As of this release of F#,     - a type provider is a .NET 4.x binary component referenced as an imported assembly       reference. The assembly should have a <code>TypeProviderAssemblyAttribute</code>, with at       least one component marked with <code>TypeProviderAttribute</code>.     - a type provider instance is an object created for a component marked with       <code>TypeProviderAttribute</code>.     - provided type definitions are <code>System.Type</code> objects returned by a type provider       instance.     - provided methods are <code>System.Reflection.MethodInfo</code> objects returned by a type       provider instance.     - provided constructors are <code>System.Reflection.ConstructorInfo</code> objects returned by       a type provider instance.     - provided properties are <code>System.Reflection.PropertyInfo</code> objects returned by a type       provider instance.     - provided events are <code>System.Reflection.EventInfo</code> objects returned by a type       provider instance.     - provided literal fields are <code>System.Reflection.FieldInfo</code> objects returned by a type       provider instance.     - provided parameters are <code>System.Reflection.ParameterInfo</code> objects returned by a       type provider instance.     - provided static parameters are <code>System.Reflection.ParameterInfo</code> objects returned       by a type provider instance.     - provided attributes are attribute value objects returned by a type provider instance.</p>"},{"location":"provided-types/#161-static-parameters","title":"16.1 Static Parameters","text":"<p>The syntax of types in F# is expanded to include static parameters, including named static parameters:</p> <pre><code>type-arg =\n    static-parameter\nstatic-parameter =\n    static-parameter-value\n    id = static-parameter-value\n\nstatic-parameter-value =\n    const expr\n    simple-constant-expression\n</code></pre> <p>References to provided types may include static parameters, e.g.</p> <pre><code>type SomeService = ODataService&lt;\"http://some.url.org/service\"&gt;\n</code></pre> <p>Static parameters which are constant expressions, but not simple literal constants, may be specified using the const keyword, e.g.</p> <pre><code>type SomeService = CsvFile&lt;const (__SOURCE_DIRECTORY__ + \"/a.csv\")&gt;\n</code></pre> <p>Parentheses are needed around any simple constants expressions after \u201cconst\u201d that are not simple literal constants, e.g.</p> <pre><code>type K = N.T&lt; const (+1) &gt;\n</code></pre> <p>During checking of a type <code>A&lt;ype-args&gt;</code>, where A is a provided type, the TPM <code>GetStaticParameters</code> is invoked to determine the static parameters for the type A if any. If the static parameters exist and are of the correct kinds, the TPM <code>ApplyStaticArguments</code> is invoked to apply the static arguments to the provided type.</p> <p>During checking of a method <code>M&lt;type-args&gt;</code>, where M is a provided method definition, the TPM <code>GetStaticParametersForMethod</code> is invoked to determine the static parameters if any. If the static parameters exist and are of the correct kinds, the TPM <code>ApplyStaticArgumentsForMethod</code> is invoked to apply the static arguments to the provided method.</p> <p>In both cases a static parameter value must be given for each non-optional static parameter.</p>"},{"location":"provided-types/#1611-mangling-of-static-parameter-values","title":"16.1.1 Mangling of Static Parameter Values","text":"<p>Static parameter values are encoded into the names used for types and methods within F# metadata. The encoding scheme used is</p> <pre><code>encoding (A&lt;arg1,...,argN&gt;) =\n\n  typeOrMethodName,ParamName1= encoding(arg1),..., ParamNameN=encoding(argN)\n\nencoding(v) = \"s\"\n</code></pre> <p>where s is the result applying the F# <code>string</code> operator to v (using invariant numeric formatting), and in the result <code>\"</code> is replaced by <code>\\\"</code> and <code>\\</code> by <code>\\\\</code></p>"},{"location":"provided-types/#162-provided-namespaces","title":"16.2 Provided Namespaces","text":"<p>Each type provider instance in the assembly context reports a collection of provided namespaces though the <code>GetNamespaces</code> type provider method. Each provided namespace can in turn report further namespaces through the <code>GetNestedNamespaces</code> type provider method.</p>"},{"location":"provided-types/#163-provided-type-definitions","title":"16.3 Provided Type Definitions","text":"<p>Each provided namespace reports provided type definitions though the <code>GetTypes</code> and <code>ResolveTypeName</code> type provider methods. The type provider is obliged to ensure that these two methods return consistent results.</p> <p>Name resolution for unqualified identifiers may return provided type definitions if no other resolution is available.</p>"},{"location":"provided-types/#1631-generated-v-erased-types","title":"16.3.1 Generated v. Erased Types","text":"<p>Each provided type definition may be <code>generated</code> or <code>erased</code>. In this case, the types and method calls are removed entirely during compilation and replaced with other representations. When an erased type is used, the compiler will replace it with the first concrete type in its inheritance chain as returned by the TPM <code>type.BaseType</code>. The erasure of an erased interface type is <code>object</code>.</p> <ul> <li> <p>If it has a type definition under a path <code>D.E.F</code> , and the .Assembly of that type is in a different assembly A to the provider\u2019s assembly, then that type definition is a <code>generated</code> type definition. Otherwise, it is an erased type definition.</p> </li> <li> <p>Erased type definitions must return <code>TypeAttributes</code> with the <code>IsErased</code> flag set, value <code>0x40000000</code> and given by the F# literal <code>TypeProviderTypeAttributes.IsErased</code>.</p> </li> <li> <p>When a provided type definition is generated, its reported assembly <code>A</code> is treated as an injected assembly which is statically linked into the resulting assembly.</p> </li> <li> <p>Concrete type definitions (both provided and F#-authored) and object expressions may not inherit from erased types</p> </li> <li> <p>Concrete type definitions (both provided and F#-authored) and object expressions may not implement erased interfaces</p> </li> <li> <p>If an erased type definition reports an interface, its erasure must implement the erasure of that interface. The interfaces reported by an erased type definition must be unique up to erasure.</p> </li> <li> <p>Erased types may not be used as the target type of a runtime type test of runtime coercion.</p> </li> <li> <p>When determining uniqueness for F#-declared methods, uniqueness is determined after erasure of both provided types and units of measure.</p> </li> <li> <p>The elaborated form of F# expressions is after erasure of provided types.</p> </li> <li> <p>Two generated type definitions are equivalent if and only if they have the same F# path and name in the same assembly, once they are rooted according to their corresponding generative type definition.</p> </li> <li> <p>Two erased type definitions are only equivalent if they are provided by the same provider, using the same type name, with the same static arguments.</p> </li> </ul>"},{"location":"provided-types/#1632-type-references","title":"16.3.2 Type References","text":"<p>The elements of provided type definitions may reference other provided type definitions, and types from imported assemblies referenced in the compilation context. They may not reference type defined in the F# code currently being compiled.</p>"},{"location":"provided-types/#1633-static-parameters","title":"16.3.3 Static Parameters","text":"<p>A provided type definition may report a set of static parameters. For such a definition, all other provided contents are ignored.</p> <p>A provided method definition may also report a set of static parameters. For such a definition, all other provided contents are ignored.</p> <p>Static parameters may be optional and/or named, indicated by the <code>Attributes</code> property of the static parameter. For a given set of static parameters, no two static parameters may have the same name and named static arguments must come after all other arguments.</p>"},{"location":"provided-types/#1634-kind","title":"16.3.4 Kind","text":"<ul> <li> <p>Provided type definitions may be classes. This includes both erased and concrete types. This corresponds to the <code>type.IsClass</code> property returning true for the provided type definition.</p> </li> <li> <p>Provided type definitions may be interfaces. This includes both erased and concrete types. This corresponds to the <code>type.IsInterface</code> property returning true. Only one of <code>IsInterface</code>, <code>IsClass</code>, <code>IsStruct</code>, <code>IsEnum</code>, <code>IsDelegate</code>, <code>IsArray</code> may return true.</p> </li> <li> <p>Provided type definitions may be static classes. This includes both erased and concrete types.</p> </li> <li> <p>Provided type definitions may be sealed.</p> </li> <li> <p>Provided type definitions may not be arrays. This means the <code>type.IsArray</code> property must always return false. Provided types used in return types and argument positions may be array <code>symbol</code> types, see below.</p> </li> <li> <p>By default, provided type definitions which are reference types are considered to support <code>null</code> literals.  A provided type definition may have the <code>AllowNullLiteralAttribute</code> with value <code>false</code> in which case the type is considered to have null as an abnormal value.</p> </li> </ul>"},{"location":"provided-types/#1635-inheritance","title":"16.3.5 Inheritance","text":"<ul> <li>Provided type definitions may report base types.</li> <li>Provided type definition may report interfaces.</li> </ul>"},{"location":"provided-types/#1636-members","title":"16.3.6 Members","text":"<ul> <li> <p>Provided type definitions may report methods.</p> <p>This corresponds to non-null results from the <code>type.GetMethod</code> and <code>type.GetMethods</code> of the provided type definition. The results returned by these methods must be consistent.</p> </li> <li> <p>Provided methods may be static, instance and abstract</p> </li> <li>Provided methods may not be class constructors (.cctor). By .NET rules these would have to be private anyway.</li> <li> <p>Provided methods may be operators such as op_Addition.</p> </li> <li> <p>Provided type definitions may report properties.</p> <p>This corresponds to non-null results from the <code>type.GetProperty</code> and <code>type.GetProperties</code> of the provided type definition. The results returned by these methods must be consistent.</p> </li> <li> <p>Provided properties may be static or instance</p> </li> <li> <p>Provided properties may be indexers. This corresponds to reporting methods with     name Item , or as identified by <code>DefaultMemberAttribute</code> non-null results from the     <code>type.GetEvent</code> and <code>type.GetEvents</code> of the provided type definition. The results     returned by these methods must be consistent. This includes 1D, 2D, 3D and 4D     indexer access notation in F# (corresponding to different numbers of parameters to     the indexer property).</p> </li> <li> <p>Provided type definitions may report constructors.</p> <p>This corresponds to non-null results from the type.GetConstructor and type.GetConstructors of the provided type definition. The results returned by these methods must be consistent.</p> </li> <li> <p>Provided type definitions may report events.</p> <p>This corresponds to non-null results from the type.GetEvent and type.GetEvents of the provided type definition. The results returned by these methods must be consistent.</p> </li> <li> <p>Provided type definitions may report nested types.</p> <p>This corresponds to non-null results from the type.GetNestedType and type.GetNestedTypes of the provided type definition. The results returned by these methods must be consistent.</p> </li> <li> <p>The nested types of an erased type may be generated types in a generated     assembly. The <code>type.DeclaringType</code> property of the nested type need not report the     erased type.</p> </li> <li> <p>Provided type definitions may report literal (constant) fields.</p> <p>This corresponds to non-null results from the <code>type.GetField</code> and <code>type.GetFields</code> of the provided type definition, and is related to the fact that provided types may be enumerations. The results returned by these methods must be consistent.</p> </li> <li> <p>Provided type definitions may not report non-literal (i.e. non-const) fields</p> <p>This is a deliberate feature limitation, because in .NET, non-literal fields should not appear in public API surface area.</p> </li> </ul>"},{"location":"provided-types/#1637-attributes","title":"16.3.7 Attributes","text":"<ul> <li> <p>Provided type definitions, properties, constructors, events and methods may report attributes.</p> <p>This includes <code>ObsoleteAttribute</code> and <code>ParamArrayAttribute</code> attributes</p> </li> </ul>"},{"location":"provided-types/#1638-accessibility","title":"16.3.8 Accessibility","text":"<ul> <li> <p>All erased provided type definitions must be public</p> <p>However, concrete provided types are each in an assembly A that gets statically linked into the resulting F# component. These assemblies may contain private types and methods. These types are not directly \u201cprovided\u201d types, since they are not returned to the compiler by the API, but they are part of the closure of the types that are being embedded.</p> </li> </ul>"},{"location":"provided-types/#1639-elaborated-code","title":"16.3.9 Elaborated Code","text":"<p>Elaborated uses of provided methods are erased to elaborated expressions returned by the TPM <code>GetInvokerExpression</code>. In the current release of F#, replacement elaborated expressions are specified via F# quotation values composed of quotations constructed with respect to the referenced assemblies in the compilation context according to the following quotation library calls:</p> <ul> <li>Expr.NewArray</li> <li>Expr.NewObject</li> <li>Expr.WhileLoop</li> <li>Expr.NewDelegate</li> <li>Expr.ForIntegerRangeLoop</li> <li>Expr.Sequential</li> <li>Expr.TryWith</li> <li>Expr.TryFinally</li> <li>Expr.Lambda</li> <li>Expr.Call</li> <li>Expr.Constant</li> <li>Expr.DefaultValue</li> <li>Expr.NewTuple</li> <li>Expr.TupleGet</li> <li>Expr.TypeAs</li> <li>Expr.TypeTest</li> <li>Expr.Let</li> <li>Expr.VarSet</li> <li>Expr.IfThenElse</li> <li>Expr.Var</li> </ul> <p>The type of the quotation expression returned by <code>GetInvokerExpression</code> must be an erased type. The type provider is obliged to ensure that this type is equivalent to the erased type of the expression it is replacing.</p>"},{"location":"provided-types/#16310-further-restrictions","title":"16.3.10 Further Restrictions","text":"<ul> <li> <p>If a provided type definition reports a member with <code>ExtensionAttribute</code>, it is not treated as an extension member</p> </li> <li> <p>Provided type and method definitions may not be generic</p> <p>This corresponds to   - <code>GetGenericArguments</code> returning length 0   - For type definitions, <code>IsGenericType</code> and <code>IsGenericTypeDefinition</code> returning false   - For method definitions, <code>IsGenericMethod</code> and <code>IsGenericMethodDefinition</code> returning false</p> </li> </ul>"},{"location":"rfc-status/","title":"RFC status","text":"Version Feature ID Feature with RFC Link Status F# 4.0 N/A Auto Quotation This was already covered (see \u00a7 and the FSharp.Core documentation) F# 4.0 N/A Class Names As Functions completed F# 4.0 N/A Core Library Functions This was replaced by the RFC \"List, Seq, Array Additions\", see below F# 4.0 N/A Extended If Grammar This was already covered (see \u00a7) F# 4.0 N/A Extension Property Initializers This was already covered (see \u00a7, item 4, 5th bullet, second sub-bullet, second sentence) F# 4.0 N/A List, Seq, Array Additions This is documented in the FSharp.Core documentation. FSharp.Core functionality is not documented in detail in this spec, except as needed for reference (see \u00a7) F# 4.0 N/A Microsoft Optional Both library documentation and spec were adapted already. F# 4.0 N/A Multi-Interface Instantiation included in FS-1031 (see below) F# 4.0 N/A Non-Null Provided Types This was already covered (see \u00a7) F# 4.0 N/A Printf Units of Measure completed F# 4.0 N/A Static Method Arguments This was already covered (see \u00a7) F# 4.1 FS-1002 Cartesian Product for Collections This specifies a detail of the <code>FSharp.Core</code> library, which is not part of this spec (except for the basic items listed in \u00a7) F# 4.1 FS-1004 Result Type completed F# 4.1 FS-1005 Underscores in Numeric Literals completed F# 4.1 FS-1006 Struct Tuples completed F# 4.1 FS-1007 Additional Option Module Functions This specifies some details of the <code>FSharp.Core</code> library, which is not part of this spec (except for the basic items listed in \u00a718) F# 4.1 FS-1008 Struct Records completed F# 4.1 FS-1009 Mutually Referential Types and Modules in Single Scope F# 4.1 FS-1010 Add Map.count This specifies some details of the <code>FSharp.Core</code> library, which is not part of this spec (except for the basic items listed in \u00a718) F# 4.1 FS-1012 Caller Info Attributes completed F# 4.1 FS-1013 Enable Reflection Functionality on Portable Profiles F# 4.1 FS-1014 Struct Discriminated Unions F# 4.1 FS-1015 Support for fixed completed F# 4.1 FS-1016 Unreserve Keywords completed F# 4.1 FS-1017 Fix SRTP Constraint Parsing F# 4.1 FS-1018 Adjust Extensions Method Scope F# 4.1 FS-1019 Implicitly Add the Module Suffix completed F# 4.1 FS-1020 ByRef Returns F# 4.1 FS-1025 Improve Record Type Inference F# 4.1 FS-1027 Complete Optional DefaultParameterValue completed F# 4.1 FS-1029 Implement IReadOnlyCollection in list F# 4.1 FS-1040 Enum Match F# 4.5 FS-1047 Match Bang completed F# 4.5 FS-1053 Span F# 4.5 FS-1054 Undent List Args completed F# 4.5 FS-1055 Subsumption for Yield in Sequence Expression F# 4.5 FS-1058 Make Enum Cases Public F# 4.6 FS-1030 Anonymous Records F# 4.7 FS-1046 Wildcard Self Identifiers F# 4.7 FS-1069 Implicit Yields F# 4.7 FS-1070 Offside Relaxations F# 5.0 FS-1001 String Interpolation F# 5.0 FS-1003 Nameof Operator F# 5.0 FS-1031 Allow Implementing Same Interface at Different Generic Instantiations completed F# 5.0 FS-1063 Support LetBang and AndBang for Applicative Functors F# 5.0 FS-1068 Open Type Declaration F# 5.0 FS-1071 Witness Passing Quotations F# 5.0 FS-1074 Default Interface Member Consumption F# 5.0 FS-1075 Nullable Interop F# 5.0 FS-1077 3D/4D Fixed Index Slicing F# 5.0 FS-1077 Tolerant Slicing F# 5.0 FS-1080 Float32 Without Dot completed F# 5.0 FS-1082 Uint Type Abbreviation F# 5.0 FS-1085 Nameof Pattern F# 5.0 FS-1089 Allow String Everywhere F# 6.0 FS-1039 Struct Representation for Active Patterns F# 6.0 FS-1056 Allow Custom Operation Overloads F# 6.0 FS-1087 Resumable Code F# 6.0 FS-1091 Extend Units of Measure completed F# 6.0 FS-1093 Additional Conversions F# 6.0 FS-1097 Task Builder F# 6.0 FS-1098 Inline If Lambda F# 6.0 FS-1099 List Collector F# 6.0 FS-1100 Printf Binary F# 6.0 FS-1102 Discards on Use Bindings F# 6.0 FS-1104 Struct Representations F# 6.0 FS-1105 Non-variable Patterns to the Right of As Patterns F# 6.0 FS-1107 Allow Attributes After the Module Keyword F# 6.0 FS-1108 Undentation Frenzy F# 6.0 FS-1109 Additional Intrinsics for the NativePtr Module F# 6.0 FS-1110 Index Syntax F# 6.0 FS-1111 RefCell Op Information Messages F# 6.0 FS-1113 Insert Remove Update Functions F# 6.0 FS-1114 ML Compat Revisions F# 7.0 FS-1024 Simplify Constrained Call Syntax F# 7.0 FS-1083 SRTP Type No Whitespace F# 7.0 FS-1096 Map Min Max KeyValue F# 7.0 FS-1123 Result Module Parity with Option F# 7.0 FS-1124 Interfaces with Static Abstract Members F# 7.0 FS-1126 Allow Lower Case DU Cases when RequireQualifiedAccess is Specified F# 7.0 FS-1127 Init Only and Required Properties F# 7.0 FS-1131 NoCompilerInliningAttribute F# 7.0 FS-1133 Arithmetic in Literals F# 8.0 FS-1011 Warn on Recursive Without Tail Call F# 8.0 FS-1081 Extended Fixed Bindings F# 8.0 FS-1128 Allow Static Members in Interfaces F# 8.0 FS-1129 Shorthand Anonymous Unary Functions F# 8.0 FS-1132 Better Interpolated Triple Quoted Strings F# 8.0 FS-1134 Try With in Sequence Expressions F# 8.0 FS-1136 Constraint Intersection Syntax F# 9.0 FS-1060 Nullable Reference Types F# 9.0 FS-1079 Union Properties Visible F# 9.0 FS-1140 Boolean Returning and Return Type Directed Partial Active Patterns F# 9.0 FS-1144 Empty Bodied Computation Expressions F# 9.0 FS-1147 Non-String Directive Args"},{"location":"special-attributes-and-types/","title":"17. Special Attributes and Types","text":"<p>This chapter describes attributes and types that have special significance to the F# compiler.</p>"},{"location":"special-attributes-and-types/#171-custom-attributes-recognized-by-f","title":"17.1 Custom Attributes Recognized by F#","text":"<p>The following custom attributes have special meanings recognized by the F# compiler. Except where indicated, the attributes may be used in F# code, in referenced assemblies authored in F#, or in assemblies that are authored in other CLI languages.</p> Attribute Description System.ObsoleteAttribute  <code>[&lt;Obsolete(...)&gt;]</code> Indicates that the construct is obsolete and gives a warning or error depending on the settings in the attribute. This attribute may be used in both F# and imported assemblies. System.ParamArrayAttribute  <code>[&lt;ParamArray(...)&gt;]</code> When applied to an argument of a method, indicates that the method can accept a variable number of arguments. This attribute may be used in both F# and imported assemblies. System.ThreadStaticAttribute  <code>[&lt;ThreadStatic(...)&gt;]</code> Marks a mutable static value in a class as thread static. This attribute may be used in both F# and imported assemblies. System.ContextStaticAttribute  <code>[&lt;ContextStatic(...)&gt;]</code> Marks a mutable static value in a class as context static. This attribute may be used in both F# and imported assemblies. System.AttributeUsageAttribute  <code>[&lt;AttributeUsage(...)&gt;]</code> Specifies the attribute usage targets for an attribute. This attribute may be used in both F# and imported assemblies. System.Diagnostics.ConditionalAttribute  <code>[&lt;Conditional(...)&gt;]</code> Emits code to call the method only if the corresponding conditional compilation symbol is defined. This attribute may be used in both F# and imported assemblies. System.Reflection.AssemblyInformationalVersionAttribute  <code>[&lt;AssemblyInformationalVersion(...)&gt;]</code> Attaches additional version metadata to the compiled form of the assembly. This attribute may be used in both F# and imported assemblies. System.Reflection.AssemblyFileVersionAttribute  <code>[&lt;AssemblyFileVersion(...)&gt;]</code> Attaches file version metadata to the compiled form of the assembly. This attribute may be used in both F# and imported assemblies. System.Reflection.AssemblyDescriptionAttribute  <code>[&lt;AssemblyDescription(...)&gt;]</code> Attaches descriptive metadata to the compiled form of the assembly, such as the \u201cComments\u201d attribute in the Win32 version resource for the assembly. This attribute may be used in both F# and imported assemblies. System.Reflection.AssemblyTitleAttribute  <code>[&lt;AssemblyTitle(...)&gt;]</code> Attaches title metadata to the compiled form of the assembly, such as the \u201cProductName\u201d attribute in the Win32 version resource for the assembly. This attribute may be used in both F# and imported assemblies. System.Reflection.AssemblyCopyrightAttribute  <code>[&lt;AssemblyCopyright(...)&gt;]</code> Attaches copyright metadata to the compiled form of the assembly, such as the \u201cLegalCopyright\u201d attribute in the Win32 version resource for the assembly. This attribute may be used in both F# and imported assemblies. System.Reflection.AssemblyTrademarkAttribute  <code>[&lt;AssemblyTrademark(...)&gt;]</code> Attaches trademark metadata to the compiled form of the assembly, such as the \u201cLegalTrademarks\u201d attribute in the Win32 version resource for the assembly. This attribute may be used in both F# and imported assemblies. System.Reflection.AssemblyCompanyAttribute  <code>[&lt;AssemblyCompany(...)&gt;]</code> Attaches company name metadata to the compiled form of the assembly, such as the \u201cCompanyName\u201d attribute in the Win32 version resource for the assembly. This attribute may be used in both F# and imported assemblies. System.Reflection.AssemblyProductAttribute  <code>[&lt;AssemblyProduct(...)&gt;]</code> Attaches product name metadata to the compiled form of the assembly, such as the \u201cProductName\u201d attribute in the Win32 version resource for the assembly. This attribute may be used in both F# and imported assemblies. System.Reflection.AssemblyKeyFileAttribute  <code>[&lt;AssemblyKeyFile(...)&gt;]</code> Indicates to the F# compiler how to sign an assembly. This attribute may be used in both F# and imported assemblies. System.Reflection.DefaultMemberAttribute  <code>[&lt;DefaultMember(...)&gt;]</code> When applied to a type, specifies the name of the indexer property for that type. This attribute may be used in both F# and imported assemblies. System.Runtime.CompilerServices.CallerFilePathAttribute  <code>[&lt;CallerFilePath&gt;]</code> A string optional argument with this attribute will be given a runtime value matching the absolute file path of source of the callsite. This attribute may be used in both F# and imported assemblies. System.Runtime.CompilerServices.CallerLineNumberAttribute  <code>[&lt;CallerLineNumber&gt;]</code> An integer optional argument with this attribute will be given a runtime value matching the line number of the source of the callsite. This attribute may be used in both F# and imported assemblies. System.Runtime.CompilerServices.CallerMemberNameAttribute  <code>[&lt;CallerMemberName&gt;]</code> A string optional argument with this attribute will be given a runtime value matching the unqualified name of the enclosing member of the callsite. This attribute may be used in both F# and imported assemblies. System.Runtime.CompilerServices.InternalsVisibleToAttribute <code>[&lt;InternalsVisibleTo(...)&gt;]</code> Directs the F# compiler to permit access to the internals of the assembly. This attribute may be used in both F# and imported assemblies. System.Runtime.CompilerServices.TypeForwardedToAttribute <code>[&lt;TypeForwardedTo(...)&gt;]</code> Indicates a type redirection. This attribute may be used only in imported non-F# assemblies. It is not permitted in F# code. System.Runtime.CompilerServices.ExtensionAttribute  <code>[&lt;Extension(...)&gt;]</code> Indicates the compiled form of a C# extension member. This attribute may be used only in imported non-F# assemblies. It is not permitted in F# code. System.Runtime.InteropServices.DefaultParameterValueAttribute  <code>[&lt;DefaultParameterValue(...)&gt;]</code> When applied to a parameter in conjunction with the <code>[&lt;Optional&gt;]</code> attribute, specifies the default value to be inserted at the callsite. This attribute may be used in both F# and imported assemblies. System.Runtime.InteropServices.DllImportAttribute  <code>[&lt;DllImport(...)&gt;]</code> When applied to a function definition in a module, causes the F# compiler to ignore the implementation of the definition, and instead compile it as a CLI P/Invoke stub declaration. This attribute may be used in both F# and imported assemblies. System.Runtime.InteropServices.MarshalAsAttribute  <code>[&lt;MarshalAs(...)&gt;]</code> When applied to a parameter or return type, specifies the marshalling attribute for a CLI P/Invoke stub declaration. This attribute may be used in both F# and imported assemblies. However, F# does not support the specification of \"custom\" marshallers. System.Runtime.InteropServices.InAttribute  <code>[&lt;In&gt;]</code> When applied to a parameter, specifies the CLI In attribute. This attribute may be used in both F# and imported assemblies. However, in F# its only effect is to change the corresponding attribute in the CLI compiled form. System.Runtime.InteropServices.OutAttribute  <code>[&lt;Out&gt;]</code> When applied to a parameter, specifies the CLI Out attribute. This attribute may be used in both F# and imported assemblies. However, in F# its only effect is to change the corresponding attribute in the CLI compiled form. System.Runtime.InteropServices.OptionalAttribute  <code>[&lt;Optional(...)&gt;]</code> When applied to a parameter, specifies the CLI Optional attribute. Should be used in conjunction with <code>[&lt;DefaultParameterValue(...)&gt;]</code>. This attribute may be used in both F# and imported assemblies. System.Runtime.InteropServices.FieldOffsetAttribute  <code>[&lt;FieldOffset(...)&gt;]</code> When applied to a field, specifies the field offset of the underlying CLI field. This attribute may be used in both F# and imported assemblies. System.NonSerializedAttribute  <code>[&lt;NonSerialized&gt;]</code> When applied to a field, sets the \"not serialized\" bit for the underlying CLI field. This attribute may be used in both F# and imported assemblies. System.Runtime.InteropServices.StructLayoutAttribute  <code>[&lt;StructLayout(...)&gt;]</code> Specifies the layout of a CLI type. This attribute may be used in both F# and imported assemblies. FSharp.Core.AutoSerializableAttribute  <code>[&lt;AutoSerializable(false)&gt;]</code> When added to a type with value false , disables default serialization, so that F# does not make the type serializable. This attribute should be used only in F# assemblies. FSharp.Core.CLIMutableAttribute  <code>[&lt;CLIMutable&gt;]</code> When specified, a record type is compiled to a CLI representation with a default constructor with property getters and setters. This attribute should be used only in F# assemblies. FSharp.Core.AutoOpenAttribute  <code>[&lt;AutoOpen&gt;]</code> When applied to an assembly and given a string argument, causes the namespace or module to be opened automatically when the assembly is referenced. When applied to a module without a string argument, causes the module to be opened automatically when the enclosing namespace or module is opened. This attribute should be used only in F# assemblies. FSharp.Core. CompilationRepresentationAttribute  <code>[&lt;CompilationRepresentation(...)&gt;]</code> Adjusts the runtime representation of a type. This attribute should be used only in F# assemblies. FSharp.Core.CompiledNameAttribute  <code>[&lt;CompiledName(...)&gt;]</code> Changes the compiled name of an F# language construct. This attribute should be used only in F# assemblies. FSharp.Core.CustomComparisonAttribute  <code>[&lt;CustomComparison&gt;]</code> When applied to an F# structural type, indicates that the type has a user-specified comparison implementation. This attribute should be used only in F# assemblies. FSharp.Core.CustomEqualityAttribute  <code>[&lt;CustomEquality&gt;]</code> When applied to an F# structural type, indicates that the type has a user-defined equality implementation. This attribute should be used only in F# assemblies. FSharp.Core.DefaultAugmentationAttribute  <code>[&lt;DefaultAugmentation(...)&gt;]</code> When applied to an F# discriminated union type with value false, turns off the generation of standard helper member tester, constructor and accessor members for the generated CLI class for that type. This attribute should be used only in F# assemblies. FSharp.Core.DefaultValueAttribute  <code>[&lt;DefaultValue(...)&gt;]</code> When added to a field declaration, specifies that the field is not initialized. During type checking, a constraint is asserted that the field type supports null. If the argument to the attribute is <code>false</code>, the constraint is not asserted. This attribute should be used only in F# assemblies. FSharp.Core.GeneralizableValueAttribute  <code>[&lt;GeneralizableValue&gt;]</code> When applied to an F# value, indicates that uses of the attribute can result in generic code through the process of type inference. For example, <code>Set.empty</code>. The value must typically be a type function whose implementation has no observable side effects. This attribute should be used only in F# assemblies. FSharp.Core.LiteralAttribute  <code>[&lt;Literal&gt;]</code> When applied to a value, compiles the value as a CLI literal. This attribute should be used only in F# assemblies. FSharp.Core.NoDynamicInvocationAttribute  <code>[&lt;NoDynamicInvocation&gt;]</code> When applied to an inline function or member definition, replaces the generated code with a stub that throws an exception at runtime. This attribute is used to replace the default generated implementation of unverifiable inline members with a verifiable stub. This attribute should be used only in F# assemblies. FSharp.Core.CompilerMessageAttribute  <code>[&lt;CompilerMessage(...)&gt;]</code> When applied to an F# construct, indicates that the F# compiler should report a message when the construct is used. This attribute should be used only in F# assemblies. FSharp.Core.StructAttribute  <code>[&lt;Struct&gt;]</code> Indicates that a type is a struct type. This attribute should be used only in F# assemblies. FSharp.Core.ClassAttribute  <code>[&lt;Class&gt;]</code> Indicates that a type is a class type. This attribute should be used only in F# assemblies. FSharp.Core.InterfaceAttribute  <code>[&lt;Interface&gt;]</code> Indicates that a type is an interface type. This attribute should be used only in F# assemblies. FSharp.Core.MeasureAttribute  <code>[&lt;Measure&gt;]</code> Indicates that a type or generic parameter is a unit of measure definition or annotation. This attribute should be used only in F# assemblies. FSharp.Core.ReferenceEqualityAttribute  <code>[&lt;ReferenceEquality&gt;]</code> When applied to an F# record or union type, indicates that the type should use reference equality for its default equality implementation. This attribute should be used only in F# assemblies. FSharp.Core.ReflectedDefinitionAttribute  <code>[&lt;ReflectedDefinition&gt;]</code> Makes the quotation form of a definition available at runtime through the FSharp.Quotations. Expr.GetReflectedDefinition method. This attribute should be used only in F# assemblies. FSharp.Core. RequireQualifiedAccessAttribute  <code>[&lt;RequireQualifiedAccess&gt;]</code> When applied to an F# module, warns if an attempt is made to open the module name. When applied to an F# union or record type, indicates that the field labels or union cases must be referenced by using a qualified path that includes the type name. This attribute should be used only in F# assemblies. RequiresExplicitTypeArgumentsAttribute  <code>[&lt;RequiresExplicitTypeArguments&gt;]</code> When applied to an F# function or method, indicates that the function or method must be invoked with explicit type arguments, such as typeof. This attribute should be used only in F# assemblies. FSharp.Core.StructuralComparisonAttribute  <code>[&lt;StructuralComparison&gt;]</code> When added to a record, union, exception, or structure type, confirms the automatic generation of implementations for <code>IComparable</code> for the type. This attribute should only be used in F# assemblies. FSharp.Core.StructuralEqualityAttribute  <code>[&lt;StructuralEquality&gt;]</code> When added to a record, union, or struct type, confirms the automatic generation of overrides for <code>Equals</code> and <code>GetHashCode</code> for the type. This attribute should be used only in F# assemblies. FSharp.Core.VolatileFieldAttribute  <code>[&lt;VolatileField&gt;]</code> When applied to an F# field or mutable value definition, controls whether the CLI volatile prefix is emitted before accesses to the field. This attribute should be used only in F# assemblies. FSharp.Core.TypeProviderXmlDocAttribute Specifies documentation for provided type definitions and provided members FSharp.Core.TypeProviderDefinitionLocationAttribute Specifies location information for provided type definitions and provided members"},{"location":"special-attributes-and-types/#172-custom-attributes-emitted-by-f","title":"17.2 Custom Attributes Emitted by F#","text":"<p>The F# compiler can emit the following custom attributes:</p> Attribute Description System.Diagnostics.DebuggableAttribute Improves debuggability of F# code. System.Diagnostics.DebuggerHiddenAttribute Improves debuggability of F# code. System.Diagnostics.DebuggerDisplayAttribute Improves debuggability of F# code. System.Diagnostics.DebuggerBrowsableAttribute Improves debuggability of F# code. System.Runtime.CompilerServices.CompilationRelaxationsAttribute Enables extra JIT optimizations. System.Runtime.CompilerServices.CompilerGeneratedAttribute Indicates that a method, type, or property is generated by the F# compiler, and does not correspond directly  to user source code. System.Reflection.DefaultMemberAttribute Specifies the name of the indexer property for a class. FSharp.Core.CompilationMappingAttribute Indicates how a CLI construct corresponds to an F# source language construct. FSharp.Core.FSharpInterfaceDataVersionAttribute Defines the schema number for the embedded binary resource for F#-specific interface and optimization data. FSharp.Core.OptionalArgumentAttribute Indicates optional arguments to F# members."},{"location":"special-attributes-and-types/#173-custom-attributes-not-recognized-by-f","title":"17.3 Custom Attributes not Recognized by F#","text":"<p>The following custom attributes are defined in some CLI implementations and may appear to be relevant to F#. However, they either do not affect the behavior of the F# compiler, or result in an error when used in in F# code.</p> Attribute Description System.Runtime.CompilerServices.DecimalConstantAttribute The F# compiler ignores this attribute.However, if used in F# code, it can cause some other CLI languages to interpret a decimal constant as a compile-time literal. System.Runtime.CompilerServices.RequiredAttributeAttribute Do not use this attribute in F# code. The F# compiler ignores it or returns an error. System.Runtime.InteropServices.DefaultParameterValueAttribute Do not use this attribute in F# code.The F# compiler ignores it or returns an error. System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute Do not use this attribute in F# code.The F# compiler ignores it or returns an error. System.Runtime.CompilerServices.FixedBufferAttribute Do not use this attribute in F# code.The F# compiler ignores it or returns an error. System.Runtime.CompilerServices.UnsafeValueTypeAttribute Do not use this attribute in F# code.The F# compiler ignores it or returns an error. System.Runtime.CompilerServices.SpecialNameAttribute Do not use this attribute in F# code.The F# compiler ignores it or returns an error."},{"location":"special-attributes-and-types/#174-exceptions-thrown-by-f-language-primitives","title":"17.4 Exceptions Thrown by F# Language Primitives","text":"<p>Certain F# language and primitive library operations throw the following exceptions.</p> Attribute Description System.ArithmeticException An arithmetic operation failed. This is the base class for exceptions such as System.DivideByZeroException and System.OverflowException. System.ArrayTypeMismatchException An attempt to store an element in an array failed because the runtime type of the stored element is incompatible with the runtime type of the array. System.DivideByZeroException An attempt to divide an integral value by zero occurred. System.IndexOutOfRangeException An attempt to index an array failed because the index is less than zero or outside the bounds of the array. System.InvalidCastException An explicit conversion from a base type or interface to a derived type failed at run time. System.NullReferenceException A null reference was used in a way that caused the referenced object to be required. System.OutOfMemoryException An attempt to use new to allocate memory failed. System.OverflowException An arithmetic operation in a checked context overflowed. System.StackOverflowException The execution stack was exhausted because of too many pending method calls, which typically indicates deep or unbounded recursion. System.TypeInitializationException F# initialization code for a type threw an exception that was not caught."},{"location":"the-f-library-fsharpcoredll/","title":"18. The F# Library FSharp.Core.dll","text":"<p>All compilations reference the following two base libraries:</p> <ul> <li>The CLI base library <code>mscorlib.dll</code>.</li> <li>The F# base library <code>FSharp.Core.dll</code>.</li> </ul> <p>The API documentation of these libraries can be found at https://fsharp.github.io/fsharp-core-docs and https://learn.microsoft.com/dotnet/standard/runtime-libraries-overview, resp.</p> <p>The following namespaces are automatically opened for all F# code:</p> <pre><code>open FSharp\nopen FSharp.Core\nopen FSharp.Core.LanguagePrimitives\nopen FSharp.Core.Operators\nopen FSharp.Text\nopen FSharp.Collections\nopen FSharp.Core.ExtraTopLevelOperators\n</code></pre> <p>A compilation may open additional namespaces may be opened if the referenced F# DLLs contain <code>AutoOpenAttribute</code> declarations.</p>"},{"location":"the-f-library-fsharpcoredll/#181-basic-types-fsharpcore","title":"18.1 Basic Types (FSharp.Core)","text":"<p>This section provides details about the basic types that are defined in <code>FSharp.Core</code>.</p>"},{"location":"the-f-library-fsharpcoredll/#1811-basic-type-abbreviations","title":"18.1.1 Basic Type Abbreviations","text":"Type Name Description <code>obj</code> <code>System.Object</code> <code>exn</code> <code>System.Exception</code> <code>nativeint</code> <code>System.IntPtr</code> <code>unativeint</code> <code>System.UIntPtr</code> <code>string</code> <code>System.String</code> <code>float32</code>, <code>single</code> <code>System.Single</code> <code>float</code>, <code>double</code> <code>System.Double</code> <code>sbyte</code>, <code>int8</code> <code>System.SByte</code> <code>byte</code>, <code>uint8</code> <code>System.Byte</code> <code>int16</code> <code>System.Int16</code> <code>uint16</code> <code>System.UInt16</code> <code>int32</code>, <code>int</code> <code>System.Int32</code> <code>uint32</code> <code>System.UInt32</code> <code>int64</code> <code>System.Int64</code> <code>uint64</code> <code>System.UInt64</code> <code>char</code> <code>System.Char</code> <code>bool</code> <code>System.Boolean</code> <code>decimal</code> <code>System.Decimal</code>"},{"location":"the-f-library-fsharpcoredll/#1812-basic-types-that-accept-unit-of-measure-annotations","title":"18.1.2 Basic Types that Accept Unit of Measure Annotations","text":"Type Name Description <code>sbyte&lt;_&gt;</code> Underlying representation <code>System.SByte</code>, but accepts a unit of measure. <code>int16&lt;_&gt;</code> Underlying representation <code>System.Int16</code>, but accepts a unit of measure. <code>int32&lt;_&gt;</code> Underlying representation <code>System.Int32</code>, but accepts a unit of measure. <code>int64&lt;_&gt;</code> Underlying representation <code>System.Int64</code>, but accepts a unit of measure. <code>float32&lt;_&gt;</code> Underlying representation <code>System.Single</code>, but accepts a unit of measure. <code>float&lt;_&gt;</code> Underlying representation <code>System.Double</code>, but accepts a unit of measure. <code>decimal&lt;_&gt;</code> Underlying representation <code>System.Decimal</code>, but accepts a unit of measure."},{"location":"the-f-library-fsharpcoredll/#1813-the-nativeptr_-type","title":"18.1.3 The nativeptr&lt;_&gt; Type","text":"<p>When the <code>nativeptr&lt;type&gt;</code> is used in method argument or return position, it is represented in compiled CIL code as either:</p> <ul> <li>A CLI pointer type <code>type*</code>, if <code>type</code> does not contain any generic type parameters.</li> <li>T CLI type <code>System.IntPtr</code> otherwise.</li> </ul> <p>Note : CLI pointer types are rarely used. In CLI metadata, pointer types sometimes appear in CLI metadata unsafe object constructors for the CLI type <code>System.String</code>.  You can convert between <code>System.UIntPtr</code> and <code>nativeptr&lt;'T&gt;</code> by using the inlined unverifiable functions in <code>FSharp.NativeInterop.NativePtr</code>.  <code>nativeptr&lt;_&gt;</code> compiles in different ways because CLI restricts where pointer types can appear.</p>"},{"location":"the-f-library-fsharpcoredll/#182-basic-operators-and-functions-fsharpcoreoperators","title":"18.2 Basic Operators and Functions (FSharp.Core.Operators)","text":""},{"location":"the-f-library-fsharpcoredll/#1821-basic-arithmetic-operators","title":"18.2.1 Basic Arithmetic Operators","text":"<p>The following operators are defined in <code>FSharp.Core.Operators</code>:</p> Operator or Function Name Expression Form Description <code>(+)</code> <code>x + y</code> Overloaded addition. <code>(-)</code> <code>x - y</code> Overloaded subtraction. <code>(*)</code> <code>x * y</code> Overloaded multiplication. <code>(/)</code> <code>x / y</code> Overloaded division.For negative numbers, the behavior of this operator follows the definition of the corresponding operator in the C# specification. <code>(%)</code> <code>x % y</code> Overloaded remainder.For integer types, the result of x % y is the value produced by x \u2013 (x / y) * y. If y is zero, <code>System.DivideByZeroException</code> is thrown. The remainder operator never causes an overflow. This follows the definition of the remainder operator in the C# specification.For floating-point types, the behavior of this operator also follows the definition of the remainder operator in the C# specification. <code>(~-)</code> <code>-x</code> Overloaded unary negation. <code>not</code> <code>not x</code> Boolean negation."},{"location":"the-f-library-fsharpcoredll/#1822-generic-equality-and-comparison-operators","title":"18.2.2 Generic Equality and Comparison Operators","text":"<p>The following operators are defined in <code>FSharp.Core.Operators</code>:</p> Operator or Function Name Expression Form Description <code>(&lt;)</code> <code>x &lt; y</code> Generic less-than <code>(&lt;=)</code> <code>x &lt;= y</code> Generic less-than-or-equal <code>(&gt;)</code> <code>x &gt; y</code> Generic greater-than <code>(&gt;=)</code> <code>x &gt;= y</code> Generic greater-than-or-equal <code>(=)</code> <code>x = y</code> Generic equality <code>(&lt;&gt;)</code> <code>x &lt;&gt; y</code> Generic disequality <code>max</code> <code>max x y</code> Generic maximum <code>min</code> <code>min x y</code> Generic minimum"},{"location":"the-f-library-fsharpcoredll/#1823-bitwise-operators","title":"18.2.3 Bitwise Operators","text":"<p>The following operators are defined in <code>FSharp.Core.Operators</code>:</p> Operator or Function Name Expression Form Description <code>(&lt;&lt;&lt;)</code> <code>x &lt;&lt;&lt; y</code> Overloaded bitwise left-shift <code>(&gt;&gt;&gt;)</code> <code>x &gt;&gt;&gt; y</code> Overloaded bitwise arithmetic right-shift <code>(^^^)</code> <code>x ^^^ y</code> Overloaded bitwise exclusive or (XOR) <code>(&amp;&amp;&amp;)</code> <code>x &amp;&amp;&amp; y</code> Overloaded bitwise and <code>(\\|\\|\\|)</code> <code>x \\|\\|\\| y</code> Overloaded bitwise or <code>(~~~)</code> <code>~~~x</code> Overloaded bitwise negation"},{"location":"the-f-library-fsharpcoredll/#1824-math-operators","title":"18.2.4 Math Operators","text":"<p>The following operators are defined in <code>FSharp.Core.Operators</code>:</p> Operator or Function Name Expression Form Description <code>abs</code> <code>abs x</code> Overloaded absolute value <code>acos</code> <code>acos x</code> Overloaded inverse cosine <code>asin</code> <code>asin x</code> Overloaded inverse sine <code>atan</code> <code>atan x</code> Overloaded inverse tangent <code>atan2</code> <code>atan2 x y</code> Overloaded inverse tangent of x/y <code>ceil</code> <code>ceil x</code> Overloaded floating-point ceiling <code>cos</code> <code>cos x</code> Overloaded cosine <code>cosh</code> <code>cosh x</code> Overloaded hyperbolic cosine <code>exp</code> <code>exp x</code> Overloaded exponent <code>floor</code> <code>floor x</code> Overloaded floating-point floor <code>log</code> <code>log x</code> Overloaded natural logarithm <code>log10</code> <code>log10 x</code> Overloaded base-10 logarithm <code>(**)</code> <code>x ** y</code> Overloaded exponential <code>pown</code> <code>pown x y</code> Overloaded integer exponential <code>round</code> <code>round x</code> Overloaded rounding <code>sign</code> <code>sign x</code> Overloaded sign function <code>sin</code> <code>sin x</code> Overloaded sine function <code>sinh</code> <code>sinh x</code> Overloaded hyperbolic sine function <code>sqrt</code> <code>sqrt x</code> Overloaded square root function <code>tan</code> <code>tan x</code> Overloaded tangent function <code>tanh</code> <code>tanh x</code> Overloaded hyperbolic tangent function"},{"location":"the-f-library-fsharpcoredll/#1825-function-pipelining-and-composition-operators","title":"18.2.5 Function Pipelining and Composition Operators","text":"<p>The following operators are defined in <code>FSharp.Core.Operators</code>:</p> Operator or Function Name Expression Form Description <code>(\\|&gt;)</code> <code>x \\|&gt; f</code> Pipelines the value <code>x</code> to the function <code>f</code> (forward pipelining) <code>(&gt;&gt;)</code> <code>f &gt;&gt; g</code> Composes two functions, so that they are applied in order from left to right <code>(&lt;\\|)</code> <code>f &lt;\\| x</code> Pipelines the value <code>x</code> to the function <code>f</code> (backward pipelining) <code>(&lt;&lt;)</code> <code>g &lt;&lt; f</code> Composes two functions, so that they are applied in order from right to left (backward function composition) <code>ignore</code> <code>ignore x</code> Computes and discards a value"},{"location":"the-f-library-fsharpcoredll/#1826-object-transformation-operators","title":"18.2.6 Object Transformation Operators","text":"<p>The following operators are defined in <code>FSharp.Core.Operators</code>:</p> Operator or Function Name Expression Form Description <code>box</code> <code>box x</code> Converts to object representation. <code>hash</code> <code>hash x</code> Generates a hash value. <code>sizeof</code> <code>sizeof&lt;type&gt;</code> Computes the size of a value of the given type. <code>typeof</code> <code>typeof&lt;type&gt;</code> Computes the <code>System.Type</code> representation of the giventype. <code>typedefof</code> <code>typedefof&lt;type&gt;</code> Computes the <code>System.Type</code> representation of <code>type</code> and calls <code>GetGenericTypeDefinition</code> if it is a generic type. <code>unbox</code> <code>unbox x</code> Converts from object representation. <code>ref</code> <code>ref x</code> Allocates a mutable reference cell. <code>(!)</code> <code>!x</code> Reads a mutable reference cell."},{"location":"the-f-library-fsharpcoredll/#1827-pair-operators","title":"18.2.7 Pair Operators","text":"<p>The following operators are defined in <code>FSharp.Core.Operators</code>:</p> Operator or Function Name Expression Form Description <code>fst</code> <code>fst p</code> Returns the first element of a pair. <code>snd</code> <code>snd p</code> Returns the second element of a pair"},{"location":"the-f-library-fsharpcoredll/#1828-exception-operators","title":"18.2.8 Exception Operators","text":"<p>The following operators are defined in <code>FSharp.Core.Operators</code>:</p> Operator or Function Name Expression Form Description <code>failwith</code> <code>failwith x</code> Raises a <code>FailureException</code> exception. <code>invalidArg</code> <code>invalidArg x</code> Raises an <code>ArgumentException</code> exception. <code>raise</code> <code>raise x</code> Raises an `exception. reraise reraise() Rethrows the current exception."},{"location":"the-f-library-fsharpcoredll/#1829-inputoutput-handles","title":"18.2.9 Input/Output Handles","text":"<p>The following operators are defined in <code>FSharp.Core.Operators</code>:</p> Operator or Function Name Expression Form Description <code>stdin</code> <code>Stdin</code> Computes <code>System.Console.In</code>. <code>stdout</code> <code>Stdout</code> Computes <code>System.Console.Out</code>. <code>stderr</code> <code>Stderr</code> Computes <code>System.Console.Error</code>."},{"location":"the-f-library-fsharpcoredll/#18210-overloaded-conversion-functions","title":"18.2.10 Overloaded Conversion Functions","text":"<p>The following operators are defined in <code>FSharp.Core.Operators</code>:</p> Operator or Function Name Expression Form Description <code>byte</code> <code>byte x</code> Overloaded conversion to a byte <code>sbyte</code> <code>sbyte x</code> Overloaded conversion to a signed byte <code>int16</code> <code>int16 x</code> Overloaded conversion to a 16-bit integer <code>uint16</code> <code>uint16 x</code> Overloaded conversion to an unsigned 16-bit integer <code>int32</code>, <code>int</code> <code>int32 x</code>, <code>int x</code> Overloaded conversion to a 32-bit integer <code>uint32</code> <code>uint32 x</code> Overloaded conversion to an unsigned 32-bit integer <code>int64</code> <code>int64 x</code> Overloaded conversion to a 64-bit integer <code>uint64</code> <code>uint64 x</code> Overloaded conversion to an unsigned 64-bit integer <code>nativeint</code> <code>nativeint x</code> Overloaded conversion to an native integer <code>unativeint</code> <code>unativeint x</code> Overloaded conversion to an unsigned native integer <code>float</code>, <code>double</code> <code>float x</code>, <code>double x</code> Overloaded conversion to a 64-bit IEEE floating-point number <code>float32</code>, <code>single</code> <code>float32 x</code>, <code>single x</code> Overloaded conversion to a 32-bit IEEE floating-point number <code>decimal</code> <code>decimal x</code> Overloaded conversion to a System.Decimal number <code>char</code> <code>char x</code> Overloaded conversion to a System.Char value <code>enum</code> <code>enum x</code> Overloaded conversion to a typed enumeration value"},{"location":"the-f-library-fsharpcoredll/#183-checked-arithmetic-operators","title":"18.3 Checked Arithmetic Operators","text":"<p>The module <code>FSharp.Core.Operators.Checked</code> defines runtime-overflow-checked versions of the following operators:</p> Operator or Function Name Expression Form Description <code>(+)</code> <code>x + y</code> Checked overloaded addition <code>(-)</code> <code>x \u2013 y</code> Checked overloaded subtraction <code>(*)</code> <code>x * y</code> Checked overloaded multiplication (~-) <code>-x</code> Checked overloaded unary negation <code>byte</code> <code>byte x</code> Checked overloaded conversion to a byte <code>sbyte</code> <code>sbyte x</code> Checked overloaded conversion to a signed byte <code>int16</code> <code>int16 x</code> Checked overloaded conversion to a 16-bit integer <code>uint16</code> <code>uint16 x</code> Checked overloaded conversion to an unsigned 16-bit integer <code>int32</code>, <code>int</code> <code>int32 x</code>, <code>int x</code> Checked overloaded conversion to a 32-bit integer <code>uint32</code> <code>uint32 x</code> Checked overloaded conversion to an unsigned 32-bit integer <code>int64</code> <code>int64 x</code> Checked overloaded conversion to a 64 - bit integer <code>uint64</code> <code>uint64 x</code> Checked overloaded conversion to an unsigned 64-bit integer <code>nativeint</code> <code>nativeint x</code> Checked overloaded conversion to an native integer <code>unativeint</code> <code>unativeint x</code> Checked overloaded conversion to an unsigned native integer <code>char</code> <code>char x</code> Checked overloaded conversion to a <code>System.Char</code> value"},{"location":"the-f-library-fsharpcoredll/#184-list-and-option-types","title":"18.4 List and Option Types","text":""},{"location":"the-f-library-fsharpcoredll/#1841-the-list-type","title":"18.4.1 The List Type","text":"<p>The following shows the elements of the F# type <code>FSharp.Collections.list</code> referred to in this specification:</p> <pre><code>type 'T list =\n    | ([])\n    | (::) of 'T * 'T list\n    static member Empty : 'T list\n    member Length : int\n    member IsEmpty : bool\n    member Head : 'T\n    member Tail : 'T list\n    member Item :int -&gt; 'T with get\n    static member Cons : 'T * 'T list -&gt; 'T list\n    interface System.Collections.Generic.IEnumerable&lt;'T&gt;\n    interface System.Collections.IEnumerable\n</code></pre> <p>See also the Language Guide and the FSharp.Core documentation.</p>"},{"location":"the-f-library-fsharpcoredll/#1842-the-option-type","title":"18.4.2 The Option Type","text":"<p>The following shows the elements of the F# type <code>FSharp.Core.option</code> referred to in this specification:</p> <pre><code>[&lt;DefaultAugmentation(false)&gt;]\n[&lt;CompilationRepresentation(CompilationRepresentationFlags.UseNullAsTrueValue)&gt;]\ntype 'T option =\n    | None\n    | Some of 'T\n    static member None : 'T option\n    static member Some : 'T -&gt; 'T option\n    [&lt;CompilationRepresentation(CompilationRepresentationFlags.Instance)&gt;]\n    member Value : 'T\n    member IsSome : bool\n    member IsNone : bool\n</code></pre> <p>See also the Language Guide and the FSharp.Core documentation.</p>"},{"location":"the-f-library-fsharpcoredll/#185-choices-and-results","title":"18.5 Choices and Results","text":"<p>Check the Language Guide and the FSharp.Core documentation.</p>"},{"location":"the-f-library-fsharpcoredll/#186-lazy-computations-lazy","title":"18.6 Lazy Computations (Lazy)","text":"<p>Check the Language Guide and the FSharp.Core documentation.</p>"},{"location":"the-f-library-fsharpcoredll/#187-asynchronous-computations-async","title":"18.7 Asynchronous Computations (Async)","text":"<p>Check the Language Guide and the FSharp.Core documentation.</p>"},{"location":"the-f-library-fsharpcoredll/#188-query-expressions","title":"18.8 Query Expressions","text":"<p>Check the Language Guide and the FSharp.Core documentation.</p>"},{"location":"the-f-library-fsharpcoredll/#189-agents-mailboxprocessor","title":"18.9 Agents (MailboxProcessor)","text":"<p>Check the FSharp.Core documentation.</p>"},{"location":"the-f-library-fsharpcoredll/#1810-event-types","title":"18.10 Event Types","text":"<p>Check the Language Guide and the FSharp.Core documentation.</p>"},{"location":"the-f-library-fsharpcoredll/#1811-immutable-collection-types-map-set","title":"18.11 Immutable Collection Types (Map, Set)","text":"<p>Check the Language Guide and the FSharp.Core documentation for Map and for Set.</p>"},{"location":"the-f-library-fsharpcoredll/#1812-text-formatting-printf","title":"18.12 Text Formatting (printf)","text":"<p>Check the Language Guide and the FSharp.Core documentation</p>"},{"location":"the-f-library-fsharpcoredll/#1813-reflection","title":"18.13 Reflection","text":"<p>Check the FSharp.Core documentation.</p>"},{"location":"the-f-library-fsharpcoredll/#1814-quotations","title":"18.14 Quotations","text":"<p>Check the Language Guide and the FSharp.Core documentation.</p>"},{"location":"the-f-library-fsharpcoredll/#1815-native-pointer-operations","title":"18.15 Native Pointer Operations","text":"<p>The FSharp.Core.NativeInterop namespace contains functionality for interoperating with native code.</p> <p>Use of these functions is unsafe, and incorrect use may generate invalid IL code.</p> Operator or Function Name Description <code>NativePtr.ofNativeInt</code> Returns a typed native pointer for a machine address. <code>NativePtr.toNativeInt</code> Returns a machine address for a typed native pointer. <code>NativePtr.add</code> Computes an indexed offset from the input pointer. <code>NativePtr.read</code> Reads the memory that the input pointer references. <code>NativePtr.write</code> Writes to the memory that the input pointer references. <code>NativePtr.get</code> Reads the memory at an indexed offset from the input pointer. <code>NativePtr.set</code> Writes the memory at an indexed offset from the input pointer. <code>NativePtr.stackalloc</code> Allocates a region of memory on the stack."},{"location":"the-f-library-fsharpcoredll/#18151-stack-allocation","title":"18.15.1 Stack Allocation","text":"<p>The <code>NativePtr.stackalloc</code> function works as follows. Given</p> <pre><code>stackalloc&lt;ty&gt; n\n</code></pre> <p>the unmanaged type <code>ty</code> specifies the type of the items that will be stored in the newly allocated location, and <code>n</code> indicates the number of these items. Taken together, these establish the required allocation size.</p> <p>The <code>stackalloc</code> function allocates <code>n * sizeof&lt;ty&gt;</code> bytes from the call stack and returns a pointer of type <code>nativeptr&lt;ty&gt;</code> to the newly allocated block. The content of the newly allocated memory is undefined. If <code>n</code> is a negative value, the behavior of the function is undefined. If <code>n</code> is zero, no allocation is made, and the returned pointer is implementation-defined. If insufficient memory is available to allocate a block of the requested size, the <code>System.StackOverflowException</code> is thrown.</p> <p>Use of this function is unsafe, and incorrect use might generate invalid IL code. For example, the function should not be used in <code>with</code> or <code>finally</code> blocks in <code>try</code>/<code>with</code> or <code>try</code>/<code>finally</code> expressions. These conditions are not checked by the F# compiler, because this primitive is rarely used from F# code.</p> <p>There is no way to explicitly free memory that is allocated using stackalloc. All stack-allocated memory blocks that are created during the execution of a function or member are automatically discarded when that function or member returns. This behavior is similar to that of the <code>alloca</code> function, an extension commonly found in C and C++ implementations.</p>"},{"location":"type-definitions/","title":"8. Type Definitions","text":"<p>Type definitions define new named types. The grammar of type definitions is shown below.</p> <pre><code>type-defn :=\n    abbrev-type-defn\n    record-type-defn\n    union-type-defn\n    anon-type-defn\n    class-type-defn\n    struct-type-defn\n    interface-type-defn\n    enum-type-defn\n    delegate-type-defn\n    type-extension\n\ntype-name :=\n    attributes~opt access~opt ident typar-defns~opt\n\nabbrev-type-defn :=\n    type-name = type\n\nunion-type-defn :=\n    type-name '=' union-type-cases type-extension-elements~opt\n\nunion-type-cases :=\n    '|'~opt union-type-case '|' ... '|' union-type-case\n\nunion-type-case :=\n    attributes~opt union-type-case-data\n\nunion-type-case-data :=\n    ident -- null union case\n    ident of union-type-field * ... * union-type-field -- n-ary union case\n    ident : uncurried-sig -- n-ary union case\n\nunion-type-field :=\n    type -- unnamed union fiels\n    ident : type -- named union field\n\nrecord-type-defn :=\n    type-name = '{' record-fields '}' type-extension-elements~opt\n\nrecord-fields :=\n    record-field ; ... ; record-field ;~opt\n\nrecord-field :=\n    attributes~opt mutable~opt access~opt ident : type\n\nanon-type-defn :=\n    type-name primary-constr-args~opt object-val~opt '=' begin class-type-body end\n\nclass-type-defn :=\n    type-name primary-constr-args~opt object-val~opt '=' class class-type-body end\n\nas-defn := as ident\n\nclass-type-body :=\n    class-inherits-decl~opt class-function-or-value-defns~opt type-defn-elements~opt\n\nclass-inherits-decl := inherit type expr~opt\n\nclass-function-or-value-defn :=\n    attributes~opt static~opt let rec~opt function-or-value-defns\n    attributes~opt static~opt do expr\n\nstruct-type-defn :=\n    type-name primary-constr-args~opt as-defn~opt '=' struct struct-type-body end\n\nstruct-type-body := type-defn-elements\n\ninterface-type-defn :=\n    type-name '=' interface interface-type-body end\n\ninterface-type-body := type-defn-elements\n\nexception-defn :=\n    attributes~opt exception union-type-case-data -- exception definition\n    attributes~opt exception ident = long-ident -- exception abbreviation\n\nenum-type-defn :=\n    type-name '=' enum-type-cases\n\nenum-type-cases =\n    '|'~opt enum-type-case '|' ... '|' enum-type-case\n\nenum-type-case :=\n    ident '=' const -- enum constant definition\n\ndelegate-type-defn :=\n    type-name '=' delegate-sig\n\ndelegate-sig :=\n    delegate of uncurried-sig -- CLI delegate definition\n\ntype-extension :=\n    type-name type-extension-elements\n\ntype-extension-elements := with type-defn-elements end\n\ntype-defn-element :=\n    member-defn\n    interface-impl\n    interface-spec\n\ntype-defn-elements := type-defn-element ... type-defn-element\n\nprimary-constr-args :=\n    attributes~opt access~opt ( simple-pat, ... , simple-pat )\n\nsimple-pat :=\n    | ident\n    | simple-pat : type\n\nadditional-constr-defn :=\n    attributes~opt access~opt new pat as-defn = additional-constr-expr\n\nadditional-constr-expr :=\n    stmt ';' additional-constr-expr -- sequence construction (after)\n    additional-constr-expr then expr -- sequence construction (before)\n    if expr then additional-constr-expr else additional-constr-expr\n    let function-or-value-defn in additional-constr-expr\n    additional-constr-init-expr\n\nadditional-constr-init-expr :=\n    '{' class-inherits-decl field-initializers '}' -- explicit construction\n    new type expr -- delegated construction\n\nmember-defn :=\n    attributes~opt static~opt member access~opt method-or-prop-defn -- concrete member\n    attributes~opt abstract member~opt access~opt member-sig -- abstract member\n    attributes~opt override access~opt method-or-prop-defn -- override member\n    attributes~opt default access~opt method-or-prop-defn -- override member\n    attributes~opt static~opt val mutable~opt access~opt ident : type -- value member\n    additional-constr-defn -- additional constructor\n\nmethod-or-prop-defn :=\n    ident.~opt function-defn -- method definition\n    ident.~opt value-defn -- property definition\n    ident.~opt ident with function-or-value-defns -- property definition via get/set methods\n    member ident = exp \u2013 - auto-implemented property definition\n    member ident = exp with get \u2013 - auto-implemented property definition\n    member ident = exp with set \u2013 - auto-implemented property definition\n    member ident = exp with get,set \u2013 - auto-implemented property definition\n    member ident = exp with set,get \u2013 - auto-implemented property definition\n\nmember-sig :=\n    ident typar-defns~opt : curried-sig -- method or property signature\n    ident typar-defns~opt : curried-sig with get -- property signature\n    ident typar-defns~opt : curried-sig with set -- property signature\n    ident typar-defns~opt : curried-sig with get,set -- property signature\n    ident typar-defns~opt : curried-sig with set,get -- property signature\n\ncurried-sig :=\n    args-spec - &gt; ... - &gt; args-spec - &gt; type\n\nuncurried-sig :=\n    args-spec - &gt; type\n\nargs-spec :=\n    arg-spec * ... * arg-spec\n\narg-spec :=\n    attributes~opt arg-name-spec~opt type\n\narg-name-spec :=\n    ?~opt ident :\n\ninterface-spec :=\n    interface type\n</code></pre> <p>For example:</p> <pre><code>type int = System.Int32\ntype Color = Red | Green | Blue\ntype Map&lt;'T&gt; = { entries: 'T[] }\n</code></pre> <p>Type definitions can be declared in:</p> <ul> <li>Module definitions</li> <li>Namespace declaration groups</li> </ul> <p>F# supports the following kinds of type definitions:</p> <ul> <li>Type abbreviations (\u00a78.3)</li> <li>Record type definitions (\u00a78.4)</li> <li>Union type definitions (\u00a78.5)</li> <li>Class type definitions (\u00a78.6)</li> <li>Interface type definitions (\u00a78.7)</li> <li>Struct type definitions (\u00a78.8)</li> <li>Enum type definitions (\u00a78.9)</li> <li>Delegate type definitions (\u00a78.10)</li> <li>Exception type definitions (\u00a78.11)</li> <li>Type extension definitions (\u00a78.12)</li> <li>Measure type definitions (\u00a79.4)</li> </ul> <p>With the exception of type abbreviations and type extension definitions, type definitions define fresh, named types that are distinct from other types.</p> <p>A type definition group defines several type definitions or extensions simultaneously:</p> <pre><code>type ... and ...\n</code></pre> <p>For example:</p> <pre><code>type RowVector(entries: seq&lt;int&gt;) =\n    let entries = Seq.toArray entries\n    member x.Length = entries.Length\n    member x.Permute = ColumnVector(entries)\nand ColumnVector(entries: seq&lt;int&gt;) =\n    let entries = Seq.toArray entries\n    member x.Length = entries.Length\n    member x.Permute = RowVector(entries)\n</code></pre> <p>A type definition group can include any type definitions except for exception type definitions and module definitions.</p> <p>Most forms of type definitions may contain both static elements and instance elements. Static elements are accessed by using the type definition. Within a <code>static</code> definition, only the <code>static</code> elements are in scope. Most forms of type definitions may contain members (\u00a78.13).</p> <p>Custom attributes may be placed immediately before a type definition group, in which case they apply to the first type definition, or immediately before the name of the type definition:</p> <pre><code>[&lt;Obsolete&gt;] type X1() = class end\n\ntype [&lt;Obsolete&gt;] X2() = class end\nand [&lt;Obsolete&gt;] Y2() = class end\n</code></pre>"},{"location":"type-definitions/#81-type-definition-group-checking-and-elaboration","title":"8.1 Type Definition Group Checking and Elaboration","text":"<p>F# checks type definition groups by determining the basic shape of the definitions and then filling in the details. In overview, a type definition group is checked as follows:</p> <ol> <li>For each type definition:<ul> <li>Determine the generic arguments, accessibility and kind of the type definition</li> <li>Determine whether the type definition supports equality and/or comparison</li> <li>Elaborate the explicit constraints for the generic parameters.</li> </ul> </li> <li>For each type definition:<ul> <li>Establish type abbreviations</li> <li>Determine the base types and implemented interfaces of each new type definition</li> <li>Detect any cyclic abbreviations</li> <li>Verify the consistency of types in fields, union cases, and base types.</li> </ul> </li> <li>For each type definition:<ul> <li>Determine the union cases, fields, and abstract members (\u00a78.14) of each new type definition.</li> <li>Check the union cases, fields, and abstract members themselves, as described in the corresponding sections of this chapter.</li> </ul> </li> <li>For each member, add items that represent the members to the environment as a recursive group.</li> <li>Check the members, function, and value definitions in order and apply incremental generalization.</li> </ol> <p>In the context in which type definitions are checked, the type definition itself is in scope, as are all members and other accessible functionality of the type. This context enables recursive references to the accessible static content of a type. It also enables recursive references to the accessible properties of any object that has the same type as the type definition or a related type.</p> <p>In more detail, given an initial environment <code>env</code>, a type definition group is checked as described in the following paragraphs.</p> <p>First, check the individual type definitions. For each type definition:</p> <ol> <li>Determine the number, names, and sorts of generic arguments of the type definition.<ul> <li>For each generic argument, if a <code>Measure</code> attribute is present, mark the generic argument as a    measure parameter. The generic arguments are initially inference parameters, and    additional constraints may be inferred for these parameters.</li> <li>For each type definition <code>T</code> , the subsequent steps use an environment <code>envT</code> that is produced    by adding the type definitions themselves and the generic arguments for <code>T</code> to <code>env</code>.</li> </ul> </li> <li>Determine the accessibility of the type definition.</li> <li>Determine and check the basic kind of the type definition, using Type Kind Inference if necessary     (\u00a78.2).</li> <li> <p>Mark the type definition as a measure type definition if a <code>Measure</code> attribute is present.</p> </li> <li> <p>If the type definition is generic, infer whether the type definition supports equality and/or comparison.</p> </li> <li> <p>Elaborate and add the explicit constraints for the generic parameters of the type definition, and     then generalize the generic parameters. Inference of additional constraints is not permitted.</p> </li> <li>If the type definition is a type abbreviation, elaborate and establish the type being abbreviated.</li> <li>Check and elaborate any base types and implemented interfaces.</li> <li>If the type definition is a type abbreviation, check that the type abbreviation is not cyclic.</li> <li>Check whether the type definition has a single, zero-argument constructor, and hence forms a     type that satisfies the default constructor constraint.</li> <li>Recheck the following to ensure that constraints are consist:<ul> <li>The type being abbreviated, if any.</li> <li>The explicit constraints for any generic parameters, if any.</li> <li>The types and constraints occurring in the base types and implemented interfaces, if any.</li> </ul> </li> <li>Determine the union cases, fields, and abstract members, if any, of the type definition. Check     and elaborate the types that the union cases, fields, and abstract members include.</li> <li>Make additional checks as defined elsewhere in this chapter. For example, check that the     <code>AbstractClass</code> attribute does not appear on a union type.</li> <li> <p>For each type definition that is a struct, class, or interface, check that the inheritance graph and     the struct-inclusion graph are not cyclic. This check ensures that a struct does not contain itself     and that a class or interface does not inherit from itself. This check includes the following steps:</p> <p>a) Create a graph with one node for each type definition.</p> <p>b) Close the graph under edges.</p> <ul> <li>(T, base-type-definition)</li> <li>(T, interface-type-definition)</li> <li>(T 1 , T 2 ) where T 1 is a struct and T 2 is a type that would store a value of type T 1 &lt;...&gt; for     some instantiation. Here \u201cX storing Y\u201d means that X is Y or is a struct type with an     instance field that stores Y.</li> </ul> <p>c) Check for cycles.</p> <p>The special case of a struct <code>S&lt;typars&gt;</code> storing a static field of type <code>S&lt;typars&gt;</code> is allowed. 15. Collectively add the elaborated member items that represent the members for all new type definitions to the environment as a recursive group (\u00a78.13), excluding interface implementation members.</p> </li> <li> <p>If the type definition has a primary constructor, create a member item to represent the primary     constructor.</p> </li> </ol> <p>After these steps are complete for each type definition, check the members. For each member:</p> <ol> <li>If the member is in a generic type, create a copy of the type parameters for the generic type and     add the copy to the environment for that member.</li> <li>If the member has explicit type parameters, elaborate these type parameters and any explicit     constraints.</li> <li>If the member is an override, default, or interface implementation member, apply dispatch-slot     inference.</li> <li>If the member has syntactic parameters, assign an initial type to the elaborated member item     based on the patterns that specify arguments for the members.</li> <li>If the member is an instance member, assign a type to the instance variable.</li> </ol> <p>Finally, check the function, value, and member definitions of each new type definition in order as a recursive group.</p>"},{"location":"type-definitions/#82-type-kind-inference","title":"8.2 Type Kind Inference","text":"<p>A type that is specified in one of the following ways has an anonymous type kind:</p> <ul> <li>By using <code>begin</code> and <code>end</code> on the right-hand side of the = token.</li> <li>In lightweight syntax, with an implicit <code>begin</code>/<code>end</code>.</li> </ul> <p>F# infers the kind of an anonymous type by applying the following rules, in order:</p> <ol> <li>If the type has a <code>Class</code> attribute, <code>Interface</code> attribute, or <code>Struct</code> attribute, this attribute identifies     the kind of the type.</li> <li>If the type has any concrete elements, the type is a class. Concrete elements are primary     constructors, additional object constructors, function definitions, value definitions, non-abstract     members, and any <code>inherit</code> declarations that have arguments.</li> <li>Otherwise, the type is an interface type.</li> </ol> <p>For example:</p> <pre><code>// This is implicitly an interface\ntype IName =\n    abstract Name : string\n\n// This is implicitly a class, because it has a constructor\ntype ConstantName(n:string) =\n    member x.Name = n\n\n// This is implicitly a class, because it has a constructor\ntype AbstractName(n:string) =\n    abstract Name : string\n    default x.Name = \"&lt;no-name&gt;\"\n</code></pre> <p>If a type is not an anonymous type, any use of the <code>Class</code> attribute, <code>Interface</code> attribute, or <code>Struct</code> attribute must match the <code>class</code>/<code>end</code>, <code>interface</code>/<code>end</code>, and <code>struct</code>/<code>end</code> tokens, if such tokens are present. These attributes cannot be used with other kinds of type definitions such as type abbreviations, record, union, or enum types.</p>"},{"location":"type-definitions/#83-type-abbreviations","title":"8.3 Type Abbreviations","text":"<p>Type abbreviations define new names for other types. For example:</p> <pre><code>type PairOfInt = int * int\n</code></pre> <p>Type abbreviations are expanded and erased during compilation and do not appear in the elaborated form of F# declarations, nor can they be referred to or accessed at runtime.</p> <p>The process of repeatedly eliminating type abbreviations in favor of their equivalent types must not result in an infinite type derivation. For example, the following are not valid type definitions:</p> <pre><code>type X = option&lt;X&gt;\n\ntype Identity&lt;'T&gt; = 'T\nand Y = Identity&lt;Y&gt;\n</code></pre> <p>The constraints on a type abbreviation must satisfy any constraints that the abbreviated type requires.</p> <p>For example, assuming the following declarations:</p> <pre><code>type IA =\n    abstract AbstractMember : int -&gt; int\n\ntype IB =\n    abstract AbstractMember : int -&gt; int\n\ntype C&lt;'T when 'T :&gt; IB&gt;() =\n    static member StaticMember(x : 'a) = x.AbstractMember(1)\n</code></pre> <p>the following is permitted:</p> <pre><code>type D&lt;'T when 'T :&gt; IB&gt; = C&lt;'T&gt;\n</code></pre> <p>whereas the following is not permitted:</p> <pre><code>type E&lt;'T&gt; = C&lt;'T&gt; // invalid: missing constraint\n</code></pre> <p>Type abbreviations can define additional constraints, so the following is permitted:</p> <pre><code>type F&lt;'T when 'T :&gt; IA and 'T :&gt; IB&gt; = C&lt;'T&gt;\n</code></pre> <p>The right side of a type abbreviation must use all the declared type variables that appear on the left side. For this purpose, the order of type variables that are used on the right-hand side of a type definition is determined by their left-to-right occurrence in the type.</p> <p>For example, the following is not a valid type abbreviation.</p> <pre><code>type Drop&lt;'T,'U&gt; = 'T * 'T // invalid: dropped type variable\n</code></pre> <p>Note : This restriction simplifies the process of guaranteeing a stable and consistent compilation to generic CLI code.</p> <p>Flexible type constraints # type may not be used on the right side of a type abbreviation, because they expand to a type variable that has not been named in the type arguments of the type abbreviation. For example, the following type is disallowed:</p> <pre><code>type BadType = #Exception -&gt; int // disallowed\n</code></pre> <p>Type abbreviations may be declared <code>internal</code> or <code>private</code>.</p> <p>Note: Private type abbreviations are still, for all purposes, considered equivalent to the abbreviated types.</p>"},{"location":"type-definitions/#84-record-type-definitions","title":"8.4 Record Type Definitions","text":"<p>A record type definition introduces a type in which all the inputs that are used to construct a value are accessible as properties on values of the type. For example:</p> <pre><code>type R1 =\n    { x : int;\n    y : int }\n    member this.Sum = this.x + this.y\n</code></pre> <p>In this example, the integers x and y can be accessed as properties on values of type R1.</p> <p>Record fields may be marked mutable. For example:</p> <pre><code>type R2 =\n    { mutable x : int;\n      mutable y : int }\n    member this.Move(dx,dy) =\n        this.x &lt;- this.x + dx\n        this.y &lt;- this.y + dy\n</code></pre> <p>The <code>mutable</code> attribute on <code>x</code> and <code>y</code> makes the assignments valid.</p> <p>Record types are implicitly sealed and may not be given the <code>Sealed</code> attribute. Record types may not be given the <code>AbstractClass</code> attribute.</p> <p>Record types are implicitly marked serializable unless the <code>AutoSerializable(false)</code> attribute is used.</p> <p>Record types are reference types unless the <code>Struct</code> attribute is used (see \u00a78.8).</p>"},{"location":"type-definitions/#841-members-in-record-types","title":"8.4.1 Members in Record Types","text":"<p>Record types may declare members (\u00a78.13), overrides, and interface implementations. Like all types with overrides and interface implementations, they are subject to Dispatch Slot Checking (\u00a714.8).</p>"},{"location":"type-definitions/#842-name-resolution-and-record-field-labels","title":"8.4.2 Name Resolution and Record Field Labels","text":"<p>For a record type, the record field labels <code>field1</code> ... <code>field</code> are added to the _FieldLabels table of the current name resolution environment unless the record type has the <code>RequireQualifiedAccess</code> attribute.</p> <p>Record field labels in the FieldLabels table play a special role in Name Resolution for Members (\u00a714.1): an expression\u2019s type may be inferred from a record label. For example:</p> <pre><code>type R = { dx : int; dy: int }\nlet f x = x.dx // x is inferred to have type R\n</code></pre> <p>In this example, the lookup <code>.dx</code> is resolved to be a field lookup.</p>"},{"location":"type-definitions/#843-structural-hashing-equality-and-comparison-for-record-types","title":"8.4.3 Structural Hashing, Equality, and Comparison for Record Types","text":"<p>Record types implicitly implement the following interfaces and dispatch slots unless they are explicitly implemented as part of the definition of the record type:</p> <pre><code>interface System.Collections.IStructuralEquatable\ninterface System.Collections.IStructuralComparable\ninterface System.IComparable\noverride GetHashCode : unit -&gt; int\noverride Equals : obj -&gt; bool\n</code></pre> <p>The implicit implementations of these interfaces and overrides are described in \u00a78.15.</p>"},{"location":"type-definitions/#844-withend-in-record-type-definitions","title":"8.4.4 With/End in Record Type Definitions","text":"<p>Record type definitions can include <code>with</code>/<code>end</code> tokens, as the following shows:</p> <pre><code>type R1 =\n    { x : int;\n      y : int }\n    with\n        member this.Sum = this.x + this.y\n    end\n</code></pre> <p>The <code>with</code>/<code>end</code> tokens can be omitted if the type-defn-elements vertically align with the <code>{</code> in the <code>record-fields</code>. The semicolon (<code>;</code>) tokens can be omitted if the next <code>record-field</code> vertically aligns with the previous <code>record-field</code>.</p>"},{"location":"type-definitions/#845-climutable-attributes","title":"8.4.5 CLIMutable Attributes","text":"<p>Adding the <code>CLIMutable</code> attribute to a record type causes it to be compiled to a CLI representation as a plain-old CLR object (POCO) with a default constructor along with property getters and setters. Adding the default constructor and mutable properties makes objects of the record type usable with .NET tools and frameworks such as database queries, serialization frameworks, and data models in XAML programming.</p> <p>For example, an F# immutable record cannot be serialized because it does not have a constructor. However, if you attach the CLIMutable attribute as in the following example, the XmlSerializer is enable to serialize or deserialize this record type:</p> <pre><code>[&lt;CLIMutable&gt;]\ntype R1 = { x : string; y : int }\n</code></pre>"},{"location":"type-definitions/#85-union-type-definitions","title":"8.5 Union Type Definitions","text":"<p>A union type definition is a type definition that includes one or more union cases. For example:</p> <pre><code>type Message =\n    | Result of string\n    | Request of int * string\n    member x.Name = match x with Result(nm) -&gt; nm | Request(_,nm) -&gt; nm\n</code></pre> <p>Union case names must begin with an uppercase letter, which is defined to mean any character for which the CLI library function <code>System.Char.IsUpper</code> returns <code>true</code> and <code>System.Char.IsLower</code> returns <code>false</code>.</p> <p>The union cases <code>Case1</code> ... <code>CaseN</code> have module scope and are added to the ExprItems and PatItems tables in the name resolution environment. This means that their unqualified names can be used to form both expressions and patterns, unless the record type has the <code>RequireQualifiedAccess</code> attribute.</p> <p>Parentheses are significant in union definitions. Thus, the following two definitions differ:</p> <pre><code>type CType = C of int * int\ntype CType = C of (int * int)\n</code></pre> <p>The lack of parentheses in the first example indicates that the union case takes two arguments. The parentheses in the second example indicate that the union case takes one argument that is a first- class tuple value.</p> <p>Union fields may optionally be named within each case of a union type. For example:</p> <pre><code>type Shape =\n    | Rectangle of width: float * length: float\n    | Circle of radius: float\n    | Prism of width: float * float * height: float\n</code></pre> <p>The names are referenced when pattern matching on union values of this type. When using pattern matching with multiple fields, semicolons are used to delimit the named fields, e.g. <code>Prism(width=w; height=h).</code></p> <p>The following declaration defines a type abbreviation if the named type <code>A</code> exists in the name resolution environment. Otherwise it defines a union type.</p> <pre><code>type OneChoice = A\n</code></pre> <p>To disambiguate this case and declare an explicit union type, use the following:</p> <pre><code>type OneChoice =\n    | A\n</code></pre> <p>Union types are implicitly marked serializable unless the <code>AutoSerializable(false)</code> attribute is used.</p>"},{"location":"type-definitions/#851-members-in-union-types","title":"8.5.1 Members in Union Types","text":"<p>Union types may declare members (\u00a78.13), overrides, and interface implementations. As with all types that declare overrides and interface implementations, they are subject to Dispatch Slot Checking (\u00a714.8).</p>"},{"location":"type-definitions/#852-structural-hashing-equality-and-comparison-for-union-types","title":"8.5.2 Structural Hashing, Equality, and Comparison for Union Types","text":"<p>Union types implicitly implement the following interfaces and dispatch slots unless they are explicitly implemented as part of the definition of the union type:</p> <pre><code>interface System.Collections.IStructuralEquatable\ninterface System.Collections.IStructuralComparable\ninterface System.IComparable\noverride GetHashCode : unit -&gt; int\noverride Equals : obj -&gt; bool\n</code></pre> <p>The implicit implementations of these interfaces and overrides are described in \u00a78.15.</p>"},{"location":"type-definitions/#853-withend-in-union-type-definitions","title":"8.5.3 With/End in Union Type Definitions","text":"<p>Union type definitions can include <code>with</code>/<code>end</code> tokens, as the following shows:</p> <pre><code>type R1 =\n    { x : int;\n      y : int }\n    with\n        member this.Sum = this.x + this.y\n    end\n</code></pre> <p>The <code>with</code>/<code>end</code> tokens can be omitted if the type-defn-elements vertically align with the <code>{</code> in the record-fields. The semicolon (<code>;</code>) tokens can be omitted if the next record-field vertically aligns with the previous record-field.</p> <p>For union types, the <code>with</code>/<code>end</code> tokens can be omitted if the type-defn-elements vertically alignwith the first <code>|</code> in the union-type-cases. However, <code>with</code>/<code>end</code> must be present if the <code>|</code> tokens align with the <code>type</code> token. For example:</p> <pre><code>/// Note: this layout is permitted\ntype Message =\n    | Result of string\n    | Request of int * string\n    member x.Name = match x with Result(nm) -&gt; nm | Request(_,nm) -&gt; nm\n\n/// Note: this layout is not permitted\ntype Message =\n| Result of string\n| Request of int * string\nmember x.Name = match x with Result(nm) -&gt; nm | Request(_,nm) -&gt; nm\n</code></pre>"},{"location":"type-definitions/#854-compiled-form-of-union-types-for-use-from-other-cli-languages","title":"8.5.4 Compiled Form of Union Types for Use from Other CLI Languages","text":"<p>A compiled union type <code>U</code> has:</p> <ul> <li>One CLI static getter property <code>U.C</code> for each null union case <code>C</code>. This property gets a singleton     object that represents each such case.</li> <li>One CLI nested type <code>U.C</code> for each non-null union case <code>C</code>. This type has instance properties <code>Item1</code>,     <code>Item2</code> ... for each field of the union case, or a single instance property <code>Item</code> if there is only one     field. However, a compiled union type that has only one case does not have a nested type.     Instead, the union type itself plays the role of the case type.</li> <li>One CLI static method <code>U.NewC</code> for each non-null union case <code>C</code>. This method constructs an object     for that case.</li> <li>One CLI instance property <code>U.IsC</code> for each case <code>C</code>. This property returns <code>true</code> or <code>false</code> for the case.</li> <li>One CLI instance property <code>U.Tag</code> for each case <code>C</code>. This property fetches or computes an integer     tag corresponding to the case.</li> <li>If <code>U</code> has more than one case, it has one CLI nested type <code>U.Tags</code>. The <code>U.Tags</code> type contains one     integer literal for each case, in increasing order starting from zero.</li> <li>A compiled union type has the methods that are required to implement its auto-generated     interfaces, in addition to any user-defined properties or methods.</li> </ul> <p>These methods and properties may not be used directly from F#. However, these types have user- facing <code>List.Empty</code>, <code>List.Cons</code>, <code>Option.None</code>, and <code>Option.Some</code> properties and/or methods.</p> <p>A compiled union type may not be used as a base type in another CLI language, because it has at least one assembly-private constructor and no public constructors.</p>"},{"location":"type-definitions/#86-class-type-definitions","title":"8.6 Class Type Definitions","text":"<p>A class type definition encapsulates values that are constructed by using one or more object constructors. Class types have the form:</p> <pre><code>type type-name pat~opt as-defn~opt =\n    class\n        class-inherits-decl~opt\n        class-function-or-value-defns~opt\n        type-defn-elements\n    end\n</code></pre> <p>The <code>class</code>/<code>end</code> tokens can be omitted, in which case Type Kind Inference (\u00a78.2) is used to determine the kind of the type.</p> <p>In F#, class types are implicitly marked serializable unless the <code>AutoSerializable(false)</code> attribute is present.</p>"},{"location":"type-definitions/#861-primary-constructors-in-classes","title":"8.6.1 Primary Constructors in Classes","text":"<p>An object constructor represents a way of initializing an object. Object constructors can create values of the type and can partially initialize an object from a subclass. A class can have an optional primary constructor and zero or more additional object constructors.</p> <p>If a type definition has a pattern immediately after the <code>type-name</code> and any accessibility annotation, then it has a primary constructor. For example, the following type has a primary constructor:</p> <pre><code>type Vector2D(dx : float, dy : float) =\n    let length = sqrt(dx*x + dy*dy)\n    member v.Length = length\n    member v.DX = dx\n    member v.DY = dy\n</code></pre> <p>Class definitions that have a primary constructor may contain function and value definitions, including those that use <code>let rec</code>.</p> <p>The pattern for a primary constructor must have zero or more patterns of the following form:</p> <pre><code>( simple-pat , ..., simple-pat )\n</code></pre> <p>Each <code>simple-pat</code> has this form:</p> <pre><code>simple-pat :=\n    | ident\n    | simple-pat : type\n</code></pre> <p>Specifically, nested patterns may not be used in the primary constructor arguments. For example, the following is not permitted because the primary constructor arguments contain a nested tuple pattern:</p> <pre><code>type TwoVectors((px, py), (qx, qy)) =\n    member v.Length = sqrt((qx-px)*(qx-px) + (qy-py)*(qy-py))\n</code></pre> <p>Instead, one or more value definitions should be used to accomplish the same effect:</p> <pre><code>type TwoVectors(pv, qv) =\n    let (px, py) = pv\n    let (qx, qy) = qv\n    member v.Length = sqrt((qx-px)*(qx-px) + (qy-py)*(qy-py))\n</code></pre> <p>When a primary constructor is evaluated, the inheritance and function and value definitions are evaluated in order.</p>"},{"location":"type-definitions/#8611-object-references-in-primary-constructors","title":"8.6.1.1 Object References in Primary Constructors","text":"<p>For types that have a primary constructor, the name of the object parameter can be bound and used in the non-static function, value, and member definitions of the type definition as follows:</p> <pre><code>type X(a:int) as x =\n    let mutable currentA = a\n    let mutable currentB = 0\n    do x.B &lt;- x.A + 3\n    member self.GetResult()= currentA + currentB\n    member self.A with get() = currentA and set v = currentA &lt;- v\n    member self.B with get() = currentB and set v = currentB &lt;- v\n</code></pre> <p>During construction, no member on the type may be called before the last value or function definition in the type has completed; such a call results in an <code>InvalidOperationException</code>. For example, the following code raises this exception:</p> <pre><code>type C() as self =\n    let f = (fun (x:C) -&gt; x.F())\n    let y = f self\n    do printfn \"construct\"\n    member this.F() = printfn \"hi, y = %A\" y\n\nlet r = new C() // raises InvalidOperationException\n</code></pre> <p>The exception is raised because an attempt may be made to access the value of the field <code>y</code> before initialization is complete.</p>"},{"location":"type-definitions/#8612-inheritance-declarations-in-primary-constructors","title":"8.6.1.2 Inheritance Declarations in Primary Constructors","text":"<p>An <code>inherit</code> declaration specifies that the type being defined is an extension of an existing type. Such declarations have the following form:</p> <pre><code>class-inherits-decl := inherit type expr~opt\n</code></pre> <p>For example:</p> <pre><code>type MyDerived(...) =\n    inherit MyBase(...)\n</code></pre> <p>If a class definition does not contain an <code>inherit</code> declaration, the class inherits <code>fromSystem.Object</code> by default.</p> <p>The <code>inherit</code> declaration for a type must have arguments if and only if the type has a primary constructor.</p> <p>Unlike \u00a78.6.1.1, members of a base type can be accessed during construction of the derived class. For example, the following code does not raise an exception:</p> <pre><code>type B() =\n    member this.G() = printfn \"hello \"\n\ntype C() as self =\n    inherit B()\n    let f = (fun (x:C) -&gt; x.G())\n    let y = f self\n    do printfn \"construct\"\n    member this.F() = printfn \"hi, y = %A\" y\n\nlet r = new C() // does not raise InvalidOperationException\n</code></pre>"},{"location":"type-definitions/#8613-instance-function-and-value-definitions-in-primary-constructors","title":"8.6.1.3 Instance Function and Value Definitions in Primary Constructors","text":"<p>Classes that have primary constructors may include function definitions, value definitions, and \u201cdo\u201d statements. The following rules apply to these definitions:</p> <ul> <li> <p>Each definition may be marked <code>static</code> (see \u00a78.6.1.4). If the definition is not marked <code>static</code>, it is     called an instance definition.</p> </li> <li> <p>The functions and values defined by instance definitions are lexically scoped (and thus implicitly     private) to the object being defined.</p> </li> <li>Each value definition may optionally be marked <code>mutable</code>.</li> <li>A group of function and value definitions may optionally be marked <code>rec</code>.</li> <li>Function and value definitions are generalized.</li> <li>Value definitions that declared in classes are represented in compiled code as follows:</li> <li>If a value definition is not mutable, and is not used in any function or member, then the        value is represented as a local value in the object constructor.</li> <li>If a value definition is mutable, or used in any function or member, then the value is        represented as an instance field in the corresponding CLI type.</li> <li> <p>Function definitions are represented in compiled code as private members of the corresponding     CLI type.     For example, consider this type:</p> <pre><code>   type C(x:int,y:int) =\n       let z = x + y\n       let f w = x + w\n       member this.Z = z\n       member this.Add(w) = f w\n</code></pre> </li> </ul> <p>The input <code>y</code> is used only during construction, and no field is stored for it. Likewise the function <code>f</code> is represented as a member rather than a field that is a function value.</p> <p>A value definition is considered a function definition if its immediate right-hand-side is an anonymous function, as in this example:</p> <pre><code>let f = (fun w -&gt; x + w)\n</code></pre> <p>Function and value definitions may have attributes as follows:</p> <ul> <li>Value definitions represented as fields may have attributes that target fields.</li> <li>Value definitions represented as locals may have attributes that target fields, but these     attributes will not be attached to any construct in the resulting CLI assembly.</li> <li>Function definitions represented as methods may have attributes that target methods.</li> </ul> <p>For example:</p> <pre><code>type C(x:int) =\n    [&lt;System.Obsolete&gt;]\n    let unused = x\n    member __.P = 1\n</code></pre> <p>In this example, no field is generated for <code>unused</code>, and no corresponding compiled CLI attribute is generated.</p>"},{"location":"type-definitions/#8614-static-function-and-value-definitions-in-primary-constructors","title":"8.6.1.4 Static Function and Value Definitions in Primary Constructors","text":"<p>Classes that have primary constructors may have function definitions, value definitions, and \u201cdo\u201d statements that are marked as static:</p> <ul> <li>The values that are defined by static function and value definitions are lexically scoped (and thus     implicitly private) to the type being defined.</li> <li>Each value definition may optionally be marked <code>mutable</code>.</li> <li>A group of function and value definitions may optionally be marked <code>rec</code>.</li> <li>Static function and value definitions are generalized.</li> <li>Static function and value definitions are computed once per generic instantiation.</li> <li>Static function and value definitions are elaborated to a static initializer associated with each     generic instantiation of the generated class. Static initializers are executed on demand in the     same way as static initializers for implementation files \u00a712.5.</li> <li>The compiled representation for static value definitions is as follows:</li> <li>If the value is not used in any function or member then the value is represented as a local        value in the CLI class initializer of the type.</li> <li>If the value is used in any function or member, then the value is represented as a static field        of the CLI class for the type.</li> <li>The compiled representation for a static function definition is a private static member of the     corresponding CLI type.</li> </ul> <p>Static function and value definitions may have attributes as follows:</p> <ul> <li>Static function and value definitions represented as fields may have attributes that target fields.</li> <li>Static function and value definitions represented as methods may have attributes that target     methods.</li> </ul> <p>For example:</p> <pre><code>type C&lt;'T&gt;() =\n    static let mutable v = 2 + 2\n    static do v &lt;- 3\n\n    member x.P = v\n    static member P2 = v+v\n\nprintfn \"check: %d = 3\" (new C&lt;int&gt;()).P\nprintfn \"check: %d = 3\" (new C&lt;int&gt;()).P\nprintfn \"check: %d = 3\" (new C&lt;string&gt;()).P\nprintfn \"check: %d = 6\" (C&lt;int&gt;.P2)\nprintfn \"check: %d = 6\" (C&lt;string&gt;.P2)\n</code></pre> <p>In this example, the value <code>v</code> is represented as a static field in the CLI type for <code>C</code>. One instance of this field exists for each generic instantiation of <code>C</code>. The output of the program is</p> <pre><code>check: 3 = 3\ncheck: 3 = 3\ncheck: 3 = 3\ncheck: 6 = 6\ncheck: 6 = 6\n</code></pre>"},{"location":"type-definitions/#862-members-in-classes","title":"8.6.2 Members in Classes","text":"<p>Class types may declare members (\u00a78.13), overrides, and interface implementations. As with all types that have overrides and interface implementations, such class types are subject to Dispatch Slot Checking (\u00a714.8).</p>"},{"location":"type-definitions/#863-additional-object-constructors-in-classes","title":"8.6.3 Additional Object Constructors in Classes","text":"<p>Although the use of primary object constructors is generally preferable, additional object constructors may also be specified. Additional object constructors are required in two situations:</p> <ul> <li>To define classes that have more than one constructor.</li> <li>To specify explicit <code>val</code> fields without the <code>DefaultValue</code> attribute.</li> </ul> <p>For example, the following statement adds a second constructor to a class that has a primary constructor:</p> <pre><code>type PairOfIntegers(x:int,y:int) =\n    new (x) = PairOfIntegers(x,x)\n</code></pre> <p>The next example declares a class without a primary constructor:</p> <pre><code>type PairOfStrings =\n    val s1 : string\n    val s2 : string\n    new (s) = { s1 = s; s2 = s }\n    new (s1,s2) = { s1 = s1; s2 = s2 }\n</code></pre> <p>If a primary constructor is present, additional object constructors must call another object constructor in the same type, which may be another additional constructor or the primary constructor.</p> <p>If no primary constructor is present, additional constructors must initialize any <code>val</code> fields of the object that do not have the <code>DefaultValue</code> attribute. They must also specify a call to a base class constructor for any inherited class type. A call to a base class constructor is not required if the base class is <code>System.Object</code>.</p> <p>The use of additional object constructors and <code>val</code> fields is required if a class has multiple object constructors that must each call different base class constructors. For example:</p> <pre><code>type BaseClass =\n    val s1 : string\n    new (s) = { s1 = s }\n    new () = { s 1 = \"default\" }\n\ntype SubClass =\n    inherit BaseClass\n    val s2 : string\n    new (s1,s2) = { inherit BaseClass(s1); s2 = s2 }\n    new (s2) = { inherit BaseClass(); s2 = s2 }\n</code></pre> <p>To implement additional object constructors, F# uses a restricted subset of expressions that ensure that the code generated for the constructor is valid according to the rules of object construction for CLI objects. Note that precisely one <code>additional-constr-init-expr</code> occurs for each branch of a construction expression.</p> <p>For classes without a primary constructor, side effects can be performed after the initialization of the fields of the object by using the <code>additional-constr-expr then stmt</code> form. For example:</p> <pre><code>type PairOfIntegers(x:int,y:int) =\n    // This additional constructor has a side effect after initialization.\n    new(x) =\n        PairOfIntegers(x, x)\n        then\n            printfn \"Initialized with only one integer\"\n</code></pre> <p>The name of the object parameter can be bound within additional constructors. For example:</p> <pre><code>type X =\n    val a : (unit -&gt; string)\n    val mutable b : string\n    new() as x = { a = (fun () -&gt; x.b); b = \"b\" }\n</code></pre> <p>A warning is given if x occurs syntactically in or before the <code>additional-constr-init-expr</code> of the construction expression. If any member is called before the completion of execution of the <code>additional-constr-init-expr</code> within the <code>additional-constr-expr</code> then an <code>InvalidOperationException</code> is thrown.</p>"},{"location":"type-definitions/#864-additional-fields-in-classes","title":"8.6.4 Additional Fields in Classes","text":"<p>Additional field declarations indicate that a value is stored in an object. They are generally used only for classes without a primary constructor, or for mutable fields that use default initialization, and typically occur only in generated code. For example:</p> <pre><code>type PairOfIntegers =\n    val x : int\n    val y : int\n    new(x, y) = {x = x; y = y}\n</code></pre> <p>The following shows an additional field declaration as a static field in an explicit class type:</p> <pre><code>type TypeWithADefaultMutableBooleanField =\n    [&lt;DefaultValue&gt;]\n    static val mutable ready : bool\n</code></pre> <p>At runtime, such a field is initially assigned the zero value for its type (\u00a76.9.3). For example:</p> <pre><code>type MyClass(name:string) =\n    // Keep a global count. It is initially zero.\n    [&lt;DefaultValue&gt;]\n    static val mutable count : int\n\n    // Increment the count each time an object is created\n    do MyClass.count &lt;- MyClass.count + 1\n\n    static member NumCreatedObjects = MyClass.count\n\n    member x.Name = name\n</code></pre> <p>A <code>val</code> specification in a type that has a primary constructor must be marked mutable and must have the <code>DefaultValue</code> attribute. For example:</p> <pre><code>type X() =\n    [&lt;DefaultValue&gt;]\n    val mutable x : int\n</code></pre> <p>The <code>DefaultValue</code> attribute takes a check parameter, which indicates whether to ensure that the <code>val</code> specification does not create unexpected <code>null</code> values. The default value for <code>check</code> is <code>true</code>. If this parameter is <code>true</code>, the type of the field must permit default initialization (\u00a75.4.8). For example, the following type is rejected:</p> <pre><code>type MyClass&lt;'T&gt;() =\n    [&lt;DefaultValue&gt;]\n    static val mutable uninitialized : 'T\n</code></pre> <p>The reason is that the type <code>'T</code> does not admit default initialization. However, in compiler-generated and hand-optimized code it is sometimes essential to be able to emit fields that are completely uninitialized. In this case, <code>DefaultValue(false)</code> can be used. For example:</p> <pre><code>type MyNullable&lt;'T&gt;() =\n    [&lt;DefaultValue&gt;]\n    static val mutable ready : bool\n\n    [&lt;DefaultValue(false)&gt;]\n    static val mutable uninitialized : 'T\n</code></pre>"},{"location":"type-definitions/#87-interface-type-definitions","title":"8.7 Interface Type Definitions","text":"<p>An interface type definition represents a contract that an object may implement. Such a type definition containsonly abstract members. For example:</p> <pre><code>type IPair&lt;'T,'U&gt; =\n    interface\n        abstract First: 'T\n        abstract Second: 'U\n    end\n\ntype IThinker&lt;'Thought&gt; =\n    abstract Think: ('Thought -&gt; unit) -&gt; unit\n    abstract StopThinking: (unit -&gt; unit)\n</code></pre> <p>Note: The <code>interface</code>/<code>end</code> tokens can be omitted when lightweight syntax is used, in which case Type Kind Inference (\u00a78.2) is used to determine the kind of the type. The presence of any non-abstract members or constructors means a type is not an interface type.  By convention, interface type names start with <code>I</code>, as in <code>IEvent</code>. However, this convention is not followed as strictly in F# as in other CLI languages.</p> <p>Interface types may be arranged hierarchically by specifying inherit declarations. For example:</p> <pre><code>type IA =\n    abstract One: int -&gt; int\n\ntype IB =\n    abstract Two: int -&gt; int\ntype IC =\n    inherit IA\n    inherit IB\n    abstract Three: int -&gt; int\n</code></pre> <p>Each <code>inherit</code> declaration must itself be an interface type. Circular references are not allowed among <code>inherit</code> declarations. F# uses the named types of the inherited interface types to determine whether references are circular.</p>"},{"location":"type-definitions/#88-struct-type-definitions","title":"8.8 Struct Type Definitions","text":"<p>A struct type definition is a type definition whose instances are stored inline inside the stack frame or object of which they are a part. The type is represented as a CLI struct type, also called a value type. For example:</p> <pre><code>type Complex =\n    struct\n        val real: float;\n        val imaginary: float\n        member x.R = x.real\n        member x.I = x.imaginary\n    end\n</code></pre> <p>Note: The <code>struct</code>/<code>end</code> tokens can be omitted when lightweight syntax is used, in which case Type Kind Inference (\u00a78.2) is used to determine the kind of the type.</p> <p>Because structs undergo type kind inference (\u00a78.2), the following is valid:</p> <pre><code>[&lt;Struct&gt;]\ntype Complex(r:float, i:float) =\n    member x.R = r\n    member x.I = i\n</code></pre> <p>Structs may have primary constructors:</p> <pre><code>[&lt;Struct&gt;]\ntype Complex(r : float, I : float) =\n    member x.R = r\n    member x.I = i\n</code></pre> <p>Structs that have primary constructors must accept at least one argument.</p> <p>Structs may have additional constructors. For example:</p> <pre><code>[&lt;Struct&gt;]\ntype Complex(r : float, I : float) =\n    member x.R = r\n    member x.I = i\n    new(r : float) = new Complex(r, 0.0)\n</code></pre> <p>The fields in a struct may be mutable only if the struct does not have a primary constructor. For example:</p> <pre><code>[&lt;Struct&gt;]\ntype MutableComplex =\n    val mutable real : float;\n    val mutable imaginary : float\n    member x.R = x.real\n    member x.I = x.imaginary\n    member x.Change(r, i) = x.real &lt;- r; x.imaginary &lt;- i\n    new (r, i) = { real = r; imaginary = i }\n</code></pre> <p>Struct types may declare members, overrides, and interface implementations. As for all types that declare overrides and interface implementations, struct types are subject to Dispatch Slot Checking (\u00a714.8).</p> <p>Structs may not have <code>inherit</code> declarations.</p> <p>Structs may not have \u201clet\u201d or \u201cdo\u201d statements unless they are static. For example, the following is not valid:</p> <pre><code>[&lt;Struct&gt;]\ntype BadStruct1 (def : int) =\n    do System.Console.WriteLine(\"Structs cannot use 'do'!\")\n</code></pre> <p>Structs may have static \u201clet\u201d or \u201cdo\u201d statements. For example, the following is valid:</p> <pre><code>[&lt;Struct&gt;]\ntype GoodStruct1 (def : int) =\n    static do System.Console.WriteLine(\"Structs can use 'static do'\")\n</code></pre> <p>A struct type must be valid according to the CLI rules for structs; in particular, recursively constructed structs are not permitted. For example, the following type definition is not permitted, because the size of <code>BadStruct2</code> would be infinite:</p> <pre><code>[&lt;Struct&gt;]\ntype BadStruct2 =\n    val data : float;\n    val rest : BadStruct2\n    new (data, rest) = { data = data; rest = rest }\n</code></pre> <p>Likewise, the implied size of the following struct would be infinite:</p> <pre><code>[&lt;Struct&gt;]\ntype BadStruct3 (data : float, rest : BadStruct3 ) =\n    member s.Data = data\n    member s.Rest = rest\n</code></pre> <p>If the types of all the fields in a struct type permit default initialization, the struct type has an implicit default constructor, which initializes all the fields to the default value. For example, the <code>Complex</code> type defined earlier in this section permits default initialization.</p> <pre><code>[&lt;Struct&gt;]\ntype Complex(r : float, I : float) =\n    member x.R = r\n    member x.I = i\n\n    new(r : float) = new Complex(r, 0.0)\n\nlet zero = Complex()\n</code></pre> <p>Note : The existence of the implicit default constructor for structs is not recorded in CLI metadata and is an artifact of the CLI specification and implementation itself. A CLI implementation permits default constructors for all struct types, although F# does not permit their direct use for F# struct types unless all field types admit default initialization. This is similar to the way that F# considers some types to have null as an abnormal value.  Public struct types for use from other CLI languages should be designed with the existence of the default zero-initializing constructor in mind.</p> <p>Record Type Defintions may also use the <code>[&lt;Struct&gt;]</code> attribute to change their representation from a reference type to a value type:</p> <pre><code>[&lt;Struct&gt;]\ntype Vector3 = { X: float; Y: float; Z: float }\n</code></pre> <p>Record structs have the following limitations:</p> <ul> <li>Unlike normal F# structs you cannot call the default constructor</li> <li>When marked with <code>[&lt;CLIMutable&gt;]</code> attribute, a default constructor is not created because it already exists implicitly</li> </ul>"},{"location":"type-definitions/#89-enum-type-definitions","title":"8.9 Enum Type Definitions","text":"<p>Occasionally the need arises to represent a type that compiles as a CLI enumeration type. An enum type definition has values that are represented by integer constants and has a CLI enumeration as its compiled form. Enum type definitions are declared by specifying integer constants in a format that is syntactically similar to a union type definition. For example:</p> <pre><code>type Color =\n    | Red = 0\n    | Green = 1\n    | Blue = 2\n\nlet rgb = (Color.Red, Color.Green, Color.Blue)\n\nlet show(colorScheme) =\n    match colorScheme with\n    | (Color.Red, Color.Green, Color.Blue) -&gt; printfn \"RGB in use\"\n    | _ -&gt; printfn \"Unknown color scheme in use\"\n</code></pre> <p>The example defines the enum type <code>Color</code>, which has the values <code>Red</code>, <code>Green</code>, and <code>Blue</code>, mapped to the constants <code>0</code>, <code>1</code>, and <code>2</code> respectively. The values are accessed by their qualified names: <code>Color.Red</code>, <code>Color.Green</code>, and <code>Color.Blue</code>.</p> <p>Each case must be given a constant value of the same type. The constant values dictate the underlying type of the enum, and must be one of the following types:</p> <ul> <li><code>sbyte</code>, <code>int16</code>, <code>int32</code>, <code>int64</code> , <code>byte</code>, <code>uint16</code>, <code>uint32</code>, <code>uint64</code>, <code>char</code></li> </ul> <p>The declaration of an enumeration type in an implementation file has the following effects on the typing environment:</p> <ul> <li>Brings a named type into scope.</li> <li>Adds the named type to the inferred signature of the containing namespace or module.</li> </ul> <p>Enum types coerce to <code>System.Enum</code> and satisfy the <code>enum&lt;underlying-type&gt;</code> constraint for their underlying type.</p> <p>Each enum type declaration is implicitly annotated with the <code>RequiresQualifiedAccess</code> attribute and does not add the tags of the enumeration to the name environment.</p> <pre><code>type Color =\n    | Red = 0\n    | Green = 1\n    | Blue = 2\n\nlet red = Red // not accepted, must use Color.Red\n</code></pre> <p>Unlike unions, enumeration types are fundamentally \u201cincomplete,\u201d because CLI enumerations can be converted to and from their underlying primitive type representation. For example, a <code>Color</code> value that is not in the above enumeration can be generated by using the <code>enum</code> function from the F# library:</p> <pre><code>let unknownColor : Color = enum&lt;Color&gt;(7)\n</code></pre> <p>This statement adds the value named <code>unknownColor</code>, equal to the constant <code>7</code>, to the <code>Color</code> enumeration.</p>"},{"location":"type-definitions/#810-delegate-type-definitions","title":"8.10 Delegate Type Definitions","text":"<p>Occasionally the need arises to represent a type that compiles as a CLI delegate type. A delegate type definition has as its values functions that are represented as CLI delegate values. A delegate type definition is declared by using the <code>delegate</code> keyword with a member signature. For example:</p> <pre><code>type Handler&lt;'T&gt; = delegate of obj * 'T -&gt; unit\n</code></pre> <p>Delegates are often used when using Platform Invoke (P/Invoke) to interface with CLI libraries, as in the following example:</p> <pre><code>type ControlEventHandler = delegate of int -&gt; bool\n\n[&lt;DllImport(\"kernel32.dll\")&gt;]\nextern void SetConsoleCtrlHandler(ControlEventHandler callback, bool add)\n</code></pre>"},{"location":"type-definitions/#811-exception-definitions","title":"8.11 Exception Definitions","text":"<p>An exception definition defines a new way of constructing values of type <code>exn</code> (a type abbreviation for <code>System.Exception</code>). Exception definitions have the form:</p> <pre><code>exception ident of type1 * ... * typen\n</code></pre> <p>An exception definition has the following effect:</p> <ul> <li>The identifier <code>ident</code> can be used to generate values of type <code>exn</code>.</li> <li>The identifier <code>ident</code> can be used to pattern match on values of type <code>exn</code>.</li> <li>The definition generates a type with name <code>ident</code> that derives from <code>exn</code>.</li> </ul> <p>For example:</p> <pre><code>exception Error of int * string\nraise (Error (3, \"well that didn't work did it\"))\n\ntry\n    raise (Error (3, \"well that didn't work did it\"))\nwith\n    | Error(sev, msg) -&gt; printfn \"severity = %d, message = %s\" sev msg\n</code></pre> <p>The type that corresponds to the exception definition can be used as a type in F# code. For example:</p> <pre><code>let exn = Error (3, \"well that didn't work did it\")\nlet checkException() =\n    if (exn :? Error) then printfn \"It is of type Error\"\n    if (exn.GetType() = typeof&lt;Error&gt;) then printfn \"Yes, it really is of type Error\"\n</code></pre> <p>Exception abbreviations may abbreviate existing exception constructors. For example:</p> <pre><code>exception ThatWentBadlyWrong of string * int\nexception ThatWentWrongBadly = ThatWentBadlyWrong\n\nlet checkForBadDay() =\n    if System.DateTime.Today.DayOfWeek = System.DayOfWeek.Monday then\n        raise (ThatWentWrongBadly(\"yes indeed\",123))\n</code></pre> <p>Exception values may also be generated by defining and using classes that extend <code>System.Exception</code>.</p>"},{"location":"type-definitions/#812-type-extensions","title":"8.12 Type Extensions","text":"<p>A type extension associates additional members with an existing type. For example, the following associates the additional member <code>IsLong</code> with the existing type <code>System.String</code>:</p> <pre><code>type System.String with\n    member x.IsLong = (x.Length &gt; 1000)\n</code></pre> <p>Type extensions may be applied to any accessible type definition except those defined by type abbreviations. For example, to add an extension method to a list type, use <code>'a List</code> because <code>'a list</code> is a type abbreviation of <code>'a List</code>. For example:</p> <pre><code>type 'a List with\n    member x.GetOrDefault(n) =\n        if x.Length &gt; n then x.[n]\n        else Unchecked.defaultof&lt;'a&gt;\nlet intlst = [1; 2; 3]\nintlst.GetOrDefault(1) //2\nintlst.GetOrDefault(4) //0\n</code></pre> <p>For an array type, backtick marks can be used to define an extension method to the array type:</p> <pre><code>type 'a ``[]`` with\n    member x.GetOrDefault(n) =\n        if x.Length &gt; n then x.[n]\n        else Unchecked.defaultof&lt;'a&gt;\nlet arrlist = [| 1; 2; 3 |]\narrlist.GetOrDefault(1) //2\narrlist.GetOrDefault(4) //0\n</code></pre> <p>A type can have any number of extensions.</p> <p>If the type extension is in the same module or namespace declaration group as the original type definition, it is called an intrinsic extension. Members that are defined in intrinsic extensions follow the same name resolution and other language rules as members that are defined as part of the original type definition.</p> <p>If the type extension is not intrinsic, it must be in a module, and it is called an extension member. Opening a module that contains an extension member extends the name resolution of the dot syntax for the extended type. That is, extension members are accessible only if the module that contains the extension is open.</p> <p>Name resolution for members that are defined in type extensions behaves as follows:</p> <ul> <li>In method application resolution (see \u00a714.4), regular members (that is, members that are part of     the original definition of a type, plus intrinsic extensions) are preferred to extension members.</li> <li>Extension members that are in scope and have the correct name are included in the group of     members considered for method application resolution (see \u00a714.4).</li> <li>An intrinsic member is always preferred to an extension member. If an extension member has     the same name and type signature as a member in the original type definition or an inherited     member, then it will be inaccessible.</li> </ul> <p>The following illustrates the definition of one intrinsic and one extension member for the same type:</p> <pre><code>namespace Numbers\ntype Complex(r : float, i : float) =\n    member x.R = r\n    member x.I = i\n\n// intrinsic extension\ntype Complex with\n    static member Create(a, b) = new Complex (a, b)\n    member x.RealPart = x.R\n    member x.ImaginaryPart = x.I\n\nnamespace Numbers\n\nmodule ComplexExtensions =\n\n    // extension member\n    type Numbers.Complex with\n        member x.Magnitude = ...\n        member x.Phase = ...\n</code></pre> <p>Extensions may define both instance members and static members.</p> <p>Extensions are checked as follows:</p> <ul> <li>Checking applies to the member definitions in an extension together with the members and     other definitions in the group of type definitions of which the extension is a part.</li> <li>Two intrinsic extensions may not contain conflicting members because intrinsic extensions are     considered part of the definition of the type.</li> <li>Extensions may not define fields, interfaces, abstract slots, inherit declarations, or dispatch slot     (interface and override) implementations.</li> <li>Extension members must be in modules.</li> <li>Extension members are compiled as CLI static members with encoded names.</li> <li>The elaborated form of an application of a static extension member <code>C.M(arg1, ..., argn)</code> is a call        to this static member with arguments <code>arg1, ..., argn</code>.</li> <li>The elaborated form of an application of an instance extension member <code>obj.M(arg1, ..., argn)</code>        is an invocation of the static instance member where the object parameter is supplied as the        first argument to the extension member followed by arguments <code>arg1 ... argn</code>.</li> </ul>"},{"location":"type-definitions/#8121-imported-cli-c-extensions-members","title":"8.12.1 Imported CLI C# Extensions Members","text":"<p>The CLI C# language defines an \u201cextension member,\u201d which commonly occurs in CLI libraries, along with some other CLI languages. C# limits extension members to instance methods.</p> <p>C#-defined extension members are made available to F# code in environments where the C#- authored assembly is referenced and an <code>open</code> declaration of the corresponding namespace is in effect.</p> <p>The encoding of compiled names for F# extension members is not compatible with C# encodings of C# extension members. However, for instance extension methods, the naming can be made compatible. For example:</p> <pre><code>open System.Runtime.CompilerServices\n\n[&lt;Extension&gt;]\nmodule EnumerableExtensions =\n    [&lt;CompiledName(\"OutputAll\"); Extension&gt;]\n    type System.Collections.Generic.IEnumerable&lt;'T&gt; with\n        member x.OutputAll (this:seq&lt;'T&gt;) =\n            for x in this do\n                System.Console.WriteLine (box x)\n</code></pre> <p>C#-style extension members may also be declared directly in F#. When combined with the \u201cinline\u201d feature of F#, this allows the definition of generic, constrained extension members that are not otherwise definable in C# or F#.</p> <pre><code>[&lt;Extension&gt;]\ntype ExtraCSharpStyleExtensionMethodsInFSharp () =\n    [&lt;Extension&gt;]\n    static member inline Sum(xs: seq&lt;'T&gt;) = Seq.sum xs\n</code></pre> <p>Such an extension member can be used as follows:</p> <pre><code>let listOfIntegers = [ 1 .. 100 ]\nlet listOfBigIntegers = [ 1I .. 100I ]\nlistOfIntegers.Sum()\nlistOfBigIntegers.Sum()\n</code></pre>"},{"location":"type-definitions/#813-members","title":"8.13 Members","text":"<p>Member definitions describe functions that are associated with type definitions and/or values of particular types. Member definitions can be used in type definitions. Members can be classified as follows:</p> <ul> <li>Property members</li> <li>Method members</li> </ul> <p>A static member is prefixed by <code>static</code> and is associated with the type, rather than with any particular object. Here are some examples of static members:</p> <pre><code>type MyClass() =\n    static let mutable adjustableStaticValue = \"3\"\n    static let staticArray = [| \"A\"; \"B\" |]\n    static let staticArray2 = [|[| \"A\"; \"B\" |]; [| \"A\"; \"B\" |] |]\n\n    static member StaticMethod(y:int) = 3 + 4 + y\n\n    static member StaticProperty = 3 + staticArray.Length\n\n    static member StaticProperty2\n        with get() = 3 + staticArray.Length\n\n    static member MutableStaticProperty\n        with get() = adjustableStaticValue\n        and set(v:string) = adjustableStaticValue &lt;- v\n\n    static member StaticIndexer\n        with get(idx) = staticArray.[idx]\n\n    static member StaticIndexer2\n        with get(idx1,idx2) = staticArray2.[idx1].[idx2]\n\n    static member MutableStaticIndexer\n        with get (idx1) = staticArray.[idx1]\n        and set (idx1) (v:string) = staticArray.[idx1] &lt;- v\n</code></pre> <p>An instance member is a member without <code>static</code>. Here are some examples of instance members:</p> <pre><code>type MyClass() =\n    let mutable adjustableInstanceValue = \"3\"\n    let instanceArray = [| \"A\"; \"B\" |]\n    let instanceArray2 = [| [| \"A\"; \"B\" |]; [| \"A\"; \"B\" |] |]\n\n    member x.InstanceMethod(y:int) = 3 + y + instanceArray.Length\n\n    member x.InstanceProperty = 3 + instanceArray.Length\n\n    member x.InstanceProperty2\n        with get () = 3 + instanceArray.Length\n\n    member x.InstanceIndexer\n        with get (idx) = instanceArray.[idx]\n\n    member x.InstanceIndexer2\n        with get (idx1,idx2) = instanceArray2.[idx1].[idx2]\n\n    member x.MutableInstanceProperty\n        with get () = adjustableInstanceValue\n        and set (v:string) = adjustableInstanceValue &lt;- v\n\n    member x.MutableInstanceIndexer\n        with get (idx1) = instanceArray.[idx1]\n        and set (idx1) (v:string) = instanceArray.[idx1] &lt;- v\n</code></pre> <p>Members from a set of mutually recursive type definitions are checked as a single mutually recursive group. As with collections of recursive functions, recursive calls to potentially-generic methods may result in inconsistent type constraints:</p> <pre><code>type Test() =\n    static member Id x = x\n    member t.M1 (x: int) = Test.Id(x)\n    member t.M2 (x: string) = Test.Id(x) // error, x has type 'string' not 'int'\n</code></pre> <p>A target method that has a full type annotation is eligible for early generalization (\u00a714.6.7).</p> <pre><code>type Test() =\n    static member Id&lt;'T&gt; (x:'T) : 'T = x\n    member t.M1 (x: int) = Test.Id(x)\n    member t.M2 (x: string) = Test.Id(x)\n</code></pre>"},{"location":"type-definitions/#8131-property-members","title":"8.13.1 Property Members","text":"<p>A property member is a <code>method-or-prop-defn</code> in one of the following forms:</p> <pre><code>static~opt member ident.~opt ident = expr\nstatic~opt member ident.~opt ident with get pat = expr\nstatic~opt member ident.~opt ident with set pat~opt pat = expr\nstatic~opt member ident.~opt ident with get pat = expr and set pat~opt pat = expr\nstatic~opt member ident.~opt ident with set pat~opt pat = expr and get pat = expr\n</code></pre> <p>A property member in the form</p> <pre><code>static~opt member ident.~opt ident with get pat1 = expr1 and set pat2a pat2b~opt = expr2\n</code></pre> <p>is equivalent to two property members of the form:</p> <pre><code>static~opt member ident.~opt ident with get pat1 = expr1\nstatic~opt member ident.~opt ident with set pat2a pat2b~opt = expr2\n</code></pre> <p>Furthermore, the following two members are equivalent:</p> <pre><code>static~opt member ident.~opt ident = expr\nstatic~opt member ident.~opt ident with get() = expr\n</code></pre> <p>These two are also equivalent:</p> <pre><code>static~opt member ident.~opt ident with set pat = expr\nstatic~opt member ident.~opt ident with set() pat = expr\n</code></pre> <p>Thus, property members may be reduced to the following two forms:</p> <pre><code>static~opt member ident.~opt ident with get patidx = expr\nstatic~opt member ident.~opt ident with set patidx pat = expr\n</code></pre> <p>The <code>ident.~opt</code> must be present if and only if the property member is an instance member. When evaluated, the identifier <code>ident</code> is bound to the \u201cthis\u201d or \u201cself\u201d object parameter that is associated with the object within the expression <code>expr</code>.</p> <p>A property member is an indexer property if <code>patidx</code> is not the unit pattern <code>()</code>. Indexer properties called <code>Item</code> are special in the sense that they are accessible via the <code>.[]</code> notation. An <code>Item</code> property that takes one argument is accessed by using <code>x.[i]</code>; with two arguments by <code>x.[i,j]</code>, and so on. Setter properties must return type <code>unit</code>.</p> <p>Note : As of F# 3. 1 , the special <code>.[]</code> notation for <code>Item</code> properties is available only for instance members. A static indexer property cannot be accessible by using the <code>.[]</code> notation.</p> <p>Property members may be declared <code>abstract</code>. If a property has both a getter and a setter, then both must be abstract or neither must be abstract.</p> <p>Each property member has an implied property type. The property type is the type of the value that the getter property returns or the setter property accepts. If a property member has both a getter and a setter, and neither is an indexer property, the signatures of both the getter and the setter must imply the same property type.</p> <p>Static and instance property members are evaluated every time the member is invoked. For example, in the following, the body of the member is evaluated each time <code>C.Time</code> is evaluated:</p> <pre><code>type C () =\n    static member Time = System.DateTime.Now\n</code></pre> <p>Note that a static property member may also be written with an explicit <code>get</code> method:</p> <pre><code>static member ComputerName\n    with get() = System.Environment.GetEnvironmentVariable(\"COMPUTERNAME\")\n</code></pre> <p>Property members that have the same name may not appear in the same type definition even if their signatures are different. For example:</p> <pre><code>type C () =\n    static member P = false // error: Duplicate property.\n    member this.P = true\n</code></pre> <p>However, methods that have the same name can be overloaded when their signatures are different.</p>"},{"location":"type-definitions/#8132-auto-implemented-properties","title":"8.13.2 Auto-implemented Properties","text":"<p>Properties can be declared in two ways: either explicitly specified with the underlying value or automatically generated by the compiler. The compiler creates a backing field automatically if all of the following are true for the declaration:</p> <ul> <li>The declaration uses the <code>member val</code> keywords.</li> <li>The declaration omits the self-identifier.</li> <li>The declaration includes an expression to initialize the property.</li> </ul> <p>To create a mutable property, include <code>with get</code>, <code>with set</code>,or both:</p> <pre><code>static~opt member val access~opt ident : ty~opt = expr\nstatic~opt member val access~opt ident : ty~opt = expr with get\nstatic~opt member val access~opt ident : ty~opt = expr with set\nstatic~opt member val access~opt ident : ty~opt = expr with get, set\n</code></pre> <p>Automatically implemented properties are part of the initialization of a type, so they must be included before any other member definitions, in the same way as let bindings and do bindings in a type definition. The expression that initializes an automatically implemented property is evaluated only at initialization, and not every time the property is accessed. This behavior is different from the behavior of an explicitly implemented property.</p> <p>For example, the following class type includes two automatically implemented properties. <code>Property1</code> is read-only and is initialized to the argument provided to the primary constructor and <code>Property2</code> is a settable property that is initialized to an empty string:</p> <pre><code>type D (x:int) =\n    member val Property1 = x\n    member val Property2 = \"\" with get, set\n</code></pre> <p>Auto-implemented properties can also be used to implement default or override properties:</p> <pre><code>type MyBase () =\n    abstract Property : string with get, set\n    default val Property = \u201cdefault\u201d with get, set\n\ntype MyDerived() =\n    inherit MyBase()\n    override val Property = \"derived\" with get, set\n</code></pre> <p>The following example shows how to use an auto-implemented property to implement an interface:</p> <pre><code>type MyInterface () =\n    abstract Property : string with get, set\n\ntype MyImplementation () =\n    interface MyInterface with\n        member val Property = \"implemented\" with get, set\n</code></pre>"},{"location":"type-definitions/#8133-method-members","title":"8.13.3 Method Members","text":"<p>A method member is of the form:</p> <pre><code>static~opt member ident.~opt ident pat1 ... patn = expr\n</code></pre> <p>The <code>ident.~opt</code> can be present if and only if the property member is an instance member. In this case, the identifier <code>ident</code> corresponds to the \u201cthis\u201d (or \u201cself\u201d) variable associated with the object on which the member is being invoked.</p> <p>Arity analysis (\u00a714.11) applies to method members. This is because F# members must compile to CLI methods, which accept only a single fixed collection of arguments.</p>"},{"location":"type-definitions/#8134-curried-method-members","title":"8.13.4 Curried Method Members","text":"<p>Methods that take multiple arguments may be written in iterated (\u201ccurried\u201d) form. For example:</p> <pre><code>static member StaticMethod2 s1 s2 =\n    sprintf \"In StaticMethod(%s,%s)\" s1 s2\n</code></pre> <p>The rules of arity analysis (\u00a714.11) determine the compiled form of these members.</p> <p>The following limitations apply to curried method members:</p> <ul> <li>Additional argument groups may not include optional or byref parameters.</li> <li>When the member is called, additional argument groups may not use named     arguments(\u00a78.13.5).</li> <li>Curried members may not be overloaded.</li> </ul> <p>The compiled representation of a curried method member is a .NET method in which the arguments are concatenated into a single argument group.</p> <p>Note : It is recommended that curried argument members do not appear in the public API of an F# assembly that is designed for use from other .NET languages. Information about the currying order is not visible to these languages.</p>"},{"location":"type-definitions/#8135-named-arguments-to-method-members","title":"8.13.5 Named Arguments to Method Members","text":"<p>Calls to methods\u2014but not to let-bound functions or function values\u2014may use named arguments. For example:</p> <pre><code>System.Console.WriteLine(format = \"Hello {0}\", arg0 = \"World\")\nSystem.Console.WriteLine(\"Hello {0}\", arg0 = \"World\")\nSystem.Console.WriteLine(arg0 = \"World\", format = \"Hello {0}\")\n</code></pre> <p>The argument names that are associated with a method declaration are derived from the names that appear in the first pattern of a member definition, or from the names used in the signature for a method member. For example:</p> <pre><code>type C() =\n    member x.Swap(first, second) = (second, first)\nlet c = C()\nc.Swap(first = 1,second = 2) // result is '(2,1)'\nc.Swap(second = 1,first = 2) // result is '(1,2)'\n</code></pre> <p>Named arguments may be used only with the arguments that correspond to the arity of the member. That is, because members have an arity only up to the first set of tupled arguments, named arguments may not be used with subsequent curried arguments of the member.</p> <p>The resolution of calls that use named arguments is specified in Method Application Resolution (see \u00a714.4). The rules in that section describe how resolution matches a named argument with either a formal parameter of the same name or a \u201csettable\u201d return property of the same name. For example, the following code resolves the named argument to a settable property:</p> <pre><code>System.Windows.Forms.Form(Text = \"Hello World\")\n</code></pre> <p>If an ambiguity exists, assigning the named argument is assigned to a formal parameter rather than to a settable return property.</p> <p>The Method Application Resolution (\u00a714.4) rules ensure that:</p> <ul> <li>Named arguments must appear after all other arguments, including optional arguments that     are matched by position.</li> </ul> <p>After named arguments have been assigned, the remaining required arguments are called the required unnamed arguments. The required unnamed arguments must precede the named arguments in the argument list. The n unnamed arguments are matched to the first n formal parameters; the subsequent named arguments must include only the remaining formal parameters. In addition, the arguments must appear in the correct sequence.</p> <p>For example, the following code is invalid:</p> <pre><code>// error: unnamed args after named\nSystem.Console.WriteLine(arg0 = \"World\", \"Hello {0}\")\n</code></pre> <p>Similarly, the following code is invalid:</p> <pre><code>type Foo() =\n    static member M (arg1, arg2, arg3) = 1\n// error: arg1, arg3 not a prefix of the argument list\nFoo.M(1, 2, arg2 = 3)\n</code></pre> <p>The following code is valid:</p> <pre><code>type Foo() =\n    static member M (arg1, arg2, arg3) = 1\n\nFoo.M (1, 2, arg 3 = 3)\n</code></pre> <p>The names of arguments to members may be listed in member signatures. For example, in a signature file:</p> <pre><code>type C =\n    static member ThreeArgs : arg1:int * arg2:int * arg3:int -&gt; int\n    abstract TwoArgs : arg1:int * arg2:int -&gt; int\n</code></pre>"},{"location":"type-definitions/#8136-optional-arguments-to-method-members","title":"8.13.6 Optional Arguments to Method Members","text":"<p>Method members\u2014but not functions definitions\u2014may have optional arguments. F# supports two forms of optional arguments: F#-style optional arguments and CLI-compatible optional arguments.</p> <p>CLI-compatible optional arguments are handled on the caller side. When a method call omits an optional argument, the compiler reads the default value from the method's metadata and explicitly passes that value. This contrasts with F#-style optional arguments, which are handled by the callee. With F#-style optional arguments, if an argument is omitted, the compiler passes <code>None</code>, and the callee determines the default value to use.</p> <p>From the caller's perspective both styles appear as optional arguments. However, their underlying mechanism and primary use cases differ.</p> <p>The compiled representation of members varies as additional optional arguments are added. The addition of optional arguments to a member signature results in a compiled form that is not binary- compatible with the previous compiled form.</p>"},{"location":"type-definitions/#81361-f-style-optional-arguments","title":"8.13.6.1 F#-Style Optional Arguments","text":"<p>F#-style optional arguments must appear at the end of the argument list. An optional argument is marked with a <code>?</code> before its name in the method declaration. Inside the member, the argument has the type <code>option&lt;argType&gt;</code>. The <code>option</code> type is used to represent a value that may or may not exist.</p> <p>The following example declares a method member that has two optional arguments:</p> <pre><code>let defaultArg x y = match x with None -&gt; y | Some v -&gt; v\n\ntype T() =\n    static member OneNormalTwoOptional (arg1, ?arg2, ?arg3) =\n        let arg2 = defaultArg arg2 3\n        let arg3 = defaultArg arg3 10\n        arg1 + arg2 + arg3\n</code></pre> <p>Optional arguments may be used in interface and abstract members. In a signature, optional arguments appear as follows:</p> <pre><code>static member OneNormalTwoOptional : arg1:int * ?arg2:int * ?arg3:int -&gt; int\n</code></pre> <p>Callers may specify values for optional arguments in the following ways:</p> <ul> <li>By name, such as <code>arg2 = 1</code>.</li> <li>By propagating an existing optional value by name, such as <code>?arg2=None</code> or <code>?arg2=Some(3)</code> or     <code>?arg2=arg2</code>. This can be useful when building a method that passes optional arguments on to     another method.</li> <li>By using normal, unnamed arguments that are matched by position.</li> </ul> <p>For example:</p> <pre><code>T.OneNormalTwoOptional(3)\nT.OneNormalTwoOptional(3, 2)\nT.OneNormalTwoOptional(arg1 = 3)\nT.OneNormalTwoOptional(arg1 = 3, arg2 = 1)\nT.OneNormalTwoOptional(arg2 = 3, arg1 = 0)\nT.OneNormalTwoOptional(arg2 = 3, arg1 = 0, arg3 = 11)\nT.OneNormalTwoOptional(0, 3, 11)\nT.OneNormalTwoOptional(0, 3, arg3 = 11)\nT.OneNormalTwoOptional(arg1 = 3, ?arg2 = Some 1)\nT.OneNormalTwoOptional(arg2 = 3, arg1 = 0, arg3 = 11)\nT.OneNormalTwoOptional(?arg2 = Some 3, arg1 = 0, arg3 = 11)\nT.OneNormalTwoOptional(0, 3, ?arg3 = Some 11)\n</code></pre> <p>The resolution of calls that use optional arguments is specified in Method Application Resolution (see \u00a714.4).</p> <p>Optional arguments may not be used in member constraints.</p> <p>Marking an argument as optional is equivalent to adding the <code>FSharp.Core.OptionalArgument</code> attribute (\u00a717.1) to a required argument. This attribute is added implicitly for optional arguments. Adding the <code>[&lt;OptionalArgument&gt;]</code> attribute to a parameter of type <code>'a option</code> in a virtual method signature is equivalent to using the <code>(?x:'a)</code> syntax in a method definition. If the attribute is applied to an argument of a method, it should also be applied to all subsequent arguments of the method. Otherwise, it has no effect and callers must provide all of the arguments.</p>"},{"location":"type-definitions/#81362-cli-compatible-optional-arguments","title":"8.13.6.2 CLI-Compatible Optional Arguments","text":"<p>For interoperability with C# and other CLI languages, F# supports optional arguments with default values using the <code>Optional</code> and <code>DefaultParameterValue</code> attributes. This mechanism is equivalent to defining an optional argument in C# with a default value, such as <code>MyMethod(int i = 3)</code>. In F#, this would be written as:</p> <pre><code>open System.Runtime.InteropServices\n\ntype C() =\n    static member MyMethod([&lt;Optional; DefaultParameterValue(3)&gt;] i: int) =\n        i + 1\n</code></pre> <p>These attributes are typically used for C# and VB interop so that callers in those languages see an argument as optional. They can also be from F# code in the same assembly and from separate assemblies.</p> <p>CLI-compatible optional arguments are not passed as values of type <code>Option&lt;_&gt;</code>. If the optional argument is present, its value is passed. If the optional argument is omitted, the default value from the CLI metadata is supplied instead. The value <code>System.Reflection.Missing.Value</code> is supplied for any CLI optional arguments of type <code>System.Object</code> that do not have a corresponding CLI default value, and the default (zero-bit pattern) value is supplied for other CLI optional arguments of other types that have no default value.</p>"},{"location":"type-definitions/#813621-allowable-default-values","title":"8.13.6.2.1 Allowable Default Values","text":"<p>The <code>DefaultParameterValue</code> attribute accepts the following types of values:</p> <ul> <li>Primitive Types: Constant values for <code>sbyte</code>, <code>byte</code>, <code>int16</code>, <code>uint16</code>, <code>int32</code>, <code>uint32</code>, <code>int64</code>, <code>uint64</code>, <code>float32</code>, <code>float</code>, and <code>string</code>.</li> <li>Reference Types: The only allowed default value is <code>null</code>.</li> <li>Value Types: The only allowed default value is the default value of the struct.</li> </ul>"},{"location":"type-definitions/#813622-usage-and-considerations","title":"8.13.6.2.2 Usage and Considerations","text":"<p>The value provided to <code>DefaultParameterValue</code> must match the parameter's type. A mismatch will generate a compiler warning, and both the <code>Optional</code> and <code>DefaultParameterValue</code> attributes will be ignored.</p> <p>For example, the following is not allowed:</p> <pre><code>type Class() =\n  static member Wrong([&lt;Optional; DefaultParameterValue(\"string\")&gt;] i:int) = ()```\n\nThis will be compiled as if it were written:\n```fsharp\ntype Class() =\n  static member Wrong(i:int) = ()\n</code></pre> <p>Note that the <code>null</code> value for reference types must be type-annotated, for instance: <code>[&lt;Optional; DefaultParameterValue(null:obj)&gt;] o:obj</code>.</p> <p>It is possible to use these attributes in the following ways, though it is not standard practice:</p> <ul> <li>Specifying <code>Optional</code> without <code>DefaultParameterValue</code>: Callers can omit the argument, and a default value will be chosen by convention (the default constructor for primitive types and structs).</li> <li>Specifying <code>DefaultParameterValue</code> without <code>Optional</code>.</li> <li>Specifying <code>Optional; DefaultParameterValue</code> on any parameter, not necessarily the last one.</li> </ul> <p>Note : Imported CLI metadata may specify arguments as optional and may additionally specify a default value for the argument. CLI optional arguments can propagate an existing optional value by name; for example, <code>?ValueTitle = Some (...)</code>. For example, here is a fragment of a call to a Microsoft Excel COM automation API that uses named and optional arguments.</p> <pre><code>    chartobject.Chart.ChartWizard(Source = range5,\n                                  Gallery = XlChartType.xl3DColumn,\n                                  PlotBy = XlRowCol.xlRows,\n                                  HasLegend = true,\n                                  Title = \"Sample Chart\",\n                                  CategoryTitle = \"Sample Category Type\",\n                                  ValueTitle = \"Sample Value Type\")\n</code></pre>"},{"location":"type-definitions/#8137-type-directed-conversions-at-member-invocations","title":"8.13.7 Type-directed Conversions at Member Invocations","text":"<p>As described in Method Application Resolution (see \u00a714.4), three type-directed conversions are applied at method invocations.</p>"},{"location":"type-definitions/#81371-conversion-to-delegates","title":"8.13.7.1 Conversion to Delegates","text":"<p>The first type-directed conversion converts anonymous function expressions and other function- valued arguments to delegate types. Given:</p> <ul> <li>A formal parameter of delegate type <code>D</code></li> <li>An actual argument <code>farg</code> of known type <code>ty1 -&gt; ... -&gt; tyn -&gt; rty</code></li> <li>Precisely <code>n</code> arguments to the <code>Invoke</code> method of delegate type <code>D</code></li> </ul> <p>Then:</p> <ul> <li> <p>The parameter is interpreted as if it were written:</p> <pre><code>new D (fun arg1 ... argn -&gt; farg arg1 ... argn)\n</code></pre> </li> </ul> <p>If the type of the formal parameter is a variable type, then F# uses the known inferred type of the argument including instantiations to determine whether a formal parameter has delegate type. For example, if an explicit type instantiation is given that instantiates a generic type parameter to a delegate type, the following conversion can apply:</p> <pre><code>type GenericClass&lt;'T&gt;() =\n    static member M(arg: 'T) = ()\n\nGenericClass&lt;System.Action&gt;.M(fun () -&gt; ()) // allowed\n</code></pre>"},{"location":"type-definitions/#81372-conversion-to-reference-cells","title":"8.13.7.2 Conversion to Reference Cells","text":"<p>The second type-directed conversion enables an F# reference cell to be passed where a <code>byref&lt;ty&gt;</code> is expected. Given:</p> <ul> <li>A formal out parameter of type <code>byref&lt;ty&gt;</code></li> <li>An actual argument that is not a byref type</li> </ul> <p>Then:</p> <ul> <li>The actual parameter is interpreted as if it had type <code>ref&lt;ty&gt;</code>.</li> </ul> <p>For example:</p> <pre><code>type C() =\n    static member M1(arg: System.Action) = ()\n    static member M2(arg: byref&lt;int&gt;) = ()\n\nC.M1(fun () -&gt; ()) // allowed\nlet f = (fun () -&gt; ()) in C.M1(f) // not allowed\n\nlet result = ref 0\nC.M2(result) // allowed\n</code></pre> <p>Note: These type-directed conversions are primarily for interoperability with existing member-based .NET libraries and do not apply at invocations of functions defined in modules or bound locally in expressions.</p> <p>A value of type <code>ref&lt;ty&gt;</code> may be passed to a function that accepts a byref parameter. The interior address of the heap-allocated cell that is associated with such a parameter is passed as the pointer argument.</p> <p>For example, consider the following C# code:</p> <pre><code>public class C\n{\n    static public void IntegerOutParam(out int x) { x = 3; }\n}\npublic class D\n{\n    virtual public void IntegerOutParam(out int x) { x = 3; }\n}\n</code></pre> <p>This C# code can be called by the following F# code:</p> <pre><code>let res1 = ref 0\nC.IntegerOutParam(res 1 )\n// res1.contents now equals 3\n</code></pre> <p>Likewise, the abstract signature can be implemented as follows:</p> <pre><code>let x = {new D() with IntegerOutParam(res : byref&lt;int&gt;) = res &lt;- 4}\nlet res2 = ref 0\nx.IntegerOutParam(res2);\n// res2.contents now equals 4\n</code></pre>"},{"location":"type-definitions/#81373-conversion-to-quotation-values","title":"8.13.7.3 Conversion to Quotation Values","text":"<p>The third type-directed conversion enables an F# expression to be implicitly quoted at a member call.</p> <p>Conversion to a quotation value is driven by the ReflectedDefinition attribute to a method argument of type FSharp.Quotations.Expr&lt;_&gt;:</p> <pre><code>static member Plot([&lt;ReflectedDefinition&gt;] values:Expr&lt;int&gt;) = (...)\n</code></pre> <p>The intention is that this gives an implicit quotation from X --&gt; &lt;@ X @&gt; at the callsite. So for</p> <pre><code>Chart.Plot(f x + f y)\n</code></pre> <p>the caller becomes:</p> <pre><code>Chart.Plot(&lt;@ f x + f y @&gt;)\n</code></pre> <p>Additionally, the method can declare that it wants both the quotation and the evaluation of the expression, by giving <code>true</code> as the <code>includeValue</code> argument of the <code>ReflectedDefinitionAttribute</code>.</p> <pre><code>static member Plot([&lt;ReflectedDefinition(true)&gt;] values:Expr&lt;X&gt;) = (...)\n</code></pre> <p>So for</p> <pre><code>Chart.Plot(f x + f y)\n</code></pre> <p>the caller becomes:</p> <pre><code>Chart.Plot(Expr.WithValue(f x + f y, &lt;@ f x + f y @&gt;))\n</code></pre> <p>and the quotation value <code>Q</code> received by <code>Chart.Plot</code> matches:</p> <pre><code>match Q with\n| Expr.WithValue(v, ty) --&gt; // v = f x + f y\n| ...\n</code></pre> <p>Note: Methods with ReflectedDefinition arguments may be used as first class values (including pipelined uses), but it will not normally be useful to use them in this way. This is because, in the above example, a first-class use of the method <code>Chart.Plot</code> is considered shorthand for <code>(fun x -&gt; C.Plot(x))</code> for some compiler-generated local name <code>x</code>, which will become <code>(fun x -&gt; C.Plot( &lt;@ x @&gt; ))</code>, so the implicit quotation will just be a local value substitution. This means a pipelines use <code>expr |&gt; C.Plot</code> will not capture a full quotation for <code>expr</code>, but rather just its value.  The same applies to auto conversions for LINQ expressions: if you pipeline a method accepting Expression arguments. This is an intrinsic cost of having an auto-quotation meta-programming facility. All uses of auto-quotation need careful use API designers.  Auto-quotation of arguments only applies at method calls, and not function calls.  The conversion only applies if the called-argument-type is type Expr for some type T, and if the caller-argument type is not of the form Expr for any U.  The caller-argument-type is determined as normal, with the addition that a caller argument of the form &lt;@ ... @&gt; is always considered to have a type of the form Expr&lt;&gt;, in the same way that caller arguments of the form (fun x -&gt; ...) are always assumed to have type of the form <code>-&gt; _</code> (i.e. a function type)</p>"},{"location":"type-definitions/#81374-conversion-to-linq-expressions","title":"8.13.7.4 Conversion to LINQ Expressions","text":"<p>The third type-directed conversion enables an F# expression to be implicitly converted to a LINQ expression at a method call. Conversion is driven by an argument of type <code>System.Linq.Expressions.Expression</code>.</p> <pre><code>static member Plot(values:Expression&lt;Func&lt;int,int&gt;&gt;) = (...)\n</code></pre> <p>This attribute results in an implicit quotation from X --&gt; &lt;@ X @&gt; at the callsite and a call for a helper function. So for</p> <pre><code>Chart.Plot(f x + f y)\n</code></pre> <p>the caller becomes:</p> <pre><code>Chart.Plot(FSharp.Linq.RuntimeHelpers.LeafExpressionConverter.\nQuotationToLambdaExpression &lt;@ f x + f y @&gt;)\n</code></pre>"},{"location":"type-definitions/#8138-overloading-of-methods","title":"8.13.8 Overloading of Methods","text":"<p>Multiple methods that have the same name may appear in the same type definition or extension. For example:</p> <pre><code>type MyForm() =\n    inherit System.Windows.Forms.Form()\n\n    member x.ChangeText(text: string) =\n        x.Text &lt;- text\n\n    member x.ChangeText(text: string, reason: string) =\n        x.Text &lt;- text\n        System.Windows.Forms.MessageBox.Show (\"changing text due to \" + reason)\n</code></pre> <p>Methods must be distinct based on their name and fully inferred types, after erasure of type abbreviations and unit-of-measure annotations.</p> <p>Methods that take curried arguments may not be overloaded.</p>"},{"location":"type-definitions/#8139-naming-restrictions-for-members","title":"8.13.9 Naming Restrictions for Members","text":"<p>A member in a record type may not have the same name as a record field in that type.</p> <p>A member may not have the same name and signature as another method in the type. This check ignores return types except for members that are named <code>op_Implicit</code> or <code>op_Explicit</code>.</p>"},{"location":"type-definitions/#81310-members-represented-as-events","title":"8.13.10 Members Represented as Events","text":"<p>Events are the CLI notion of a \u201clistening point\u201d\u2014that is, a configurable object that holds a set of callbacks, which can be triggered, often by some external action such as a mouse click or timer tick.</p> <p>In F#, events are first-class values; that is, they are objects that mediate the addition and removal of listeners from a backing list of listeners. The F# library supports the type <code>FSharp.Control.IEvent&lt;_,_&gt;</code> and the module <code>FSharp.Control.Event</code>, which contains operations to map, fold, create, and compose events. The type is defined as follows:</p> <pre><code>type IDelegateEvent&lt;'del when 'del :&gt; System.Delegate &gt; =\n    abstract AddHandler : 'del -&gt; unit\n    abstract RemoveHandler : 'del -&gt; unit\n\ntype IEvent&lt;'Del,'T when 'Del : delegate&lt;'T,unit&gt; and 'del :&gt; System.Delegate &gt; =\n    abstract Add : event : ('T -&gt; unit) -&gt; unit\n    inherit IDelegateEvent&lt;'del&gt;\n\ntype Handler&lt;'T&gt; = delegate of sender : obj * 'T -&gt; unit\n\ntype IEvent&lt;'T&gt; = IEvent&lt;Handler&lt;'T&gt;, 'T&gt;\n</code></pre> <p>The following shows a sample use of events:</p> <pre><code>open System.Windows.Forms\n\ntype MyCanvas() =\n    inherit Form()\n    let event = new Event&lt;PaintEventArgs&gt;()\n    member x.Redraw = event.Publish\n    override x.OnPaint(args) = event.Trigger(args)\n\nlet form = new MyCanvas()\nform.Redraw.Add(fun args -&gt; printfn \"OnRedraw\")\nform.Activate()\nApplication.Run(form)\n</code></pre> <p>Events from CLI languages are revealed as object properties of type <code>FSharp.Control.IEvent&lt;tydelegate, tyargs&gt;</code>. The F# compiler determines the type arguments, which are derived from the CLI delegate type that is associated with the event.</p> <p>Event declarations are not built into the F# language, and <code>event</code> is not a keyword. However, property members that are marked with the <code>CLIEvent</code> attribute and whose type coerces to <code>FSharp.Control.IDelegateEvent&lt;tydelegate&gt;</code> are compiled to include extra CLI metadata and methods that mark the property name as a CLI event. For example, in the following code, the <code>ChannelChanged</code> property is currently compiled as a CLI event:</p> <pre><code>type ChannelChangedHandler = delegate of obj * int -&gt; unit\n\ntype C() =\n    let channelChanged = new Event&lt;ChannelChangedHandler,_&gt;()\n    [&lt;CLIEvent&gt;]\n    member self.ChannelChanged = channelChanged.Publish\n</code></pre> <p>Similarly, the following shows the definition and implementation of an abstract event:</p> <pre><code>type I =\n    [&lt;CLIEvent&gt;]\n    abstract ChannelChanged : IEvent&lt;ChannelChanged,int&gt;\n\ntype ImplI() =\n    let channelChanged = new Event&lt;ChannelChanged,_&gt;()\n    interface I with\n        [&lt;CLIEvent&gt;]\n        member self.ChannelChanged = channelChanged.Publish\n</code></pre>"},{"location":"type-definitions/#81311-members-represented-as-static-members","title":"8.13.11 Members Represented as Static Members","text":"<p>Most members are represented as their corresponding CLI method or property. However, in certain situations an instance member may be compiled as a static method. This happens when either of the following is true:</p> <ul> <li> <p>The type definition uses <code>null</code> as a representation by placing the     <code>CompilationRepresentation(CompilationRepresentationFlags.UseNullAsTrueValue)</code> attribute on     the type that declares the member.</p> </li> <li> <p>The member is an extension member.</p> </li> </ul> <p>Compilation of an instance member as a static method can affect the view of the type when seen from other languages or from <code>System.Reflection</code>. A member that might otherwise have a static representation can be reverted to an instance member representation by placing the attribute <code>CompilationRepresentation(CompilationRepresentationFlags.Instance)</code> on the member.</p> <p>For example, consider the following type:</p> <pre><code>[&lt;CompilationRepresentation(CompilationRepresentationFlags.UseNullAsTrueValue)&gt;]\ntype option&lt;'T&gt; =\n    | None\n    | Some of 'T\n\n    member x.IsNone = match x with None -&gt; true | _ -&gt; false\n    member x.IsSome = match x with Some _ -&gt; true | _ -&gt; false\n\n    [&lt;CompilationRepresentation(CompilationRepresentationFlags.Instance)&gt;]\n    member x.Item =\n    match x with\n        | Some x -&gt; x\n        | None -&gt; failwith \"Option.Item\"\n</code></pre> <p>The <code>IsNone</code> and <code>IsSome</code> properties are represented as CLI static methods. The <code>Item</code> property is represented as an instance property.</p>"},{"location":"type-definitions/#814-abstract-members-and-interface-implementations","title":"8.14 Abstract Members and Interface Implementations","text":"<p>Abstract member definitions and interface declarations in a type definition represent promises that an object will provide an implementation for a corresponding contract.</p>"},{"location":"type-definitions/#8141-abstract-members","title":"8.14.1 Abstract Members","text":"<p>An abstract member definition in a type definition represents a promise that an object will provide an implementation for a dispatch slot. For example:</p> <pre><code>type IX =\n    abstract M : int -&gt; int\n</code></pre> <p>The abstract member <code>M</code> indicates that an object of type <code>IX</code> will implement a displatch slot for a member that returns an <code>int</code>.</p> <p>A class definition may contain abstract member definitions, but the definition must be labeled with the <code>AbstractClass</code> attribute:</p> <pre><code>[&lt;AbstractClass&gt;]\ntype X() =\n    abstract M : int -&gt; int\n</code></pre> <p>An abstract member definition has the form</p> <pre><code>abstract access~opt member-sig\n</code></pre> <p>where a member signature has one of the following forms</p> <pre><code>ident typar-defns~opt : curried-sig\nident typar-defns~opt : curried-sig with get\nident typar-defns~opt : curried-sig with set\nident typar-defns~opt : curried-sig with get, set\nident typar-defns~opt : curried-sig with set, get\n</code></pre> <p>and the curried signature has the form</p> <pre><code>args-spec1 -&gt; ... -&gt; args-specn -&gt; type\n</code></pre> <p>If <code>n</code> \u2265 2, then <code>args-spec2 ... args-specn</code> must all be patterns without attribute or optional argument specifications.</p> <p>If <code>get</code> or <code>set</code> is specified, the abstract member is a property member. If both <code>get</code> and <code>set</code> are specified, the abstract member is equivalent to two abstract members, one with <code>get</code> and one with <code>set</code>.</p>"},{"location":"type-definitions/#8142-members-that-implement-abstract-members","title":"8.14.2 Members that Implement Abstract Members","text":"<p>An implementation member has the form:</p> <pre><code>override ident. ident pat 1 ... patn = expr\ndefault ident. ident pat 1 ... patn = expr\n</code></pre> <p>Implementation members implement dispatch slots. For example:</p> <pre><code>[&lt;AbstractClass&gt;]\ntype BaseClass() =\n    abstract AbstractMethod : int -&gt; int\n\ntype SubClass(x: int) =\n    inherit BaseClass()\n    override obj.AbstractMethod n = n + x\n\nlet v1 = BaseClass() // not allowed \u2013 BaseClass is abstract\nlet v2 = (SubClass(7) :&gt; BaseClass)\n\nv2.AbstractMethod 6 // evaluates to 13\n</code></pre> <p>In this example, <code>BaseClass()</code> declares the abstract slot <code>AbstractMethod</code> and the <code>SubClass</code> type supplies an implementation member <code>obj.AbstractMethod</code>, which takes an argument <code>n</code> and returns the sum of <code>n</code> and the argument that was passed in the instantiation of <code>SubClass</code>. The <code>v2</code> object instantiates <code>SubClass</code> with the value <code>7</code>, so <code>v2.AbstractMethod 6</code> evaluates to <code>13</code>.</p> <p>The combination of an abstract slot declaration and a default implementation of that slot create the F# equivalent of a \u201cvirtual\u201d method in some other languages\u2014that is, an abstract member that is guaranteed to have an implementation. For example:</p> <pre><code>type BaseClass() =\n    abstract AbstractMethodWithDefaultImplementation : int -&gt; int\n    default obj.AbstractMethodWithDefaultImplementation n = n\n\ntype SubClass1(x: int) =\n    inherit BaseClass()\n    override obj.AbstractMethodWithDefaultImplementation n = n + x\n\ntype SubClass2() =\n    inherit BaseClass()\n\nlet v1 = BaseClass() // allowed -- BaseClass contains a default implementation\nlet v2 = (SubClass1(7) :&gt; BaseClass)\nlet v3 = (SubClass2() :&gt; BaseClass)\n\nv1.AbstractMethodWithDefaultImplementation 6 // evaluates to 6\nv2.AbstractMethodWithDefaultImplementation 6 // evaluates to 13\nv3.AbstractMethodWithDefaultImplementation 6 // evaluates to 6\n</code></pre> <p>Here, the <code>BaseClass</code> type contains a default implementation, so F# allows the instantiation of <code>v1</code>. The instantiation of <code>v2</code> is the same as in the previous example. The instantiation of <code>v3</code> is similar to that of <code>v1</code>, because <code>SubClass2</code> inherits directly from <code>BaseClass</code> and does not override the <code>default</code> method.</p> <p>Note: The keywords <code>override</code> and <code>default</code> are synonyms. However, it is recommended that <code>default</code> be used only when the implementation is in the same class as the corresponding abstract definition; <code>override</code> should be used in other cases. This records the intended role of the member implementation.</p> <p>Implementations may override methods from System.Object:</p> <pre><code>type BaseClass() =\n    override obj.ToString() = \"I'm an instance of BaseClass\"\n\ntype SubClass(x: int) =\n    inherit BaseClass()\n    override obj.ToString() = \"I'm an instance of SubClass\"\n</code></pre> <p>In this example, <code>BaseClass</code> inherits from <code>System.Object</code> and overrides the <code>ToString</code> method from that class. The <code>SubClass</code>, in turn, inherits from <code>BaseClass</code> and overrides its version of the <code>ToString</code> method.</p> <p>Implementations may include abstract property members:</p> <pre><code>[&lt;AbstractClass&gt;]\ntype BaseClass() =\n    let mutable data1 = 0\n    let mutable data2 = 0\n    abstract AbstractProperty : int\n    abstract AbstractSettableProperty : int with get, set\n\n    abstract AbstractPropertyWithDefaultImplementation : int\n    default obj.AbstractPropertyWithDefaultImplementation = 3\n\n    abstract AbstractSettablePropertyWithDefaultImplementation : int with get, set\n    default obj.AbstractSettablePropertyWithDefaultImplementation\n        with get() = data2\n        and set v = data2 &lt;- v\n\ntype SubClass(x: int) =\n    inherit BaseClass()\n    let mutable data1b = 0\n    let mutable data2b = 0\n    override obj.AbstractProperty = 3 + x\n    override obj.AbstractSettableProperty\n        with get() = data1b + x\n        and set v = data1b &lt;- v - x\n    override obj.AbstractPropertyWithDefaultImplementation = 6 + x\n    override obj.AbstractSettablePropertyWithDefaultImplementation\n        with get() = data2b + x\n        and set v = data2b &lt;- v - x\n</code></pre> <p>The same rules apply to both property members and method members. In the preceding example, <code>BaseClass</code> includes abstract properties named <code>AbstractProperty</code>, <code>AbstractSettableProperty</code>, <code>AbstractPropertyWithDefaultImplementation</code>, and <code>AbstractSettablePropertyWithDefaultImplementation</code> and provides default implementations for the latter two. <code>SubClass</code> provides implementations for <code>AbstractProperty</code> and <code>AbstractSettableProperty</code>, and overrides the default implementations for <code>AbstractPropertyWithDefaultImplementation</code> and <code>AbstractSettablePropertyWithDefaultImplementation</code>.</p> <p>Implementation members may also implement CLI events (\u00a78.13.10). In this case, the member should be marked with the <code>CLIEvent</code> attribute. For example:</p> <pre><code>type ChannelChangedHandler = delegate of obj * int -&gt; unit\n\n[&lt;AbstractClass&gt;]\ntype BaseClass() =\n    [&lt;CLIEvent&gt;]\n    abstract ChannelChanged : IEvent&lt;ChannelChangedHandler, int&gt;\n\ntype SubClass() =\n    inherit BaseClass()\n    let mutable channel = 7\n    let channelChanged = new Event&lt;ChannelChangedHandler, int&gt;()\n\n    [&lt;CLIEvent&gt;]\n    override self.ChannelChanged = channelChanged.Publish\n    member self.Channel\n        with get () = channel\n        and set v = channel &lt;- v; channelChanged.Trigger(self, channel)\n</code></pre> <p><code>BaseClass</code> implements the CLI event <code>IEvent</code>, so the abstract member <code>ChannelChanged</code> is marked with <code>[&lt;CLIEvent&gt;]</code> as described earlier in \u00a78.13.10. SubClass provides an implementation of the abstract member, so the [] attribute must also precede the <code>override</code> declaration in <code>SubClass</code>."},{"location":"type-definitions/#8143-interface-implementations","title":"8.14.3 Interface Implementations","text":"<p>An interface implementation specifies how objects of a given type support a particular interface. An interface in a type definition indicates that objects of the defined type support the interface. For example:</p> <pre><code>type IIncrement =\n    abstract M : int -&gt; int\n\ntype IDecrement =\n    abstract M : int -&gt; int\n\ntype C() =\n    interface IIncrement with\n        member x.M(n) = n + 1\n    interface IDecrement with\n        member x.M(n) = n - 1\n</code></pre> <p>The first two definitions in the example are implementations of the interfaces <code>IIncrement</code> and <code>IDecrement</code>. In the last definition,the type <code>C</code> supports these two interfaces.</p> <p>No type may implement multiple different instantiations of a generic interface, either directly or through inheritance. For example, the following is not permitted:</p> <pre><code>// This type definition is not permitted because it implements two instantiations\n// of the same generic interface\ntype ClassThatTriesToImplemenTwoInstantiations() =\n    interface System.IComparable&lt;int&gt; with\n        member x.CompareTo(n : int) = 0\n    interface System.IComparable&lt;string&gt; with\n        member x.CompareTo(n : string) = 1\n</code></pre> <p>Each member of an interface implementation is checked as follows:</p> <ul> <li>The member must be an instance member definition.</li> <li>Dispatch Slot Inference (\u00a714.7) is applied.</li> <li>The member is checked under the assumption that the \u201cthis\u201d variable has the enclosing type.</li> </ul> <p>In the following example, the value <code>x</code> has type <code>C</code>.</p> <pre><code>type C() =\n    interface IIncrement with\n        member x.M(n) = n + 1\n    interface IDecrement with\n        member x.M(n) = n - 1\n</code></pre> <p>All interface implementations are made explicit. In its first implementation, every interface must be completely implemented, even in an abstract class. However, interface implementations may be inherited from a base class. In particular, if a class <code>C</code> implements interface <code>I</code>, and a base class of <code>C</code> implements interface <code>I</code>, then <code>C</code> is not required to implement all the methods of <code>I</code>; it can implement all, some, or none of the methods instead. For example:</p> <pre><code>type I1 =\n    abstract V1 : string\n    abstract V2 : string\n\ntype I2 =\n    inherit I1\n    abstract V3 : string\n\ntype C1() =\n    interface I1 with\n        member this.V1 = \"C1\"\n        member this.V2 = \"C2\"\n// This is OK\ntype C2() =\n    inherit C1()\n\n// This is also OK; C3 implements I2 but not I1.\ntype C3() =\n    inherit C1()\n    interface I2 with\n        member this.V3 = \"C3\"\n\n// This is also OK; C4 implements one method in I1.\ntype C4() =\n    inherit C1()\n    interface I1 with\n        member this.V2 = \"C2b\"\n</code></pre>"},{"location":"type-definitions/#815-equality-hashing-and-comparison","title":"8.15 Equality, Hashing, and Comparison","text":"<p>Functional programming in F# frequently involves the use of structural equality, structural hashing, and structural comparison. For example, the following expression evaluates to <code>true</code>, because tuple types support structural equality:</p> <pre><code>(1, 1 + 1) = (1, 2)\n</code></pre> <p>Likewise, these two function calls return identical values:</p> <pre><code>hash (1, 1 +1 )\nhash (1,2)\n</code></pre> <p>Similarly, an ordering on constituent parts of a tuple induces an ordering on tuples themselves, so all the following evaluate to <code>true</code>:</p> <pre><code>(1, 2) &lt; (1, 3)\n(1, 2) &lt; (2, 3)\n(1, 2) &lt; (2, 1)\n(1, 2) &gt; (1, 0)\n</code></pre> <p>The same applies to lists, options, arrays, and user-defined record, union, and struct types whose constituent field types permit structural equality, hashing, and comparison. For example, given:</p> <pre><code>type R = R of int * int\n</code></pre> <p>then all of the following also evaluate to <code>true</code>:</p> <pre><code>R (1, 1 + 1) = R (1, 2)\n\nR (1, 3) &lt;&gt; R (1, 2)\n\nhash (R (1, 1 + 1)) = hash (R (1, 2))\n\nR (1, 2) &lt; R (1, 3)\nR (1, 2) &lt; R (2, 3)\nR (1, 2) &lt; R (2, 1)\nR (1, 2) &gt; R (1, 0)\n</code></pre> <p>To facilitate this, by default, record, union, and struct type definitions\u2014called structural types \u2014 implicitly include compiler-generated declarations for structural equality, hashing, and comparison. These implicit declarations consist of the following for structural equality and hashing:</p> <pre><code>override x.GetHashCode() = ...\noverride x.Equals(y:obj) = ...\n    interface System.Collections.IStructuralEquatable with\n    member x.Equals(yobj: obj, comparer: System.Collections.IEqualityComparer) = ...\n    member x.GetHashCode(comparer: System.IEqualityComparer) = ...\n</code></pre> <p>The following declarations enable structural comparison:</p> <pre><code>interface System.IComparable with\n    member x.CompareTo(y:obj) = ...\ninterface System.Collections.IStructuralComparable with\n    member x.CompareTo(yobj: obj, comparer: System.Collections.IComparer) = ...\n</code></pre> <p>For exception types, implicit declarations for structural equality and hashings are generated, but declarations for structural comparison are not generated. Implicit declarations are never generated for interface, delegate, class, or enum types. Enum types implicitly derive support for equality, hashing, and comparison through their underlying representation as integers.</p>"},{"location":"type-definitions/#8151-equality-attributes","title":"8.15.1 Equality Attributes","text":"<p>Several attributes affect the equality behavior of types:</p> <pre><code>FSharp.Core.NoEquality\nFSharp.Core.ReferenceEquality\nFSharp.Core.StructuralEquality\nFSharp.Core.CustomEquality\n</code></pre> <p>The following table lists the effects of each attribute on a type:</p> Attrribute Effect <code>NoEquality</code> \u25aa No equality or hashing is generated for the type.\u25aa The type does not satisfy the <code>ty : equality</code> constraint. <code>ReferenceEquality</code> \u25aa No equality or hashing is generated for the type. \u25aa The defaults for <code>System.Object</code> will implicitly be used. <code>StructuralEquality</code> \u25aa The type must be a structural type.\u25aa All structural field types <code>ty</code> must satisfy <code>ty : equality</code>. <code>CustomEquality</code> \u25aa The type must have an explicit implementation of <code>override Equals(obj: obj)</code> None \u25aa For a non-structural type, the default is <code>ReferenceEquality</code>.\u25aa For a structural type:The default is <code>NoEquality</code> if any structural field type <code>F</code> fails <code>F : equality</code>.The default is <code>StructuralEquality</code> if all structural field types <code>F</code> satisfy <code>F : equality</code>. <p>Equality inference also determines the constraint dependencies of a generic structural type. That is:</p> <ul> <li>If a structural type has a generic parameter <code>'T</code> and <code>T : equality</code> is necessary to make the type     default to <code>StructuralEquality</code>, then the <code>EqualityConditionalOn</code> constraint dependency is     inferred for <code>'T</code>.</li> </ul>"},{"location":"type-definitions/#8152-comparison-attributes","title":"8.15.2 Comparison Attributes","text":"<p>The comparison behavior of types can be affected by the following attributes:</p> <pre><code>FSharp.Core.NoComparison\nFSharp.Core.StructuralComparison\nFSharp.Core.CustomComparison\n</code></pre> <p>The following table lists the effects of each attribute on a type.</p> Attribute Effect <code>NoComparison</code> \u25aa No comparisons are generated for the type.\u25aa The type does not satisfy the <code>ty : comparison</code> constraint. <code>StructuralComparison</code> \u25aa The type must be a structural type other than an exception type.\u25aa All structural field types <code>ty</code> must satisfy <code>ty : comparison</code>.\u25aa An exception type may not have the <code>StructuralComparison</code> attribute. <code>CustomComparison</code> \u25aa The type must have an explicit implementation of one or both of the following:<code>interface System.IComparable</code><code>interface System.Collections.IStructuralComparable</code>\u25aa A structural type that has an explicit implementation of one or both of these contracts must specify the <code>CustomComparison</code> attribute. None \u25aa For a non-structural or exception type, the default is <code>NoComparison</code>.\u25aa For any other structural type:The default is <code>NoComparison</code> if any structural field type <code>F</code> fails <code>F : comparison</code>.The default is <code>StructuralComparison</code> if all structural field types <code>F</code> satisfy <code>F : comparison</code>. <p>This check also determines the constraint dependencies of a generic structural type. That is:</p> <ul> <li>If a structural type has a generic parameter <code>'T</code> and <code>T</code> : comparison is necessary to make the type     default to <code>StructuralComparison</code>, then the <code>ComparisonConditionalOn</code> constraint dependency is     inferred for <code>'T</code>.</li> </ul> <p>For example:</p> <pre><code>[&lt;StructuralEquality; StructuralComparison&gt;]\ntype X = X of (int -&gt; int)\n</code></pre> <p>results in the following message:</p> <pre><code>The struct, record or union type 'X' has the 'StructuralEquality' attribute\nbut the component type '(int -&gt; int)' does not satisfy the 'equality' constraint\n</code></pre> <p>For example, given</p> <pre><code>type R1 =\n    { myData : int }\n    static member Create() = { myData = 0 }\n\n[&lt;ReferenceEquality&gt;]\ntype R2 =\n    { mutable myState : int }\n    static member Fresh() = { myState = 0 }\n\n[&lt;StructuralEquality; NoComparison &gt;]\ntype R3 =\n    { someType : System.Type }\n    static member Make() = { someType = typeof&lt;int&gt; }\n</code></pre> <p>then the following expressions all evaluate to <code>true</code>:</p> <pre><code>R1.Create() = R1.Create()\nnot (R2.Fresh() = R2.Fresh())\nR3.Make() = R3.Make()\n</code></pre> <p>Combinations of <code>equality</code> and <code>comparion</code> attributes are restricted. If any of the following attributes are present, they may be used only in the following combinations:</p> <ul> <li>No attributes</li> <li><code>[&lt;NoComparison&gt;]</code> on any type</li> <li><code>[&lt;NoEquality; NoComparison&gt;]</code> on any type</li> <li><code>[&lt;CustomEquality; NoComparison&gt;]</code> on a structural type</li> <li><code>[&lt;ReferenceEquality&gt;]</code> on a non-struct structural type</li> <li><code>[&lt;ReferenceEquality; NoComparison&gt;]</code> on a non-struct structural type</li> <li><code>[&lt;StructuralEquality; NoComparison&gt;]</code> on a structural type</li> <li><code>[&lt;CustomEquality; CustomComparison&gt;]</code> on a structural type</li> <li><code>[&lt;StructuralEquality; CustomComparison&gt;]</code> on a structural type</li> <li><code>[&lt;StructuralEquality; StructuralComparison&gt;]</code> on a structural type</li> </ul>"},{"location":"type-definitions/#8153-behavior-of-the-generated-objectequals-implementation","title":"8.15.3 Behavior of the Generated Object.Equals Implementation","text":"<p>For a type definition <code>T</code>, the behavior of the generated <code>override x.Equals(y:obj) = ...</code> implementation is as follows.</p> <ol> <li> <p>If the interface <code>System.IComparable</code> has an explicit implementation, then just call     <code>System.IComparable.CompareTo</code>:</p> <pre><code>override x.Equals(y : obj) =\n    ((x :&gt; System.IComparable).CompareTo(y) = 0)\n</code></pre> </li> <li> <p>Otherwise:</p> <ul> <li>Convert the <code>y</code> argument to type <code>T</code>. If the conversion fails, return <code>false</code>.</li> <li>Return <code>false</code> if <code>T</code> is a reference type and <code>y</code> is null.</li> <li>If <code>T</code> is a struct or record type, invoke <code>FSharp.Core.Operators.(=)</code> on each corresponding pair    of fields of <code>x</code> and <code>y</code> in declaration order. This method stops at the first <code>false</code> result and    returns <code>false</code>.</li> <li>If <code>T</code> is a union type, invoke <code>FSharp.Core.Operators.(=)</code> first on the index of the union cases    for the two values, then on each corresponding field pair of <code>x</code> and <code>y</code> for the data carried by    the union case. This method stops at the first <code>false</code> result and returns <code>false</code>.</li> <li>If <code>T</code> is an exception type, invoke <code>FSharp.Core.Operators.(=)</code> on the index of the tags for the    two values, then on each corresponding field pair for the data carried by the exception. This    method stops at the first <code>false</code> result and returns <code>false</code>.</li> </ul> </li> </ol>"},{"location":"type-definitions/#8154-behavior-of-the-generated-compareto-implementations","title":"8.15.4 Behavior of the Generated CompareTo Implementations","text":"<p>For a type <code>T</code>, the behavior of the generated <code>System.IComparable.CompareTo</code> implementation is as follows:</p> <ul> <li>Convert the <code>y</code> argument to type <code>T</code>. If the conversion fails, raise the <code>InvalidCastException</code>.</li> <li>If <code>T</code> is a reference type and <code>y</code> is <code>null</code>, return <code>1</code>.</li> <li>If <code>T</code> is a struct or record type, invoke <code>FSharp.Core.Operators.compare</code> on each corresponding pair     of fields of <code>x</code> and <code>y</code> in declaration order, and return the first non-zero result.</li> <li>If <code>T</code> is a union type, invoke <code>FSharp.Core.Operators.compare</code> first on the index of the union cases     for the two values, and then on each corresponding field pair of <code>x</code> and <code>y</code> for the data carried by     the union case. Return the first non-zero result.</li> </ul> <p>The first few lines of this code can be written:</p> <pre><code>interface System.IComparable with\n    member x.CompareTo(y:obj) =\n        let y = (obj :?&gt; T) in\n            match obj with\n            | null -&gt; 1\n            | _ -&gt; ...\n</code></pre>"},{"location":"type-definitions/#8155-behavior-of-the-generated-gethashcode-implementations","title":"8.15.5 Behavior of the Generated GetHashCode Implementations","text":"<p>For a type <code>T</code>, the generated <code>System.Object.GetHashCode()</code> override implements a combination hash of the structural elements of a structural type.</p>"},{"location":"type-definitions/#8156-behavior-of-hash-and-compare","title":"8.15.6 Behavior of Hash, =, and Compare","text":"<p>The generated equality, hashing, and comparison declarations that are described in sections \u00a78.15.3, \u00a78.15.4, and \u00a78.15.5 use the <code>hash</code>, <code>=</code> and <code>compare</code> functions from the F# library. The behavior of these library functions is defined by the pseudocode later in this section. This code ensures:</p> <ul> <li>Ordinal comparison for strings</li> <li>Structural comparison for arrays</li> <li>Natural ordering for native integers (which do not support <code>System.IComparable</code>)</li> </ul>"},{"location":"type-definitions/#81561-pseudocode-for-fsharpcoreoperatorscompare","title":"8.15.6.1 Pseudocode for FSharp.Core.Operators.compare","text":"<p>Note: In practice, fast (but semantically equivalent) code is emitted for direct calls to (=), compare, and hash for all base types, and faster paths are used for comparing most arrays.</p> <pre><code>open System\n\n/// Pseudo code for code implementation of generic comparison.\nlet rec compare x y =\n    let xobj = box x\n    let yobj = box y\n    match xobj, yobj with\n    | null, null -&gt; 0\n    | null, _ -&gt; - 1\n    | _, null -&gt; 1\n\n    // Use Ordinal comparison for strings\n    | (:? string as x),(:? string as y) -&gt;\n        String.CompareOrdinal(x, y)\n\n    // Special types not supporting IComparable\n    | (:? Array as arr1), (:? Array as arr2) -&gt;\n        ... compare the arrays by rank, lengths and elements ...\n    | (:? nativeint as x),(:? nativeint as y) -&gt;\n        ... compare the native integers x and y....\n    | (:? unativeint as x),(:? unativeint as y) -&gt;\n        ... compare the unsigned integers x and y....\n\n    // Check for IComparable\n    | (:? IComparable as x),_ -&gt; x.CompareTo(yobj)\n    | _,(:? IComparable as yc) -&gt; -(sign(yc.CompareTo(xobj)))\n\n    // Otherwise raise a runtime error\n    | _ -&gt; raise (new ArgumentException(...))\n</code></pre>"},{"location":"type-definitions/#81562-pseudo-code-for-fsharpcoreoperators","title":"8.15.6.2 Pseudo code for FSharp.Core.Operators.(=)","text":"<p>Note: In practice, fast (but semantically equivalent) code is emitted for direct calls to (=), compare, and hash for all base types, and faster paths are used for comparing most arrays</p> <pre><code>open System\n/// Pseudo code for core implementation of generic equality.\nlet rec (=) x y =\n    let xobj = box x\n    let yobj = box y\n    match xobj,yobj with\n    | null,null -&gt; true\n    | null,_ -&gt; false\n    | _,null -&gt; false\n\n    // Special types not supporting IComparable\n    | (:? Array as arr1), (:? Array as arr2) -&gt;\n        ... compare the arrays by rank, lengths and elements ...\n\n    // Ensure NaN semantics on recursive calls\n    | (:? float as f1), (:? float as f2) -&gt;\n        ... IEEE equality on f1 and f2...\n    | (:? float32 as f1), (:? float32 as f2) -&gt;\n        ... IEEE equality on f1 and f2...\n\n    // Otherwise use Object.Equals. This is reference equality\n    // for reference types unless an override is provided (implicitly\n    // or explicitly).\n    | _ -&gt; xobj.Equals(yobj)\n</code></pre>"},{"location":"types-and-type-constraints/","title":"5. Types and Type Constraints","text":"<p>The notion of type is central to both the static checking of F# programs and to dynamic type tests and reflection at runtime. The word is used with four distinct but related meanings:</p> <ul> <li>Type definitions, such as the actual CLI or F# definitions of <code>System.String</code> or   <code>FSharp.Collections.Map&lt;_,_&gt;</code>.</li> <li>Syntactic types, such as the text <code>option&lt;_&gt;</code> that might occur in a program text. Syntactic types   are converted to static types during the process of type checking and inference.</li> <li>Static types, which result from type checking and inference, either by the translation of syntactic   types that appear in the source text, or by the application of constraints that are related to   particular language constructs. For example, <code>option&lt;int&gt;</code> is the fully processed static type that is   inferred for an expression <code>Some(1+1)</code>. Static types may contain <code>type variables</code> as described later   in this section.</li> <li>Runtime types, which are objects of type <code>System.Type</code> and represent some or all of the   information that type definitions and static types convey at runtime. The <code>obj.GetType()</code> method,   which is available on all F# values, provides access to the runtime type of an object. An object\u2019s   runtime type is related to the static type of the identifiers and expressions that correspond to   the object. Runtime types may be tested by built-in language operators such as <code>:?</code> and <code>:?&gt;</code>, the   expression form downcast <code>expr</code>, and pattern matching type tests. Runtime types of objects do   not contain type variables. Runtime types that <code>System.Reflection</code> reports may contain type   variables that are represented by <code>System.Type</code> values.</li> </ul> <p>The following describes the syntactic forms of types as they appear in programs:</p> <pre><code>type :=\n    ( type )\n    type - &gt; type                  -- function type\n    type * ... * type              -- tuple type\n    struct (type * ... * type)     -- struct tuple type\n    typar                          -- variable type\n    long-ident                     -- named type, such as int\n    long-ident &lt;type-args&gt;         -- named type, such as list&lt;int&gt;\n    long-ident &lt; &gt;                 -- named type, such as IEnumerable&lt; &gt;\n    type long-ident                -- named type, such as int list\n    type [ , ... , ]               -- array type\n    type typar-defns               -- type with constraints\n    typar :&gt; type                  -- variable type with subtype constraint\n    # type                         -- anonymous type with subtype constraint\n\ntype-args := type-arg , ..., type-arg\n\ntype-arg :=\n    type                           -- type argument\n    measure                        -- unit of measure argument\n    static-parameter               -- static parameter\n\natomic-type :=\n    type : one of\n            #type typar ( type ) long-ident long-ident &lt;type-args&gt;\n\ntypar :=\n    _                              -- anonymous variable type\n    ' ident                        -- type variable\n    ^ ident                        -- static head-type type variable\n\nconstraint :=\n    typar :&gt; type                  -- coercion constraint\n    typar : null                   -- nullness constraint\n    static-typars : ( member-sig ) -- member \"trait\" constraint\n    typar : (new : unit -&gt; 'T)     -- CLI default constructor constraint\n    typar : struct                 -- CLI non-Nullable struct\n    typar : not struct             -- CLI reference type\n    typar : enum&lt; type &gt;           -- enum decomposition constraint\n    typar : unmanaged              -- unmanaged constraint\n    typar : delegate&lt;type, type&gt;   -- delegate decomposition constraint\n    typar : equality\n    typar : comparison\n\ntypar-defn := attributes opt typar\n\ntypar-defns := &lt; typar-defn, ..., typar-defn typar-constraints opt &gt;\n\ntypar-constraints := when constraint and ... and constraint\n\nstatic-typars :=\n    ^ ident\n    (^ ident or ... or ^ ident )\n\nmember-sig := &lt;see Section 10&gt;\n</code></pre> <p>In a type instantiation, the type name and the opening angle bracket must be syntactically adjacent with no intervening whitespace, as determined by lexical filtering (\u00a715.). Specifically:</p> <pre><code>array&lt;int&gt;\n</code></pre> <p>and not</p> <pre><code>array &lt; int &gt;\n</code></pre>"},{"location":"types-and-type-constraints/#51-checking-syntactic-types","title":"5.1 Checking Syntactic Types","text":"<p>Syntactic types are checked and converted to static types as they are encountered. Static types are a specification device used to describe</p> <ul> <li>The process of type checking and inference.</li> <li>The connection between syntactic types and the execution of F# programs.</li> </ul> <p>Every expression in an F# program is given a unique inferred static type, possibly involving one or more explicit or implicit generic parameters.</p> <p>For the remainder of this specification we use the same syntax to represent syntactic types and static types. For example <code>int32 * int32</code> is used to represent the syntactic type that appears in source code and the static type that is used during checking and type inference.</p> <p>The conversion from syntactic types to static types happens in the context of a name resolution environment (see \u00a714.1), a floating type variable environment, which is a mapping from names to type variables, and a type inference environment (see \u00a714.5).</p> <p>The phrase \u201cfresh type\u201d means a static type that is formed from a fresh type inference variable. Type inference variables are either solved or generalized by type inference (\u00a714.5). During conversion and throughout the checking of types, expressions, declarations, and entire files, a set of current inference constraints is maintained. That is, each static type is processed under input constraints <code>\u03a7</code> , and results in output constraints <code>\u03a7\u2019</code>. Type inference variables and constraints are progressively simplified and eliminated based on these equations through constraint solving (\u00a714.5).</p>"},{"location":"types-and-type-constraints/#511-named-types","title":"5.1.1 Named Types","text":"<p>Named types have several forms, as listed in the following table.</p> Form Description <code>long-ident &lt;ty1, ..., tyn&gt;</code> Named type with one or more suffixed type arguments. <code>long-ident</code> Named type with no type arguments <code>type long-ident</code> Named type with one type argument; processed the same as <code>long-ident&lt;type&gt;</code> <code>ty1 -&gt; ty2</code> A function type, where:  \u25aa ty1 is the domain of the function values associated with the type \u25aa ty2 is the range.In compiled code it is represented by the named type<code>FSharp.Core.FastFunc&lt;ty1, ty2&gt;</code>. <p>Named types are converted to static types as follows:</p> <ul> <li>Name Resolution for Types (see \u00a714.1) resolves <code>long-ident</code> to a type definition with formal generic   parameters <code>&lt;typar1, ..., typarn&gt;</code> and formal constraints <code>C</code>. The number of type arguments <code>n</code> is   used during the name resolution process to distinguish between similarly named types that take   different numbers of type arguments.</li> <li>Fresh type inference variables <code>&lt;ty'1, ..., ty'n&gt;</code> are generated for each formal type parameter. The   formal constraints <code>C</code> are added to the current inference constraints for the new type inference   variables; and constraints <code>tyi = ty'i</code> are added to the current inference constraints.</li> </ul>"},{"location":"types-and-type-constraints/#512-variable-types","title":"5.1.2 Variable Types","text":"<p>A type of the form <code>'ident</code> is a variable type. For example, the following are all variable types:</p> <pre><code>'a\n'T\n'Key\n</code></pre> <p>During checking, Name Resolution (see \u00a714.1) is applied to the identifier.</p> <ul> <li>If name resolution succeeds, the result is a variable type that refers to an existing declared type   parameter.</li> <li>If name resolution fails, the current floating type variable environment is consulted, although   only in the context of a syntactic type that is embedded in an expression or pattern. If the type   variable name is assigned a type in that environment, F# uses that mapping. Otherwise, a fresh</li> </ul> <p>type inference variable is created (see \u00a714.5) and added to both the type inference environment and the floating type variable environment.</p> <p>A type of the form <code>_</code> is an anonymous variable type. A fresh type inference variable is created and added to the type inference environment (see \u00a714.5) for such a type.</p> <p>A type of the form <code>^ident</code> is a statically resolved type variable. A fresh type inference variable is created and added to the type inference environment (see \u00a714.5). This type variable is tagged with an attribute that indicates that it can be generalized only at <code>inline</code> definitions (see \u00a714.6.7). The same restriction on generalization applies to any type variables that are contained in any type that is equated with the <code>^ident</code> type in a type inference equation.</p> <p>Note: This specification generally uses uppercase identifiers such as <code>'T</code> or <code>'Key</code> for user-declared generic type parameters,  and uses lowercase identifiers such as <code>'a</code> or <code>'b</code> for compiler-inferred generic parameters.</p>"},{"location":"types-and-type-constraints/#513-tuple-types","title":"5.1.3 Tuple Types","text":"<p>A tuple type has the following form:</p> <pre><code>ty 1 * ... * tyn\n</code></pre> <p>The elaborated form of a tuple type is shorthand for a use of the family of F# library types <code>System.Tuple&lt;_, ..., _&gt;</code>. (see \u00a76.3.2) for the details of this encoding.</p> <p>When considered as static types, tuple types are distinct from their encoded form. However, the encoded form of tuple types is visible in the F# type system through runtime types. For example, <code>typeof&lt;int * int&gt;</code> is equivalent to <code>typeof&lt;System.Tuple&lt;int,int&gt;&gt;</code>.</p>"},{"location":"types-and-type-constraints/#5131-struct-tuple-types","title":"5.1.3.1 Struct Tuple Types","text":"<p>A struct tuple type has the following form:</p> <pre><code>struct ( ty 1 * ... * tyn )\n</code></pre> <p>The elaborated form of a tuple type is shorthand for a use of the family of .NET types System.ValueTuple.</p> <p>When considered as static types, tuple types are distinct from their encoded form. However, the encoded form of tuple types is visible in the F# type system through runtime types. For example, <code>typeof&lt;int * int&gt;</code> is equivalent to <code>typeof&lt;System.ValueTuple&lt;int,int&gt;&gt;</code>.</p> <p>Struct tuple types are value types (as opposed to tuple types which are reference types). Struct tuple types are primarily aimed at use in interop and performance tuning.</p> <p>The \"structness\" (i.e. tuple type vs. struct tuple type) of tuple expressions and tuple patterns is inferred in the F# type inference process (unless they are explicitly tagged \"struct\"). However, code cannot be generic over structness, and there is no implicit conversion between struct tuples and reference tuples.</p>"},{"location":"types-and-type-constraints/#514-array-types","title":"5.1.4 Array Types","text":"<p>Array types have the following forms:</p> <pre><code>ty []\nty [ , ... , ]\n</code></pre> <p>A type of the form <code>ty []</code> is a single-dimensional array type, and a type of the form <code>ty[ , ... , ]</code> is a multidimensional array type. For example, <code>int[,,]</code> is an array of integers of rank 3.</p> <p>Except where specified otherwise in this document, these array types are treated as named types, as if they are an instantiation of a fictitious type definition <code>System.Arrayn&lt;ty&gt;</code> where <code>n</code> corresponds to the rank of the array type.</p> <p>Note: The type <code>int[][,]</code> in F# is the same as the type <code>int[,][]</code> in C# although the dimensions are swapped. This ensures consistency with other postfix type names in F# such as <code>int list list</code>.</p> <p>F# supports multidimensional array types only up to rank 4.</p>"},{"location":"types-and-type-constraints/#515-constrained-types","title":"5.1.5 Constrained Types","text":"<p>A type with constraints has the following form:</p> <pre><code>type when constraints\n</code></pre> <p>During checking, <code>type</code> is first checked and converted to a static type, then <code>constraints</code> are checked and added to the current inference constraints. The various forms of constraints are described in (see \u00a75.2)</p> <p>A type of the form <code>typar :&gt; type</code> is a type variable with a subtype constraint and is equivalent to <code>typar when typar :&gt; type</code>.</p> <p>A type of the form <code>#type</code> is an anonymous type with a subtype constraint and is equivalent to <code>'a when 'a :&gt; type</code> , where <code>'a</code> is a fresh type inference variable.</p>"},{"location":"types-and-type-constraints/#52-type-constraints","title":"5.2 Type Constraints","text":"<p>A type constraint limits the types that can be used to create an instance of a type parameter or type variable. F# supports the following type constraints:</p> <ul> <li>Subtype constraints</li> <li>Nullness constraints</li> <li>Member constraints</li> <li>Default constructor constraints</li> <li>Value type constraints</li> <li>Reference type constraints</li> <li>Enumeration constraints</li> <li>Delegate constraints</li> <li>Unmanaged constraints</li> <li>Equality and comparison constraints</li> </ul>"},{"location":"types-and-type-constraints/#521-subtype-constraints","title":"5.2.1 Subtype Constraints","text":"<p>An explicit subtype constraint has the following form:</p> <pre><code>typar :&gt; type\n</code></pre> <p>During checking, <code>typar</code> is first checked as a variable type, <code>type</code> is checked as a type, and the constraint is added to the current inference constraints. Subtype constraints affect type coercion as specified in (see \u00a75.4.7)</p> <p>Note that subtype constraints also result implicitly from:</p> <ul> <li>Expressions of the form <code>expr :&gt; type</code>.</li> <li>Patterns of the form <code>pattern :&gt; type</code>.</li> <li>The use of generic values, types, and members with constraints.</li> <li>The implicit use of subsumption when using values and members (see \u00a714.4.3).</li> </ul> <p>A type variable cannot be constrained by two distinct instantiations of the same named type. If two such constraints arise during constraint solving, the type instantiations are constrained to be equal. For example, during type inference, if a type variable is constrained by both <code>IA&lt;int&gt;</code> and <code>IA&lt;string&gt;</code>, an error occurs when the type instantiations are constrained to be equal. This limitation is specifically necessary to simplify type inference, reduce the size of types shown to users, and help ensure the reporting of useful error messages.</p>"},{"location":"types-and-type-constraints/#522-nullness-constraints","title":"5.2.2 Nullness Constraints","text":"<p>An explicit nullness constraint has the following form:</p> <pre><code>typar : null\n</code></pre> <p>During checking, <code>typar</code> is checked as a variable type and the constraint is added to the current inference constraints. The conditions that govern when a type satisfies a nullness constraint are specified in (see \u00a75.4.8)</p> <p>In addition:</p> <ul> <li>The <code>typar</code> must be a statically resolved type variable of the form <code>^ident</code>. This limitation ensures   that the constraint is resolved at compile time, and means that generic code may not use this   constraint unless that code is marked inline (see \u00a714.6.7).</li> </ul> <p>Note: Nullness constraints are primarily for use during type checking and are used relatively rarely in F# code.  Nullness constraints also arise from expressions of the form <code>null</code>.</p>"},{"location":"types-and-type-constraints/#523-member-constraints","title":"5.2.3 Member Constraints","text":"<p>An explicit member constraint has the following form:</p> <pre><code>( typar or ... or typar ) : ( member-sig )\n</code></pre> <p>For example, the F# library defines the + operator with the following signature:</p> <pre><code>val inline (+) : ^a -&gt; ^b -&gt; ^c\n    when (^a or ^b) : (static member (+) : ^a * ^b -&gt; ^c)\n</code></pre> <p>This definition indicates that each use of the <code>+</code> operator results in a constraint on the types that correspond to parameters <code>^a</code>, <code>^b</code>, and <code>^c</code>. If these are named types, then either the named type for <code>^a</code> or the named type for <code>^b</code> must support a static member called <code>+</code> that has the given signature.</p> <p>In addition:</p> <ul> <li>Each <code>typar</code> must be a statically resolved type variable (see \u00a75.1.2) in the form <code>^ident</code>. This ensures   that the constraint is resolved at compile time against a corresponding named type. It also   means that generic code cannot use this constraint unless that code is marked inline (see \u00a714.6.7).</li> <li>The <code>member-sig</code> cannot be generic; that is, it cannot include explicit type parameter definitions.</li> <li>The conditions that govern when a type satisfies a member constraint are specified in (see \u00a714.5.4).</li> </ul> <p>Note: Member constraints are primarily used to define overloaded functions in the F# library and are used relatively rarely in F# code. Uses of overloaded operators do not result in generalized code unless definitions are marked as inline. For example, the function <code>let f x = x + x</code> results in a function <code>f</code> that can be used only to add one type of value, such as <code>int</code> or <code>float</code>. The exact type is determined by later constraints.</p> <p>A type variable may not be involved in the support set of more than one member constraint that has the same name, staticness, argument arity, and support set (see \u00a714.5.4). If it is, the argument and return types in the two member constraints are themselves constrained to be equal. This limitation is specifically necessary to simplify type inference, reduce the size of types shown to users, and ensure the reporting of useful error messages.</p>"},{"location":"types-and-type-constraints/#524-default-constructor-constraints","title":"5.2.4 Default Constructor Constraints","text":"<p>An explicit default constructor constraint has the following form:</p> <pre><code>typar : (new : unit -&gt; 'T)\n</code></pre> <p>During constraint solving (see \u00a714.5), the constraint <code>type : (new : unit -&gt; 'T)</code> is met if <code>type</code> has a parameterless object constructor.</p> <p>Note: This constraint form exists primarily to provide the full set of constraints that CLI implementations allow. It is rarely used in F# programming.</p>"},{"location":"types-and-type-constraints/#525-value-type-constraints","title":"5.2.5 Value Type Constraints","text":"<p>An explicit value type constraint has the following form:</p> <pre><code>typar : struct\n</code></pre> <p>During constraint solving (see \u00a714.5), the constraint <code>type</code> : struct is met if <code>type</code> is a value type other than the CLI type <code>System.Nullable&lt;_&gt;</code>.</p> <p>Note: This constraint form exists primarily to provide the full set of constraints that CLI implementations allow. It is rarely used in F# programming. The restriction on <code>System.Nullable</code> is inherited from C# and other CLI languages, which give this type a special syntactic status. In F#, the type <code>option&lt;_&gt;</code> is similar to some uses of <code>System.Nullable&lt;_&gt;</code>. For various technical reasons the two types cannot be equated, notably because types such as <code>System.Nullable&lt;System.Nullable&lt;_&gt;&gt;</code> and <code>System.Nullable&lt;string&gt;</code> are not valid CLI types.</p>"},{"location":"types-and-type-constraints/#526-reference-type-constraints","title":"5.2.6 Reference Type Constraints","text":"<p>An explicit reference type constraint has the following form:</p> <pre><code>typar : not struct\n</code></pre> <p>During constraint solving (see \u00a714.5), the constraint <code>type : not struct</code> is met if <code>type</code> is a reference type.</p> <p>Note: This constraint form exists primarily to provide the full set of constraints that CLI implementations allow. It is rarely used in F# programming.</p>"},{"location":"types-and-type-constraints/#527-enumeration-constraints","title":"5.2.7 Enumeration Constraints","text":"<p>An explicit enumeration constraint has the following form:</p> <pre><code>typar : enum&lt;underlying-type&gt;\n</code></pre> <p>During constraint solving (see \u00a714.5), the constraint <code>type : enum&lt;underlying-type&gt;</code> is met if <code>type</code> is a CLI or F# enumeration type that has constant literal values of type <code>underlying-type</code>.</p> <p>Note: This constraint form exists primarily to allow the definition of library functions such as <code>enum</code>. It is rarely used directly in F# programming. The <code>enum</code> constraint does not imply anything about subtypes. For example, an <code>enum</code> constraint does not imply that the type is a subtype of <code>System.Enum</code>.</p>"},{"location":"types-and-type-constraints/#528-delegate-constraints","title":"5.2.8 Delegate Constraints","text":"<p>An explicit delegate constraint has the following form:</p> <pre><code>typar : delegate&lt; tupled-arg-type , return-type&gt;\n</code></pre> <p>During constraint solving (see \u00a714. .5), the constraint <code>type : delegate&lt;tupled-arg-type, return-types&gt;</code> is met if <code>type</code> is a delegate type <code>D</code> with declaration <code>type D = delegate of object * arg1 * ... * argN</code> and <code>tupled-arg-type = arg1 * ... * argN.</code> That is, the delegate must match the CLI design pattern where the sender object is the first argument to the event.</p> <p>Note: This constraint form exists primarily to allow the definition of certain F# library functions that are related to event programming. It is rarely used directly in F# programming. The <code>delegate</code> constraint does not imply anything about subtypes. In particular, a <code>delegate</code> constraint does not imply that the type is a subtype of <code>System.Delegate</code>. The <code>delegate</code> constraint applies only to delegate types that follow the usual form for CLI event handlers, where the first argument is a <code>sender</code> object. The reason is that the purpose of the constraint is to simplify the presentation of CLI event handlers to the F# programmer.</p>"},{"location":"types-and-type-constraints/#529-unmanaged-constraints","title":"5.2.9 Unmanaged Constraints","text":"<p>An unmanaged constraint has the following form:</p> <pre><code>typar : unmanaged\n</code></pre> <p>During constraint solving (see \u00a714.5), the constraint <code>type : unmanaged</code> is met if <code>type</code> is unmanaged as specified below:</p> <ul> <li>Types sbyte, <code>byte</code>, <code>char</code>, <code>nativeint</code>, <code>unativeint</code>, <code>float32</code>, <code>float</code>, <code>int16</code>, <code>uint16</code>, <code>int32</code>, <code>uint32</code>,   <code>int64</code>, <code>uint64</code>, <code>decimal</code> are unmanaged.</li> <li>Type <code>nativeptr&lt;type&gt;</code> is unmanaged.</li> <li>A non-generic struct type whose fields are all unmanaged types is unmanaged.</li> </ul>"},{"location":"types-and-type-constraints/#5210-equality-and-comparison-constraints","title":"5.2.10 Equality and Comparison Constraints","text":"<p>Equality constraints and comparison constraints have the following forms, respectively:</p> <pre><code>typar : equality\ntypar : comparison\n</code></pre> <p>During constraint solving (see \u00a714.5), the constraint <code>type : equality</code> is met if both of the following conditions are true:</p> <ul> <li>The type is a named type, and the type definition does not have, and is not inferred to have, the   <code>NoEquality</code> attribute.</li> <li>The type has <code>equality</code> dependencies <code>ty1,..., tyn</code>, each of which satisfies <code>tyi: equality</code>.</li> </ul> <p>The constraint <code>type : comparison</code> is a <code>comparison constraint</code>. Such a constraint is met if all the following conditions hold:</p> <ul> <li>If the type is a named type, then the type definition does not have, and is not inferred to have,   the <code>NoComparison</code> attribute, and the type definition implements <code>System.IComparable</code> or is an   array type or is <code>System.IntPtr</code> or is <code>System.UIntPtr</code>.</li> <li>If the type has <code>comparison dependencies</code> <code>ty1, ..., tyn</code> , then each of these must satisfy <code>tyi :   comparison</code></li> </ul> <p>An equality constraint is a relatively weak constraint, because with two exceptions, all CLI types satisfy this constraint. The exceptions are F# types that are annotated with the <code>NoEquality</code> attribute and structural types that are inferred to have the <code>NoEquality</code> attribute. The reason is that in other CLI languages, such as C#, it possible to use reference equality on all reference types.</p> <p>A comparison constraint is a stronger constraint, because it usually implies that a type must implement <code>System.IComparable</code>.</p>"},{"location":"types-and-type-constraints/#53-type-parameter-definitions","title":"5.3 Type Parameter Definitions","text":"<p>Type parameter definitions can occur in the following locations:</p> <ul> <li>Value definitions in modules</li> <li>Member definitions</li> <li>Type definitions</li> <li>Corresponding specifications in signatures</li> </ul> <p>For example, the following defines the type parameter \u2018T in a function definition:</p> <pre><code>let id&lt;'T&gt; (x:'T) = x\n</code></pre> <p>Likewise, in a type definition:</p> <pre><code>type Funcs&lt;'T1,'T2&gt; =\n    { Forward: 'T1 -&gt; 'T2\n      Backward : 'T2 -&gt; 'T2 }\n</code></pre> <p>Likewise, in a signature file:</p> <pre><code>val id&lt;'T&gt; : 'T -&gt; 'T\n</code></pre> <p>Explicit type parameter definitions can include <code>explicit constraint declarations</code>. For example:</p> <pre><code>let dispose2&lt;'T when 'T :&gt; System.IDisposable&gt; (x: 'T, y: 'T) =\nx.Dispose()\ny.Dispose()\n</code></pre> <p>The constraint in this example requires that <code>'T</code> be a type that supports the <code>IDisposable</code> interface.</p> <p>However, in most circumstances, declarations that imply subtype constraints on arguments can be written more concisely:</p> <pre><code>let throw (x: Exception) = raise x\n</code></pre> <p>Multiple explicit constraint declarations use and:</p> <pre><code>let multipleConstraints&lt;'T when 'T :&gt; System.IDisposable and\n                                'T :&gt; System.IComparable &gt; (x: 'T, y: 'T) =\n    if x.CompareTo(y) &lt; 0 then x.Dispose() else y.Dispose()\n</code></pre> <p>Explicit type parameter definitions can declare custom attributes on type parameter definitions (see \u00a713.1).</p>"},{"location":"types-and-type-constraints/#54-logical-properties-of-types","title":"5.4 Logical Properties of Types","text":"<p>During type checking and elaboration, syntactic types and constraints are processed into a reduced form composed of:</p> <ul> <li>Named types <code>op&lt;types&gt;</code>, where each <code>op</code> consists of a specific type definition, an operator to form   function types, an operator to form array types of a specific rank, or an operator to form specific   <code>n-tuple</code> types.</li> <li>Type variables <code>'ident</code>.</li> </ul>"},{"location":"types-and-type-constraints/#541-characteristics-of-type-definitions","title":"5.4.1 Characteristics of Type Definitions","text":"<p>Type definitions include CLI type definitions such as <code>System.String</code> and types that are defined in F# code (see \u00a78.). The following terms are used to describe type definitions:</p> <ul> <li>Type definitions may be generic , with one or more type parameters; for example,   <code>System.Collections.Generic.Dictionary&lt;'Key,'Value&gt;</code>.</li> <li>The generic parameters of type definitions may have associated <code>formal type constraints</code>.</li> <li>Type definitions may have custom attributes (see \u00a713.1), some of which are relevant to checking and   inference.</li> <li> <p>Type definitions may be type abbreviations (see \u00a78.3). These are eliminated for the purposes of   checking and inference (see \u00a75.4.2).</p> </li> <li> <p>Type definitions have a <code>kind</code> which is one of the following:</p> </li> <li><code>Class</code></li> <li><code>Interface</code></li> <li><code>Delegate</code></li> <li><code>Struct</code></li> <li><code>Record</code></li> <li><code>Union</code></li> <li><code>Enum</code></li> <li><code>Measure</code></li> <li><code>Abstract</code></li> </ul> <p>The kind is determined at the point of declaration by Type Kind Inference (see \u00a78.2) if it is not   specified explicitly as part of the type definition. The kind of a type refers to the kind of its   outermost named type definition, after expanding abbreviations. For example, a type is a class   type if it is a named type <code>C&lt;types&gt;</code> where <code>C</code> is of kind class. Thus,   <code>System.Collections.Generic.List&lt;int&gt;</code> is a class type.</p> <ul> <li>Type definitions may be sealed. Record, union, function, tuple, struct, delegate, enum, and array   types are all sealed, as are class types that are marked with the <code>SealedAttribute</code> attribute.</li> <li>Type definitions may have zero or one base type declarations. Each base type declaration   represents an additional type that is supported by any values that are formed using the type   definition. Furthermore, some aspects of the base type are used to form the implementation of   the type definition.</li> <li>Type definitions may have one or more interface declarations. These represent additional   encapsulated types that are supported by values that are formed using the type.</li> </ul> <p>Class, interface, delegate, function, tuple, record, and union types are all reference type definitions. A type is a reference type if its outermost named type definition is a reference type, after expanding type definitions.</p> <p>Struct types are value types.</p>"},{"location":"types-and-type-constraints/#542-expanding-abbreviations-and-inference-equations","title":"5.4.2 Expanding Abbreviations and Inference Equations","text":"<p>Two static types are considered equivalent and indistinguishable if they are equivalent after taking into account both of the following:</p> <ul> <li>The inference equations that are inferred from the current inference constraints (see \u00a714.5).</li> <li>The expansion of type abbreviations (see \u00a78.3).</li> </ul> <p>For example, static types may refer to type abbreviations such as <code>int</code>, which is an abbreviation for <code>System.Int32</code> and is declared by the F# library:</p> <pre><code>type int = System.Int32\n</code></pre> <p>This means that the types <code>int32</code> and <code>System.Int32</code> are considered equivalent, as are <code>System.Int32 -&gt; int</code> and <code>int -&gt; System.Int32</code>.</p> <p>Likewise, consider the process of checking this function:</p> <pre><code>let checkString (x:string) y =\n    (x = y), y.Contains(\"Hello\")\n</code></pre> <p>During checking, fresh type inference variables are created for values <code>x</code> and <code>y</code>; let\u2019s call them <code>ty1</code> and <code>ty2</code>. Checking imposes the constraints <code>ty1 = string</code> and <code>ty1 = ty2</code>. The second constraint results from the use of the generic <code>=</code> operator. As a result of constraint solving, <code>ty2 = string</code> is inferred, and thus the type of <code>y</code> is <code>string</code>.</p> <p>All relations on static types are considered after the elimination of all equational inference constraints and type abbreviations. For example, we say <code>int</code> is a struct type because <code>System.Int32</code> is a struct type.</p> <p>Note: Implementations of F# should attempt to preserve type abbreviations when reporting types and errors to users. This typically means that type abbreviations should be preserved in the logical structure of types throughout the checking process.</p>"},{"location":"types-and-type-constraints/#543-type-variables-and-definition-sites","title":"5.4.3 Type Variables and Definition Sites","text":"<p>Static types may be type variables. During type inference, static types may be partial, in that they contain type inference variables that have not been solved or generalized. Type variables may also refer to explicit type parameter definitions, in which case the type variable is said to be rigid and have a definition site.</p> <p>For example, in the following, the definition site of the type parameter 'T is the type definition of C:</p> <pre><code>type C&lt;'T&gt; = 'T * 'T\n</code></pre> <p>Type variables that do not have a binding site are inference variables. If an expression is composed of multiple sub-expressions, the resulting constraint set is normally the union of the constraints that result from checking all the sub-expressions. However, for some constructs (notably function, value and member definitions), the checking process applies generalization (see \u00a714.6.7). Consequently, some intermediate inference variables and constraints are factored out of the intermediate constraint sets and new implicit definition site(s) are assigned for these variables.</p> <p>For example, given the following declaration, the type inference variable that is associated with the value <code>x</code> is generalized and has an implicit definition site at the definition of function <code>id</code>:</p> <pre><code>let id x = x\n</code></pre> <p>Occasionally in this specification we use a more fully annotated representation of inferred and generalized type information. For example:</p> <pre><code>let id&lt;'a&gt; x'a = x'a\n</code></pre> <p>Here, <code>'a</code> represents a generic type parameter that is inferred by applying type inference and generalization to the original source code (see \u00a714.6.7), and the annotation represents the definition site of the type variable.</p>"},{"location":"types-and-type-constraints/#544-base-type-of-a-type","title":"5.4.4 Base Type of a Type","text":"<p>The base type for the static types is shown in the table. These types are defined in the CLI specifications and corresponding implementation documentation.</p> Static Type Base Type Abstract types <code>System.Object</code> All array types <code>System.Array</code> Class types The declared base type of the type definition if the type has one; otherwise, <code>System.Object</code>. For generic types <code>C&lt;type-inst&gt;</code>, substitute the formal generic parameters of <code>C</code> for <code>type-inst</code> Delegate types <code>System.MulticastDelegate</code> Enum types <code>System.Enum</code> Exception types <code>System.Exception</code> Interface types <code>System.Object</code> Record types <code>System.Object</code> Struct types <code>System.ValueType</code> Union types <code>System.Object</code> Variable types <code>System.Object</code>"},{"location":"types-and-type-constraints/#545-interfaces-types-of-a-type","title":"5.4.5 Interfaces Types of a Type","text":"<p>The interface types of a named type <code>C&lt;type-inst&gt;</code> are defined by the transitive closure of the interface declarations of <code>C</code> and the interface types of the base type of <code>C</code>, where formal generic parameters are substituted for the actual type instantiation <code>type-inst</code>.</p> <p>The interface types for single dimensional array types <code>ty[]</code> include the transitive closure that starts from the interface <code>System.Collections.Generic.IList&lt;ty&gt;</code>, which includes <code>System.Collections.Generic.ICollection&lt;ty&gt;</code> and <code>System.Collections.Generic.IEnumerable&lt;ty&gt;</code>.</p>"},{"location":"types-and-type-constraints/#546-type-equivalence","title":"5.4.6 Type Equivalence","text":"<p>Two static types <code>ty1</code> and <code>ty2</code> are definitely equivalent (with respect to a set of current inference constraints) if either of the following is true:</p> <ul> <li><code>ty1</code> has form <code>op&lt;ty11, ..., ty1n&gt;</code>, <code>ty2</code> has form <code>op&lt;ty21, ..., ty2n&gt;</code> and each <code>ty1i</code> is   definitely equivalent to <code>ty2i</code> for all <code>1</code> &lt;= <code>i</code> &lt;= <code>n</code>.</li> </ul> <p>OR</p> <ul> <li><code>ty1</code> and <code>ty2</code> are both variable types, and they both refer to the same definition site or are the   same type inference variable.</li> </ul> <p>This means that the addition of new constraints may make types definitely equivalent where previously they were not. For example, given <code>\u03a7 = { 'a = int }</code>, we have <code>list&lt;int&gt;</code> = <code>list&lt;'a&gt;</code>.</p> <p>Two static types <code>ty1</code> and <code>ty2</code> are feasibly equivalent if <code>ty1</code> and <code>ty2</code> may become definitely equivalent if further constraints are added to the current inference constraints. Thus <code>list&lt;int&gt;</code> and <code>list&lt;'a&gt;</code> are feasibly equivalent for the empty constraint set.</p>"},{"location":"types-and-type-constraints/#547-subtyping-and-coercion","title":"5.4.7 Subtyping and Coercion","text":"<p>A static type <code>ty2</code> coerces to static type <code>ty1</code> (with respect to a set of current inference constraints X), if <code>ty1</code> is in the transitive closure of the base types and interface types of <code>ty2</code>. Static coercion is written with the <code>:&gt;</code> symbol:</p> <pre><code>ty2 :&gt; ty1\n</code></pre> <p>Variable types <code>'T</code> coerce to all types <code>ty</code> if the current inference constraints include a constraint of the form <code>'T :&gt; ty2</code>, and <code>ty</code> is in the inclusive transitive closure of the base and interface types of <code>ty2</code>.</p> <p>A static type <code>ty2</code> feasibly coerces to static type <code>ty1</code> if <code>ty2</code> coerces to <code>ty1</code> may hold through the addition of further constraints to the current inference constraints. The result of adding constraints is defined in <code>Constraint Solving</code> (see \u00a714.5).</p>"},{"location":"types-and-type-constraints/#548-nullness","title":"5.4.8 Nullness","text":"<p>The design of F# aims to greatly reduce the use of null literals in common programming tasks, because they generally result in error-prone code. However:</p> <ul> <li>The use of some <code>null</code> literals is required for interoperation with CLI libraries.</li> <li>The appearance of <code>null</code> values during execution cannot be completely precluded for technical   reasons related to the CLI and CLI libraries.</li> </ul> <p>As a result, F# types differ in their treatment of the <code>null</code> literal and <code>null</code> values. All named types and type definitions fall into one of the following categories:</p> <ul> <li>Types with the <code>null</code> literal. These types have <code>null</code> as an \"extra\" value. The following types are in   this category:</li> <li>All CLI reference types that are defined in other CLI languages.</li> <li>All types that are defined in F# and annotated with the <code>AllowNullLiteral</code> attribute.</li> </ul> <p>For example, <code>System.String</code> and other CLI reference types satisfy this constraint, and these types   permit the direct use of the <code>null</code> literal.</p> <ul> <li>Types with <code>null</code> as an abnormal value. These types do not permit the <code>null</code> literal, but do have   <code>null</code> as an abnormal value. The following types are in this category:</li> <li>All F# list, record, tuple, function, class, and interface types.</li> <li>All F# union types except those that have <code>null</code> as a normal value, as discussed in the next       bullet point.</li> </ul> <p>For types in this category, the use of the <code>null</code> literal is not directly allowed. However, strictly   speaking, it is possible to generate a <code>null</code> value for these types by using certain functions such as   <code>Unchecked.defaultof&lt;type&gt;</code>. For these types, <code>null</code> is considered an abnormal value. Operations   differ in their use and treatment of <code>null</code> values; for details about evaluation of expressions that   might include <code>null</code> values, see (see \u00a76.9).</p> <ul> <li>Types with <code>null</code> as a representation value. These types do not permit the <code>null</code> literal but use   the <code>null</code> value as a representation.   For these types, the use of the null literal is not directly permitted. However, one or all of the   \u201cnormal\u201d values of the type is represented by the null value. The following types are in this   category:</li> <li>The unit type. The <code>null</code> value is used to represent all values of this type.</li> <li>Any union type that has the       <code>FSharp.Core.CompilationRepresentation(CompilationRepresentationFlags.UseNullAsTrueV       alue)</code> attribute flag and a single null union case. The null value represents this case. In       particular, <code>null</code> represents <code>None</code> in the F# <code>option&lt;_&gt;</code> type.</li> <li>Types without <code>null</code>. These types do not permit the <code>null</code> literal and do not have the null value.   All value types are in this category, including primitive integers, floating-point numbers, and any   value of a CLI or F# <code>struct</code> type.</li> </ul> <p>A static type <code>ty</code> satisfies a nullness constraint <code>ty : null</code> if it:</p> <ul> <li>Has an outermost named type that has the <code>null</code> literal.</li> <li>Is a variable type with a <code>typar : null</code> constraint.</li> </ul>"},{"location":"types-and-type-constraints/#549-default-initialization","title":"5.4.9 Default Initialization","text":"<p>Related to nullness is the default initialization of values of some types to zero values. This technique is common in some programming languages, but the design of F# deliberately de-emphasizes it. However, default initialization is allowed in some circumstances:</p> <ul> <li>Checked default initialization may be used when a type is known to have a valid and \u201csafe\u201d   default zero value. For example, the types of fields that are labeled with <code>DefaultValue(true)</code> are   checked to ensure that they allow default initialization.</li> <li>CLI libraries sometimes perform unchecked default initialization, as do the F# library primitives   <code>Unchecked.defaultof&lt;_&gt;</code> and <code>Array.zeroCreate</code>.</li> </ul> <p>The following types permit default initialization :</p> <ul> <li>Any type that satisfies the nullness constraint.</li> <li>Primitive value types.</li> <li>Struct types whose field types all permit default initialization.</li> </ul>"},{"location":"types-and-type-constraints/#5410-dynamic-conversion-between-types","title":"5.4.10 Dynamic Conversion Between Types","text":"<p>A runtime type <code>vty</code> dynamically converts to a static type <code>ty</code> if any of the following are true:</p> <ul> <li><code>vty</code> coerces to <code>ty</code>.</li> <li><code>vty</code> is <code>int32[]</code> and <code>ty</code> is <code>uint32[]</code>(or conversely). Likewise for <code>sbyte[]</code>/<code>byte[]</code>, <code>int16[]</code>/<code>uint16[]</code>,   <code>int64[]</code>/<code>uint64[]</code>, and <code>nativeint[]</code>/<code>unativeint[]</code>.</li> <li><code>vty</code> is <code>enum[]</code> where <code>enum</code> has underlying type <code>underlying</code> , and <code>ty</code> is <code>underlying[]</code> (or conversely),   or the (un)signed equivalent of <code>underlying[]</code> by the immediately preceding rule.</li> <li><code>vty</code> is <code>elemty1[]</code>, <code>ty</code> is <code>elemty2[]</code>, <code>elemty1</code> is a reference type, and <code>elemty1</code> converts to <code>elemty2</code>.</li> <li><code>ty</code> is <code>System.Nullable&lt;vty&gt;</code>.</li> </ul> <p>Note that this specification does not define the full algebra of the conversions of runtime types to static types because the information that is available in runtime types is implementation dependent. However, the specification does state the conditions under which objects are guaranteed to have a runtime type that is compatible with a particular static type.</p> <p>Note: This specification covers the additional rules of CLI dynamic conversions, all of which apply to F# types. For example:</p> <pre><code>let x = box [| System.DayOfWeek.Monday |]\nlet y = x :? int32[]\nprintf \"%b\" y // true\n</code></pre> <p>In the previous code, the type <code>System.DayOfWeek.Monday[]</code> does not statically coerce to <code>int32[]</code>, but the expression <code>x :? int32[]</code> evaluates to true.</p> <pre><code>let x = box [| 1 |]\nlet y = x :? uint32 []\nprintf \"%b\" y // true\n</code></pre> <p>In the previous code, the type <code>int32[]</code> does not statically coerce to <code>uint32[]</code>, but the expression <code>x :? uint32 []</code> evaluates to true.</p> <pre><code>let x = box [| \"\" |]\nlet y = x :? obj []\nprintf \"%b\" y // true\n</code></pre> <p>In the previous code, the type <code>string[]</code> does not statically coerce to <code>obj[]</code>, but the expression <code>x :? obj []</code> evaluates to true.</p> <pre><code>let x = box 1\nlet y = x :? System.Nullable&lt;int32&gt;\nprintf \"%b\" y // true\n</code></pre> <p>In the previous code, the type <code>int32</code> does not coerce to <code>System.Nullable&lt;int32&gt;</code>, but the expression <code>x :? System.Nullable&lt;int32&gt;</code> evaluates to true.</p>"},{"location":"units-of-measure/","title":"9. Units of Measure","text":"<p>F# supports static checking of units of measure. Units of measure, or measures for short, are like types in that they can appear as parameters to other types and values (as in <code>float&lt;kg&gt;</code>, <code>vector&lt;m/s&gt;</code>, <code>add&lt;m&gt;</code>), can be represented by variables (as in <code>float&lt;'U&gt;</code>), and are checked for consistency by the type-checker.</p> <p>However, measures differ from types in several important ways:</p> <ul> <li>Measures play no role at runtime; in fact, they are erased.</li> <li>Measures obey special rules of equivalence , so that <code>N m</code> can be interchanged with <code>m N</code>.</li> <li>Measures are supported by special syntax.</li> </ul> <p>The syntax of constants (\u00a74.3) is extended to support numeric constants with units of measure. The syntax of types is extended with measure type annotations.</p> <pre><code>measure-literal-atom :=\n    long-ident                                  -- named measure e.g. kg\n    ( measure-literal-simp )                    -- parenthesized measure, such as (N m)\n\nmeasure-literal-power :=\n    measure-literal-atom\n    measure-literal-atom ^ int32                -- power of measure, such as m^3\n\nmeasure-literal-seq :=\n    measure-literal-power\n    measure-literal-power measure-literal-seq\n\nmeasure-literal-simp :=\n    measure-literal-seq                         -- implicit product, such as m s^- 2\n    measure-literal-simp * measure-literal-simp -- product, such as m * s^3\n    measure-literal-simp / measure-literal-simp -- quotient, such as m/s^2\n    / measure-literal-simp                      -- reciprocal, such as /s\n    1                                           -- dimensionless\n\nmeasure-literal :=\n    _                                           -- anonymous measure\n    measure-literal-simp                        -- simple measure, such as N m\n\nconst :=\n    ...\n    byte &lt; measure-literal &gt;                    -- 8 - bit unsigned integer constant\n    uint16 &lt; measure-literal &gt;                  -- 16 - bit unsigned integer constant\n    uint32 &lt; measure-literal &gt;                  -- 32 - bit unsigned integer constant\n    uint64 &lt; measure-literal &gt;                  -- 64 - bit unsigned integer constant\n    sbyte &lt; measure-literal &gt;                   -- 8 - bit integer constant\n    int16 &lt; measure-literal &gt;                   -- 16 - bit integer constant\n    int32 &lt; measure-literal &gt;                   -- 32 - bit integer constant\n    int64 &lt; measure-literal &gt;                   -- 64 - bit integer constant\n    ieee32 &lt; measure-literal &gt;                  -- single-precision float32 constant\n    ieee64 &lt; measure-literal &gt;                  -- double-precision float constant\n    decimal &lt; measure-literal &gt;                 -- decimal constant\n\nmeasure-atom :=\n    typar                                       -- variable measure, such as 'U\n    long-ident                                  -- named measure, such as kg\n    ( measure-simp )                            -- parenthesized measure, such as (N m)\n\nmeasure-power :=\n    measure-atom\n    measure-atom ^ int32                        -- power of measure, such as m^3\n\nmeasure-seq :=\n    measure-power\n    measure-power measure-seq\n\nmeasure-simp :=\n    measure-seq                                 -- implicit product, such as 'U 'V^3\n    measure-simp * measure-simp                 -- product, such as 'U * 'V\n    measure-simp / measure-simp                 -- quotient, such as 'U / 'V\n    / measure-simp                              -- reciprocal, such as /'U\n    1                                           -- dimensionless measure (no units)\n\nmeasure :=\n    _                                           -- anonymous measure\nmeasure-simp                                    -- simple measure, such as 'U 'V\n</code></pre> <p>Measure definitions use the special <code>Measure</code> attribute on type definitions. Measure parameters, meanwhile, use a variation on the syntax of generic parameters (see \u00a79.5) to parameterize types and members by units of measure. The primitive types <code>byte</code>, <code>uint16</code>, <code>uint</code>, <code>uint64</code>, <code>sbyte</code>, <code>int16</code>, <code>int</code>, <code>int64</code>, <code>float</code>, <code>float32</code>, <code>decimal</code>, <code>unativeint</code>, and <code>nativeint</code> have non-parameterized (dimensionless) and parameterized versions.</p> <p>Here is a simple example:</p> <pre><code>[&lt;Measure&gt;] type m          // base measure: meters\n[&lt;Measure&gt;] type s          // base measure: seconds\n[&lt;Measure&gt;] type sqm = m^2  // derived measure: square meters\n\nlet areaOfTriangle (baseLength:float&lt;m&gt;, height:float&lt;m&gt;) : float&lt;sqm&gt; =\n    baseLength*height/2.0\n\nlet distanceTravelled (speed:float&lt;m/s&gt;, time:float&lt;s&gt;) : float&lt;m&gt; = speed*time\n</code></pre> <p>As with ordinary types, F# can infer that functions are generic in their units. For example, consider the following function definitions:</p> <pre><code>let sqr (x:float&lt;_&gt;) = x * x\n\nlet sumOfSquares x y = sqr x + sqr y\n</code></pre> <p>The inferred types are:</p> <pre><code>val sqr : float&lt;'u&gt; -&gt; float&lt;'u ^ 2&gt;\n\nval sumOfSquares : float&lt;'u&gt; -&gt; float&lt;'u&gt; -&gt; float&lt;'u ^ 2&gt;\n</code></pre> <p>Measures are type-like annotations such as <code>kg</code> or <code>m/s</code> or <code>m^2</code>. Their special syntax includes the use of <code>*</code> and <code>/</code> for product and quotient of measures, juxtaposition as shorthand for product, and <code>^</code> for integer powers.</p>"},{"location":"units-of-measure/#91-measures","title":"9.1 Measures","text":"<p>Measures are built from:</p> <ul> <li>Atomic measures from long identifiers such as <code>SI.kg</code> or <code>FreedomUnits.feet</code>.</li> <li>Product measures , which are written <code>measure measure</code> (juxtaposition) or <code>measure * measure</code>.</li> <li>Quotient measures , which are written <code>measure / measure</code>.</li> <li>Integer powers of measures , which are written <code>measure ^ int</code>.</li> <li>Dimensionless measures , which are written <code>1</code>.</li> <li>Variable measures, which are written <code>'u</code> or <code>'U</code>. Variable measures can include anonymous measures <code>_</code>, which indicates that the compiler can infer the measure from the context.</li> </ul> <p>Dimensionless measures indicate \u201cwithout units,\u201d but are rarely needed, because non-parameterized types such as <code>float</code> are aliases for the parameterized type with <code>1</code> as parameter, that is, <code>float = float&lt;1&gt;</code>.</p> <p>The precedence of operations involving measure is similar to that for floating-point expressions:</p> <ul> <li>Products and quotients (<code>*</code> and <code>/</code>) have the same precedence, and associate to the left, but juxtaposition has higher syntactic precedence than both <code>*</code> and <code>/</code>.</li> <li>Integer powers (<code>^</code>) have higher precedence than juxtaposition.</li> <li>The <code>/</code> symbol can also be used as a unary reciprocal operator.</li> </ul>"},{"location":"units-of-measure/#92-constants-annotated-by-measures","title":"9.2 Constants Annotated by Measures","text":"<p>A floating-point constant can be annotated with its measure by specifying a literal measure in angle brackets following the constant.</p> <p>Measure annotations on constants may not include measure variables.</p> <p>Here are some examples of annotated constants:</p> <pre><code>let earthGravity = 9.81f&lt;m/s^2&gt;\nlet atmosphere = 101325.0&lt;N m^-2&gt;\nlet zero = 0.0f&lt;_&gt;\n</code></pre> <p>Constants that are annotated with units of measure are assigned a corresponding numeric type with the measure parameter that is specified in the annotation. In the example above, <code>earthGravity</code> is assigned the type <code>float32&lt;m/s^2&gt;</code>, <code>atmosphere</code> is assigned the type <code>float&lt;N/m^2&gt;</code> and <code>zero</code> is assigned the type <code>float&lt;'U&gt;</code>.</p>"},{"location":"units-of-measure/#93-relations-of-measures","title":"9.3 Relations of Measures","text":"<p>After measures are parsed and checked, they are maintained in the following normalized form:</p> <pre><code>measure-int := 1 | long-ident | measure-par | measure-int measure-int | / measure-int\n</code></pre> <p>Powers of measures are expanded. For example, <code>kg^3</code> is equivalent to <code>kg</code> <code>kg</code> <code>kg</code>.</p> <p>Two measures are indistinguishable if they can be made equivalent by repeated application of the following rules:</p> <ul> <li>Commutativity. <code>measure-int1 measure-int2</code> is equivalent to <code>measure-int2 measure-int1</code>.</li> <li>Associativity. It does not matter what grouping is used for juxtaposition (product) of measures, so parentheses are not required. For example, <code>kg m s</code> can be split as the product of <code>kg m</code> and <code>s</code>, or as the product of <code>kg</code> and <code>m s</code>.</li> <li>Identity. 1 <code>measure-int</code> is equivalent to <code>measure-int</code>.</li> <li>Inverses. <code>measure-int / measure-int</code> is equivalent to <code>1</code>.</li> <li>Abbreviation. <code>long-ident</code> is equivalent to <code>measure</code> if a measure abbreviation of the form <code>[&lt;Measure&gt;] type long-ident = measure</code> is currently in scope.</li> </ul> <p>Note that these are the laws of Abelian groups together with expansion of abbreviations.</p> <p>For example, <code>kg m / s^2</code> is the same as <code>m kg / s^2</code>.</p> <p>For presentation purposes (for example, in error messages), measures are presented in the normalized form that appears at the beginning of this section, but with the following restrictions:</p> <ul> <li>Powers are positive and greater than 1. This splits the measure into positive powers and negative powers, separated by <code>/</code>.</li> <li>Atomic measures are ordered as follows: measure parameters first, ordered alphabetically, followed by measure identifiers, ordered alphabetically.</li> </ul> <p>For example, the measure expression <code>m^1 kg s^-1</code> would be normalized to <code>kg m / s</code>.</p> <p>This normalized form provides a convenient way to check the equality of measures: given two measure expressions <code>measure-int1</code> and <code>measure-int2</code> , reduce each to normalized form by using the rules of commutativity, associativity, identity, inverses, and abbreviation, and then compare the syntax.</p> <p>To check the equality of two measures, abbreviations are expanded to compare their normalized forms. However, abbreviations are not expanded for presentation. For example, consider the following definitions:</p> <pre><code>[&lt;Measure&gt;] type a\n[&lt;Measure&gt;] type b = a * a\nlet x = 1&lt;b&gt; / 1&lt;a&gt;\n</code></pre> <p>The inferred type is presented as <code>int&lt;b/a&gt;</code>, not <code>int&lt;a&gt;</code>. If a measure is equivalent to <code>1</code>, however, abbreviations are expanded to cancel each other and are presented without units:</p> <pre><code>let y = 1&lt;b&gt; / 1&lt;a a&gt; // val y : int = 1\n</code></pre>"},{"location":"units-of-measure/#931-constraint-solving","title":"9.3.1 Constraint Solving","text":"<p>The mechanism described in \u00a714.5 is extended to support equational constraints between measure expressions. Such expressions arise from equations between parameterized types \u2014 that is, when <code>type&lt;tyarg11 , ..., tyarg1n&gt; = type&lt;tyarg21, ..., tyarg2n&gt;</code> is reduced to a series of constraints <code>tyarg1i = tyarg2i</code>. For the arguments that are measures, rather than types, the rules listed in \u00a79.3 are applied to obtain primitive equations of the form <code>'U = measure-int</code> where <code>'U</code> is a measure variable and <code>measure-int</code> is a measure expression in internal form. The variable <code>'U</code> is then replaced by <code>measure-int</code> wherever else it occurs. For example, the equation <code>float&lt;m^2/s^2&gt; = float&lt;'U^2&gt;</code> would be reduced to the <code>constraint m^2/s^2 = 'U^2</code>, which would be further reduced to the primitive equation <code>'U = m/s</code>.</p> <p>If constraints cannot be solved, a type error occurs. For example, the following expression</p> <pre><code>fun (x : float&lt;m^2&gt;, y : float&lt;s&gt;) -&gt; x + y\n</code></pre> <p>would eventually result in the constraint <code>m^2 = s</code>, which cannot be solved, indicating a type error.</p>"},{"location":"units-of-measure/#932-generalization-of-measure-variables","title":"9.3.2 Generalization of Measure Variables","text":"<p>Analogous to the process of generalization of type variables described in \u00a714.6.7, a generalization procedure produces measure variables over which a value, function, or member can be generalized.</p>"},{"location":"units-of-measure/#94-measure-definitions","title":"9.4 Measure Definitions","text":"<p>Measure definitions define new named units of measure by using the same syntax as for type definitions, with the addition of the <code>Measure</code> attribute. For example:</p> <pre><code>[&lt;Measure&gt;] type kg\n[&lt;Measure&gt;] type m\n[&lt;Measure&gt;] type s\n[&lt;Measure&gt;] type N = kg / m s^2\n</code></pre> <p>A primitive measure abbreviation defines a fresh, named measure that is distinct from other measures. Measure abbreviations, like type abbreviations, define new names for existing measures. Also like type abbreviations, repeatedly eliminating measure abbreviations in favor of their equivalent measures must not result in infinite measure expressions. For example, the following is not a valid measure definition because it results in the infinite squaring of <code>X</code>:</p> <pre><code>[&lt;Measure&gt;] type X = X^2\n</code></pre> <p>Measure definitions and abbreviations may not have type or measure parameters.</p>"},{"location":"units-of-measure/#95-measure-parameter-definitions","title":"9.5 Measure Parameter Definitions","text":"<p>Measure parameter definitions can appear wherever ordinary type parameter definitions can (see \u00a75.2.9). If an explicit parameter definition is used, the parameter name is prefixed by the special <code>Measure</code> attribute. For example:</p> <pre><code>val sqr&lt;[&lt;Measure&gt;] 'U&gt; : float&lt;'U&gt; -&gt; float&lt;'U^2&gt;\n\ntype Vector&lt;[&lt;Measure&gt;] 'U&gt; =\n    { X: float&lt;'U&gt;;\n      Y: float&lt;'U&gt;;\n      Z: float&lt;'U&gt; }\n\ntype Sphere&lt;[&lt;Measure&gt;] 'U&gt; =\n    { Center:Vector&lt;'U&gt;;\n      Radius:float&lt;'U&gt; }\n\ntype Disc&lt;[&lt;Measure&gt;] 'U&gt; =\n    { Center:Vector&lt;'U&gt;;\n      Radius:float&lt;'U&gt;;\n      Norm:Vector&lt;1&gt; }\n\ntype SceneObject&lt;[&lt;Measure&gt;] 'U&gt; =\n    | Sphere of Sphere&lt;'U&gt;\n    | Disc of Disc&lt;'U&gt;\n</code></pre> <p>Internally, the type checker distinguishes between type parameters and measure parameters by assigning one of two sorts (Type or Measure) to each parameter. This technique is used to check the actual arguments to types and other parameterized definitions. The type checker rejects ill-formed types such as <code>float&lt;int&gt;</code> and <code>IEnumerable&lt;m/s&gt;</code>.</p>"},{"location":"units-of-measure/#96-measure-parameter-erasure","title":"9.6 Measure Parameter Erasure","text":"<p>In contrast to type parameters on generic types, measure parameters are not exposed in the metadata that the runtime interprets; instead, measures are erased. Erasure has several consequences:</p> <ul> <li>Casting is with respect to erased types.</li> <li>Method application resolution (see \u00a714.4) is with respect to erased types.</li> <li>Reflection is with respect to erased types.</li> </ul>"},{"location":"units-of-measure/#97-type-definitions-with-measures-in-the-f-core-library","title":"9.7 Type Definitions with Measures in the F# Core Library","text":"<p>The F# core library defines the following types:</p> <pre><code>type float&lt;[&lt;Measure&gt;] 'U&gt;\ntype float32&lt;[&lt;Measure&gt;] 'U&gt;\ntype decimal&lt;[&lt;Measure&gt;] 'U&gt;\ntype sbyte&lt;[&lt;Measure&gt;] 'U&gt;\ntype int16&lt;[&lt;Measure&gt;] 'U&gt;\ntype int&lt;[&lt;Measure&gt;] 'U&gt;\ntype int64&lt;[&lt;Measure&gt;] 'U&gt;\ntype nativeint&lt;[&lt;Measure&gt;] 'U&gt;\ntype uint&lt;[&lt;Measure&gt;] 'U&gt;\ntype byte&lt;[&lt;Measure&gt;] 'U&gt;\ntype uint16&lt;[&lt;Measure&gt;] 'U&gt;\ntype uint64&lt;[&lt;Measure&gt;] 'U&gt;\ntype unativeint&lt;[&lt;Measure&gt;] 'U&gt;\n</code></pre> <p>Note: These definitions are called measure-annotated base types and are marked with the <code>MeasureAnnotatedAbbreviation</code> attribute in the implementation of the library. The <code>MeasureAnnotatedAbbreviation</code> attribute is not for use in user code and in future revisions of the language may result in a warning or error.</p> <p>These type definitions have the following special properties:</p> <ul> <li>They extend <code>System.ValueType</code>.</li> <li>They explicitly implement <code>System.IFormattable</code>, <code>System.IComparable</code>, <code>System.IConvertible</code>, and corresponding generic interfaces, instantiated at the given type\u2014for example, <code>System.IComparable&lt;float&lt;'u&gt;&gt;</code> and <code>System.IEquatable&lt;float&lt;'u&gt;&gt;</code> (so that you can invoke, for example, <code>CompareTo</code> after an explicit upcast).</li> <li>As a result of erasure, their compiled form is the corresponding primitive type.</li> <li> <p>For the purposes of constraint solving and other logical operations on types, a type equivalence holds between the unparameterized primitive type and the corresponding measured type definition that is instantiated at <code>&lt;1&gt;</code>:</p> <pre><code>sbyte = sbyte&lt;1&gt;\nint16 = int16&lt;1&gt;\nint = int&lt;1&gt;\nint64 = int64&lt;1&gt;\nbyte = byte&lt;1&gt;\nuint16 = uint16&lt;1&gt;\nuint = uint&lt;1&gt;\nuint64 = uint64&lt;1&gt;\nfloat = float&lt;1&gt;\nfloat32 = float32&lt;1&gt;\ndecimal = decimal&lt;1&gt;\n</code></pre> </li> <li> <p>The measured type definitions <code>byte</code>,  <code>uint16</code>, <code>uint</code>, <code>uint64</code>, <code>sbyte</code>, <code>int16</code>, <code>int</code>, <code>int64</code>, <code>float</code>, <code>float32</code>, <code>decimal</code>, <code>unativeint</code>, and <code>nativeint</code> are assumed to have additional static members that have the measure types that are listed in the table. Note that <code>N</code> is any of these types, and <code>F</code> is either <code>float32</code> or <code>float</code>.</p> </li> </ul> Member Measure Type <code>Sqrt</code> <code>F&lt;'U^2&gt; -&gt; F&lt;'U&gt;</code> <code>Atan2</code> <code>F&lt;'U&gt; -&gt; F&lt;'U&gt; -&gt; F&lt;1&gt;</code> <code>op_Addition</code><code>op_Subtraction</code><code>op_Modulus</code> <code>N&lt;'U&gt; -&gt; N&lt;'U&gt; -&gt; N&lt;'U&gt;</code> <code>op_Multiply</code> <code>N&lt;'U&gt; -&gt; N&lt;'V&gt; -&gt; N&lt;'U 'V&gt;</code> <code>op_Division</code> <code>N&lt;'U&gt; -&gt; N&lt;'V&gt; -&gt; N&lt;'U/'V&gt;</code> <code>Abs</code><code>op_UnaryNegation</code><code>op_UnaryPlus</code> <code>N&lt;'U&gt; -&gt; N&lt;'U&gt;</code> <code>Sign</code> <code>N&lt;'U&gt; -&gt; int</code> <p>This mechanism is used to support units of measure in the following math functions of the F# library: <code>(+)</code>, <code>(-)</code>, <code>(*)</code>, <code>(/)</code>, <code>(%)</code>, <code>(~+)</code>, <code>(~-)</code>, <code>abs</code>, <code>sign</code>, <code>atan2</code> and <code>sqrt</code>.</p> <p>Additionally, the F# core library provides the following measure-annotated aliases, which are functionally equivalent to the previously-listed measure-annotated types, and which are included for the sake of completeness:</p> <pre><code>type double&lt;[&lt;Measure&gt;] 'U&gt; // aliases float&lt;'U&gt;\ntype single&lt;[&lt;Measure&gt;] 'U&gt; // aliases float32&lt;'U&gt;\ntype int8&lt;[&lt;Measure&gt;] 'U&gt;   // aliases sbyte&lt;'U&gt;\ntype int32&lt;[&lt;Measure&gt;] 'U&gt;  // aliases int&lt;'U&gt;\ntype uint8&lt;[&lt;Measure&gt;] 'U&gt;  // aliases byte&lt;'U&gt;\ntype uint32&lt;[&lt;Measure&gt;] 'U&gt; // aliases uint&lt;'U&gt;\n</code></pre>"},{"location":"units-of-measure/#98-restrictions","title":"9.8 Restrictions","text":"<p>Measures can be used in range expressions but a properly measured step is required. For example, these are not allowed:</p> <pre><code>[&lt;Measure&gt;] type s\n[1&lt;s&gt; .. 5&lt;s&gt;] // error: The type 'int&lt;s&gt;' does not match the type 'int'\n[1&lt;s&gt; .. 1 .. 5&lt;s&gt;] // error: The type 'int&lt;s&gt;' does not match the type 'int'\n</code></pre> <p>However, the following range expression is valid:</p> <pre><code>[1&lt;s&gt; .. 1&lt;s&gt; .. 5&lt;s&gt;] // int&lt;s&gt; list = [1; 2; 3; 4; 5]\n</code></pre>"}]}