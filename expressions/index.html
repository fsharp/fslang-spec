
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
        <link rel="canonical" href="https://fsharp.github.io/fslang-spec/expressions/">
      
      
        <link rel="prev" href="../types-and-type-constraints/">
      
      
        <link rel="next" href="../patterns/">
      
      
      <link rel="icon" href="../fsharp128.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.6.22">
    
    
      
        <title>6. Expressions - F# Language Specification</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.84d31ad4.min.css">
      
        
        <link rel="stylesheet" href="../assets/stylesheets/palette.06af60db.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    
    
      
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="indigo" data-md-color-accent="indigo">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#6-expressions" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="F# Language Specification" class="md-header__button md-logo" aria-label="F# Language Specification" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M0 12 11.39.61v5.695L5.695 12l5.695 5.695v5.695zm7.322 0 4.068-4.068v8.136zM24 12 12.203.61v5.695L17.898 12l-5.695 5.695v5.695z"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            F# Language Specification
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              6. Expressions
            
          </span>
        </div>
      </div>
    </div>
    
      
        <form class="md-header__option" data-md-component="palette">
  
    
    
    
    <input class="md-option" data-md-color-media="(prefers-color-scheme)" data-md-color-scheme="default" data-md-color-primary="indigo" data-md-color-accent="indigo"  aria-label="Switch to light mode"  type="radio" name="__palette" id="__palette_0">
    
      <label class="md-header__button md-icon" title="Switch to light mode" for="__palette_1" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="m14.3 16-.7-2h-3.2l-.7 2H7.8L11 7h2l3.2 9zM20 8.69V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12zm-9.15 3.96h2.3L12 9z"/></svg>
      </label>
    
  
    
    
    
    <input class="md-option" data-md-color-media="(prefers-color-scheme: light)" data-md-color-scheme="default" data-md-color-primary="indigo" data-md-color-accent="indigo"  aria-label="Switch to dark mode"  type="radio" name="__palette" id="__palette_1">
    
      <label class="md-header__button md-icon" title="Switch to dark mode" for="__palette_2" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a4 4 0 0 0-4 4 4 4 0 0 0 4 4 4 4 0 0 0 4-4 4 4 0 0 0-4-4m0 10a6 6 0 0 1-6-6 6 6 0 0 1 6-6 6 6 0 0 1 6 6 6 6 0 0 1-6 6m8-9.31V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12z"/></svg>
      </label>
    
  
    
    
    
    <input class="md-option" data-md-color-media="(prefers-color-scheme: dark)" data-md-color-scheme="slate" data-md-color-primary="indigo" data-md-color-accent="indigo"  aria-label="Switch to system preference"  type="radio" name="__palette" id="__palette_2">
    
      <label class="md-header__button md-icon" title="Switch to system preference" for="__palette_0" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 18c-.89 0-1.74-.2-2.5-.55C11.56 16.5 13 14.42 13 12s-1.44-4.5-3.5-5.45C10.26 6.2 11.11 6 12 6a6 6 0 0 1 6 6 6 6 0 0 1-6 6m8-9.31V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12z"/></svg>
      </label>
    
  
</form>
      
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      
      
        <label class="md-header__button md-icon" for="__search">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        </label>
        <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
      
    
    
      <div class="md-header__source">
        <a href="https://github.com/fsharp/fslang-spec" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 7.1.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2025 Fonticons, Inc.--><path d="M439.6 236.1 244 40.5c-5.4-5.5-12.8-8.5-20.4-8.5s-15 3-20.4 8.4L162.5 81l51.5 51.5c27.1-9.1 52.7 16.8 43.4 43.7l49.7 49.7c34.2-11.8 61.2 31 35.5 56.7-26.5 26.5-70.2-2.9-56-37.3L240.3 199v121.9c25.3 12.5 22.3 41.8 9.1 55-6.4 6.4-15.2 10.1-24.3 10.1s-17.8-3.6-24.3-10.1c-17.6-17.6-11.1-46.9 11.2-56v-123c-20.8-8.5-24.6-30.7-18.6-45L142.6 101 8.5 235.1C3 240.6 0 247.9 0 255.5s3 15 8.5 20.4l195.6 195.7c5.4 5.4 12.7 8.4 20.4 8.4s15-3 20.4-8.4l194.7-194.7c5.4-5.4 8.4-12.8 8.4-20.4s-3-15-8.4-20.4"/></svg>
  </div>
  <div class="md-source__repository">
    GitHub
  </div>
</a>
      </div>
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="F# Language Specification" class="md-nav__button md-logo" aria-label="F# Language Specification" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M0 12 11.39.61v5.695L5.695 12l5.695 5.695v5.695zm7.322 0 4.068-4.068v8.136zM24 12 12.203.61v5.695L17.898 12l-5.695 5.695v5.695z"/></svg>

    </a>
    F# Language Specification
  </label>
  
    <div class="md-nav__source">
      <a href="https://github.com/fsharp/fslang-spec" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 7.1.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2025 Fonticons, Inc.--><path d="M439.6 236.1 244 40.5c-5.4-5.5-12.8-8.5-20.4-8.5s-15 3-20.4 8.4L162.5 81l51.5 51.5c27.1-9.1 52.7 16.8 43.4 43.7l49.7 49.7c34.2-11.8 61.2 31 35.5 56.7-26.5 26.5-70.2-2.9-56-37.3L240.3 199v121.9c25.3 12.5 22.3 41.8 9.1 55-6.4 6.4-15.2 10.1-24.3 10.1s-17.8-3.6-24.3-10.1c-17.6-17.6-11.1-46.9 11.2-56v-123c-20.8-8.5-24.6-30.7-18.6-45L142.6 101 8.5 235.1C3 240.6 0 247.9 0 255.5s3 15 8.5 20.4l195.6 195.7c5.4 5.4 12.7 8.4 20.4 8.4s15-3 20.4-8.4l194.7-194.7c5.4-5.4 8.4-12.8 8.4-20.4s-3-15-8.4-20.4"/></svg>
  </div>
  <div class="md-source__repository">
    GitHub
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Front Matter
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../rfc-status/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    RFC status
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../introduction/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    1. Introduction
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../program-structure/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    2. Program Structure
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../lexical-analysis/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    3. Lexical Analysis
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../basic-grammar-elements/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    4. Basic Grammar Elements
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../types-and-type-constraints/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    5. Types and Type Constraints
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  
  <span class="md-ellipsis">
    6. Expressions
    
  </span>
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        
  
  
  <span class="md-ellipsis">
    6. Expressions
    
  </span>
  

      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#61-some-checking-and-inference-terminology" class="md-nav__link">
    <span class="md-ellipsis">
      6.1 Some Checking and Inference Terminology
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#62-elaboration-and-elaborated-expressions" class="md-nav__link">
    <span class="md-ellipsis">
      6.2 Elaboration and Elaborated Expressions
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#63-data-expressions" class="md-nav__link">
    <span class="md-ellipsis">
      6.3 Data Expressions
    </span>
  </a>
  
    <nav class="md-nav" aria-label="6.3 Data Expressions">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#631-simple-constant-expressions" class="md-nav__link">
    <span class="md-ellipsis">
      6.3.1 Simple Constant Expressions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#632-tuple-expressions" class="md-nav__link">
    <span class="md-ellipsis">
      6.3.2 Tuple Expressions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#633-list-expressions" class="md-nav__link">
    <span class="md-ellipsis">
      6.3.3 List Expressions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#634-array-expressions" class="md-nav__link">
    <span class="md-ellipsis">
      6.3.4 Array Expressions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#635-record-expressions" class="md-nav__link">
    <span class="md-ellipsis">
      6.3.5 Record Expressions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#636-copy-and-update-record-expressions" class="md-nav__link">
    <span class="md-ellipsis">
      6.3.6 Copy-and-update Record Expressions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#637-function-expressions" class="md-nav__link">
    <span class="md-ellipsis">
      6.3.7 Function Expressions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#638-object-expressions" class="md-nav__link">
    <span class="md-ellipsis">
      6.3.8 Object Expressions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#639-delayed-expressions" class="md-nav__link">
    <span class="md-ellipsis">
      6.3.9 Delayed Expressions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#6310-computation-expressions" class="md-nav__link">
    <span class="md-ellipsis">
      6.3.10 Computation Expressions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#6311-sequence-expressions" class="md-nav__link">
    <span class="md-ellipsis">
      6.3.11 Sequence Expressions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#6312-range-expressions" class="md-nav__link">
    <span class="md-ellipsis">
      6.3.12 Range Expressions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#6313-lists-via-sequence-expressions" class="md-nav__link">
    <span class="md-ellipsis">
      6.3.13 Lists via Sequence Expressions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#6314-arrays-sequence-expressions" class="md-nav__link">
    <span class="md-ellipsis">
      6.3.14 Arrays Sequence Expressions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#6315-null-expressions" class="md-nav__link">
    <span class="md-ellipsis">
      6.3.15 Null Expressions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#6316-printf-formats" class="md-nav__link">
    <span class="md-ellipsis">
      6.3.16 'printf' Formats
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#64-application-expressions" class="md-nav__link">
    <span class="md-ellipsis">
      6.4 Application Expressions
    </span>
  </a>
  
    <nav class="md-nav" aria-label="6.4 Application Expressions">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#641-basic-application-expressions" class="md-nav__link">
    <span class="md-ellipsis">
      6.4.1 Basic Application Expressions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#642-object-construction-expressions" class="md-nav__link">
    <span class="md-ellipsis">
      6.4.2 Object Construction Expressions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#643-operator-expressions" class="md-nav__link">
    <span class="md-ellipsis">
      6.4.3 Operator Expressions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#644-dynamic-operator-expressions" class="md-nav__link">
    <span class="md-ellipsis">
      6.4.4 Dynamic Operator Expressions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#645-the-addressof-operators" class="md-nav__link">
    <span class="md-ellipsis">
      6.4.5 The AddressOf Operators
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#646-lookup-expressions" class="md-nav__link">
    <span class="md-ellipsis">
      6.4.6 Lookup Expressions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#647-slice-expressions" class="md-nav__link">
    <span class="md-ellipsis">
      6.4.7 Slice Expressions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#648-member-constraint-invocation-expressions" class="md-nav__link">
    <span class="md-ellipsis">
      6.4.8 Member Constraint Invocation Expressions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#649-assignment-expressions" class="md-nav__link">
    <span class="md-ellipsis">
      6.4.9 Assignment Expressions
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#65-control-flow-expressions" class="md-nav__link">
    <span class="md-ellipsis">
      6.5 Control Flow Expressions
    </span>
  </a>
  
    <nav class="md-nav" aria-label="6.5 Control Flow Expressions">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#651-parenthesized-and-block-expressions" class="md-nav__link">
    <span class="md-ellipsis">
      6.5.1 Parenthesized and Block Expressions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#652-sequential-execution-expressions" class="md-nav__link">
    <span class="md-ellipsis">
      6.5.2 Sequential Execution Expressions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#653-conditional-expressions" class="md-nav__link">
    <span class="md-ellipsis">
      6.5.3 Conditional Expressions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#654-shortcut-operator-expressions" class="md-nav__link">
    <span class="md-ellipsis">
      6.5.4 Shortcut Operator Expressions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#655-pattern-matching-expressions-and-functions" class="md-nav__link">
    <span class="md-ellipsis">
      6.5.5 Pattern-Matching Expressions and Functions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#656-sequence-iteration-expressions" class="md-nav__link">
    <span class="md-ellipsis">
      6.5.6 Sequence Iteration Expressions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#657-simple-for-loop-expressions" class="md-nav__link">
    <span class="md-ellipsis">
      6.5.7 Simple for-Loop Expressions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#658-while-expressions" class="md-nav__link">
    <span class="md-ellipsis">
      6.5.8 While Expressions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#659-try-with-expressions" class="md-nav__link">
    <span class="md-ellipsis">
      6.5.9 Try-with Expressions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#6510-reraise-expressions" class="md-nav__link">
    <span class="md-ellipsis">
      6.5.10 Reraise Expressions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#6511-try-finally-expressions" class="md-nav__link">
    <span class="md-ellipsis">
      6.5.11 Try-finally Expressions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#6512-assertion-expressions" class="md-nav__link">
    <span class="md-ellipsis">
      6.5.12 Assertion Expressions
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#66-definition-expressions" class="md-nav__link">
    <span class="md-ellipsis">
      6.6 Definition Expressions
    </span>
  </a>
  
    <nav class="md-nav" aria-label="6.6 Definition Expressions">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#661-value-definition-expressions" class="md-nav__link">
    <span class="md-ellipsis">
      6.6.1 Value Definition Expressions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#662-function-definition-expressions" class="md-nav__link">
    <span class="md-ellipsis">
      6.6.2 Function Definition Expressions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#663-recursive-definition-expressions" class="md-nav__link">
    <span class="md-ellipsis">
      6.6.3 Recursive Definition Expressions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#664-deterministic-disposal-expressions" class="md-nav__link">
    <span class="md-ellipsis">
      6.6.4 Deterministic Disposal Expressions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#665-pinned-pointer-expressions" class="md-nav__link">
    <span class="md-ellipsis">
      6.6.5 Pinned Pointer Expressions
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#67-type-related-expressions" class="md-nav__link">
    <span class="md-ellipsis">
      6.7 Type-related Expressions
    </span>
  </a>
  
    <nav class="md-nav" aria-label="6.7 Type-related Expressions">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#671-type-annotated-expressions" class="md-nav__link">
    <span class="md-ellipsis">
      6.7.1 Type-Annotated Expressions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#672-static-coercion-expressions" class="md-nav__link">
    <span class="md-ellipsis">
      6.7.2 Static Coercion Expressions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#673-dynamic-type-test-expressions" class="md-nav__link">
    <span class="md-ellipsis">
      6.7.3 Dynamic Type-Test Expressions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#674-dynamic-coercion-expressions" class="md-nav__link">
    <span class="md-ellipsis">
      6.7.4 Dynamic Coercion Expressions
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#68-quoted-expressions" class="md-nav__link">
    <span class="md-ellipsis">
      6.8 Quoted Expressions
    </span>
  </a>
  
    <nav class="md-nav" aria-label="6.8 Quoted Expressions">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#681-strongly-typed-quoted-expressions" class="md-nav__link">
    <span class="md-ellipsis">
      6.8.1 Strongly Typed Quoted Expressions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#682-weakly-typed-quoted-expressions" class="md-nav__link">
    <span class="md-ellipsis">
      6.8.2 Weakly Typed Quoted Expressions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#683-expression-splices" class="md-nav__link">
    <span class="md-ellipsis">
      6.8.3 Expression Splices
    </span>
  </a>
  
    <nav class="md-nav" aria-label="6.8.3 Expression Splices">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#6831-strongly-typed-expression-splices" class="md-nav__link">
    <span class="md-ellipsis">
      6.8.3.1 Strongly Typed Expression Splices
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#69-evaluation-of-elaborated-forms" class="md-nav__link">
    <span class="md-ellipsis">
      6.9 Evaluation of Elaborated Forms
    </span>
  </a>
  
    <nav class="md-nav" aria-label="6.9 Evaluation of Elaborated Forms">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#691-values-and-execution-context" class="md-nav__link">
    <span class="md-ellipsis">
      6.9.1 Values and Execution Context
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#692-parallel-execution-and-memory-model" class="md-nav__link">
    <span class="md-ellipsis">
      6.9.2 Parallel Execution and Memory Model
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#693-zero-values" class="md-nav__link">
    <span class="md-ellipsis">
      6.9.3 Zero Values
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#694-taking-the-address-of-an-elaborated-expression" class="md-nav__link">
    <span class="md-ellipsis">
      6.9.4 Taking the Address of an Elaborated Expression
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#695-evaluating-value-references" class="md-nav__link">
    <span class="md-ellipsis">
      6.9.5 Evaluating Value References
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#696-evaluating-function-applications" class="md-nav__link">
    <span class="md-ellipsis">
      6.9.6 Evaluating Function Applications
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#697-evaluating-method-applications" class="md-nav__link">
    <span class="md-ellipsis">
      6.9.7 Evaluating Method Applications
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#698-evaluating-union-cases" class="md-nav__link">
    <span class="md-ellipsis">
      6.9.8 Evaluating Union Cases
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#699-evaluating-field-lookups" class="md-nav__link">
    <span class="md-ellipsis">
      6.9.9 Evaluating Field Lookups
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#6910-evaluating-array-expressions" class="md-nav__link">
    <span class="md-ellipsis">
      6.9.10 Evaluating Array Expressions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#6911-evaluating-record-expressions" class="md-nav__link">
    <span class="md-ellipsis">
      6.9.11 Evaluating Record Expressions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#6912-evaluating-function-expressions" class="md-nav__link">
    <span class="md-ellipsis">
      6.9.12 Evaluating Function Expressions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#6913-evaluating-object-expressions" class="md-nav__link">
    <span class="md-ellipsis">
      6.9.13 Evaluating Object Expressions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#6914-evaluating-definition-expressions" class="md-nav__link">
    <span class="md-ellipsis">
      6.9.14 Evaluating Definition Expressions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#6915-evaluating-integer-for-loops" class="md-nav__link">
    <span class="md-ellipsis">
      6.9.15 Evaluating Integer For Loops
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#6916-evaluating-while-loops" class="md-nav__link">
    <span class="md-ellipsis">
      6.9.16 Evaluating While Loops
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#6917-evaluating-static-coercion-expressions" class="md-nav__link">
    <span class="md-ellipsis">
      6.9.17 Evaluating Static Coercion Expressions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#6918-evaluating-dynamic-type-test-expressions" class="md-nav__link">
    <span class="md-ellipsis">
      6.9.18 Evaluating Dynamic Type-Test Expressions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#6919-evaluating-dynamic-coercion-expressions" class="md-nav__link">
    <span class="md-ellipsis">
      6.9.19 Evaluating Dynamic Coercion Expressions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#6920-evaluating-sequential-execution-expressions" class="md-nav__link">
    <span class="md-ellipsis">
      6.9.20 Evaluating Sequential Execution Expressions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#6921-evaluating-try-with-expressions" class="md-nav__link">
    <span class="md-ellipsis">
      6.9.21 Evaluating Try-with Expressions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#6922-evaluating-try-finally-expressions" class="md-nav__link">
    <span class="md-ellipsis">
      6.9.22 Evaluating Try-finally Expressions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#6923-evaluating-addressof-expressions" class="md-nav__link">
    <span class="md-ellipsis">
      6.9.23 Evaluating AddressOf Expressions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#6924-values-with-underspecified-object-identity-and-type-identity" class="md-nav__link">
    <span class="md-ellipsis">
      6.9.24 Values with Underspecified Object Identity and Type Identity
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../patterns/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    7. Patterns
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../type-definitions/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    8. Type Definitions
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../units-of-measure/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    9. Units of Measure
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../namespaces-and-modules/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    10. Namespaces and Modules
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../namespace-and-module-signatures/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    11. Namespace and Module Signatures
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../program-structure-and-execution/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    12. Program Structure and Execution
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../custom-attributes-and-reflection/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    13. Custom Attributes and Reflection
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../inference-procedures/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    14. Inference Procedures
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../lexical-filtering/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    15. Lexical Filtering
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../provided-types/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    16. Provided Types
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../special-attributes-and-types/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    17. Special Attributes and Types
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../the-f-library-fsharpcoredll/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    18. The F# Library FSharp.Core.dll
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../features-for-ml-compatibility/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    19. Features for ML Compatibility
    
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#61-some-checking-and-inference-terminology" class="md-nav__link">
    <span class="md-ellipsis">
      6.1 Some Checking and Inference Terminology
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#62-elaboration-and-elaborated-expressions" class="md-nav__link">
    <span class="md-ellipsis">
      6.2 Elaboration and Elaborated Expressions
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#63-data-expressions" class="md-nav__link">
    <span class="md-ellipsis">
      6.3 Data Expressions
    </span>
  </a>
  
    <nav class="md-nav" aria-label="6.3 Data Expressions">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#631-simple-constant-expressions" class="md-nav__link">
    <span class="md-ellipsis">
      6.3.1 Simple Constant Expressions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#632-tuple-expressions" class="md-nav__link">
    <span class="md-ellipsis">
      6.3.2 Tuple Expressions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#633-list-expressions" class="md-nav__link">
    <span class="md-ellipsis">
      6.3.3 List Expressions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#634-array-expressions" class="md-nav__link">
    <span class="md-ellipsis">
      6.3.4 Array Expressions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#635-record-expressions" class="md-nav__link">
    <span class="md-ellipsis">
      6.3.5 Record Expressions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#636-copy-and-update-record-expressions" class="md-nav__link">
    <span class="md-ellipsis">
      6.3.6 Copy-and-update Record Expressions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#637-function-expressions" class="md-nav__link">
    <span class="md-ellipsis">
      6.3.7 Function Expressions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#638-object-expressions" class="md-nav__link">
    <span class="md-ellipsis">
      6.3.8 Object Expressions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#639-delayed-expressions" class="md-nav__link">
    <span class="md-ellipsis">
      6.3.9 Delayed Expressions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#6310-computation-expressions" class="md-nav__link">
    <span class="md-ellipsis">
      6.3.10 Computation Expressions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#6311-sequence-expressions" class="md-nav__link">
    <span class="md-ellipsis">
      6.3.11 Sequence Expressions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#6312-range-expressions" class="md-nav__link">
    <span class="md-ellipsis">
      6.3.12 Range Expressions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#6313-lists-via-sequence-expressions" class="md-nav__link">
    <span class="md-ellipsis">
      6.3.13 Lists via Sequence Expressions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#6314-arrays-sequence-expressions" class="md-nav__link">
    <span class="md-ellipsis">
      6.3.14 Arrays Sequence Expressions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#6315-null-expressions" class="md-nav__link">
    <span class="md-ellipsis">
      6.3.15 Null Expressions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#6316-printf-formats" class="md-nav__link">
    <span class="md-ellipsis">
      6.3.16 'printf' Formats
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#64-application-expressions" class="md-nav__link">
    <span class="md-ellipsis">
      6.4 Application Expressions
    </span>
  </a>
  
    <nav class="md-nav" aria-label="6.4 Application Expressions">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#641-basic-application-expressions" class="md-nav__link">
    <span class="md-ellipsis">
      6.4.1 Basic Application Expressions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#642-object-construction-expressions" class="md-nav__link">
    <span class="md-ellipsis">
      6.4.2 Object Construction Expressions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#643-operator-expressions" class="md-nav__link">
    <span class="md-ellipsis">
      6.4.3 Operator Expressions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#644-dynamic-operator-expressions" class="md-nav__link">
    <span class="md-ellipsis">
      6.4.4 Dynamic Operator Expressions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#645-the-addressof-operators" class="md-nav__link">
    <span class="md-ellipsis">
      6.4.5 The AddressOf Operators
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#646-lookup-expressions" class="md-nav__link">
    <span class="md-ellipsis">
      6.4.6 Lookup Expressions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#647-slice-expressions" class="md-nav__link">
    <span class="md-ellipsis">
      6.4.7 Slice Expressions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#648-member-constraint-invocation-expressions" class="md-nav__link">
    <span class="md-ellipsis">
      6.4.8 Member Constraint Invocation Expressions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#649-assignment-expressions" class="md-nav__link">
    <span class="md-ellipsis">
      6.4.9 Assignment Expressions
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#65-control-flow-expressions" class="md-nav__link">
    <span class="md-ellipsis">
      6.5 Control Flow Expressions
    </span>
  </a>
  
    <nav class="md-nav" aria-label="6.5 Control Flow Expressions">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#651-parenthesized-and-block-expressions" class="md-nav__link">
    <span class="md-ellipsis">
      6.5.1 Parenthesized and Block Expressions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#652-sequential-execution-expressions" class="md-nav__link">
    <span class="md-ellipsis">
      6.5.2 Sequential Execution Expressions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#653-conditional-expressions" class="md-nav__link">
    <span class="md-ellipsis">
      6.5.3 Conditional Expressions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#654-shortcut-operator-expressions" class="md-nav__link">
    <span class="md-ellipsis">
      6.5.4 Shortcut Operator Expressions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#655-pattern-matching-expressions-and-functions" class="md-nav__link">
    <span class="md-ellipsis">
      6.5.5 Pattern-Matching Expressions and Functions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#656-sequence-iteration-expressions" class="md-nav__link">
    <span class="md-ellipsis">
      6.5.6 Sequence Iteration Expressions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#657-simple-for-loop-expressions" class="md-nav__link">
    <span class="md-ellipsis">
      6.5.7 Simple for-Loop Expressions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#658-while-expressions" class="md-nav__link">
    <span class="md-ellipsis">
      6.5.8 While Expressions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#659-try-with-expressions" class="md-nav__link">
    <span class="md-ellipsis">
      6.5.9 Try-with Expressions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#6510-reraise-expressions" class="md-nav__link">
    <span class="md-ellipsis">
      6.5.10 Reraise Expressions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#6511-try-finally-expressions" class="md-nav__link">
    <span class="md-ellipsis">
      6.5.11 Try-finally Expressions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#6512-assertion-expressions" class="md-nav__link">
    <span class="md-ellipsis">
      6.5.12 Assertion Expressions
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#66-definition-expressions" class="md-nav__link">
    <span class="md-ellipsis">
      6.6 Definition Expressions
    </span>
  </a>
  
    <nav class="md-nav" aria-label="6.6 Definition Expressions">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#661-value-definition-expressions" class="md-nav__link">
    <span class="md-ellipsis">
      6.6.1 Value Definition Expressions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#662-function-definition-expressions" class="md-nav__link">
    <span class="md-ellipsis">
      6.6.2 Function Definition Expressions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#663-recursive-definition-expressions" class="md-nav__link">
    <span class="md-ellipsis">
      6.6.3 Recursive Definition Expressions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#664-deterministic-disposal-expressions" class="md-nav__link">
    <span class="md-ellipsis">
      6.6.4 Deterministic Disposal Expressions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#665-pinned-pointer-expressions" class="md-nav__link">
    <span class="md-ellipsis">
      6.6.5 Pinned Pointer Expressions
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#67-type-related-expressions" class="md-nav__link">
    <span class="md-ellipsis">
      6.7 Type-related Expressions
    </span>
  </a>
  
    <nav class="md-nav" aria-label="6.7 Type-related Expressions">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#671-type-annotated-expressions" class="md-nav__link">
    <span class="md-ellipsis">
      6.7.1 Type-Annotated Expressions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#672-static-coercion-expressions" class="md-nav__link">
    <span class="md-ellipsis">
      6.7.2 Static Coercion Expressions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#673-dynamic-type-test-expressions" class="md-nav__link">
    <span class="md-ellipsis">
      6.7.3 Dynamic Type-Test Expressions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#674-dynamic-coercion-expressions" class="md-nav__link">
    <span class="md-ellipsis">
      6.7.4 Dynamic Coercion Expressions
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#68-quoted-expressions" class="md-nav__link">
    <span class="md-ellipsis">
      6.8 Quoted Expressions
    </span>
  </a>
  
    <nav class="md-nav" aria-label="6.8 Quoted Expressions">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#681-strongly-typed-quoted-expressions" class="md-nav__link">
    <span class="md-ellipsis">
      6.8.1 Strongly Typed Quoted Expressions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#682-weakly-typed-quoted-expressions" class="md-nav__link">
    <span class="md-ellipsis">
      6.8.2 Weakly Typed Quoted Expressions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#683-expression-splices" class="md-nav__link">
    <span class="md-ellipsis">
      6.8.3 Expression Splices
    </span>
  </a>
  
    <nav class="md-nav" aria-label="6.8.3 Expression Splices">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#6831-strongly-typed-expression-splices" class="md-nav__link">
    <span class="md-ellipsis">
      6.8.3.1 Strongly Typed Expression Splices
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#69-evaluation-of-elaborated-forms" class="md-nav__link">
    <span class="md-ellipsis">
      6.9 Evaluation of Elaborated Forms
    </span>
  </a>
  
    <nav class="md-nav" aria-label="6.9 Evaluation of Elaborated Forms">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#691-values-and-execution-context" class="md-nav__link">
    <span class="md-ellipsis">
      6.9.1 Values and Execution Context
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#692-parallel-execution-and-memory-model" class="md-nav__link">
    <span class="md-ellipsis">
      6.9.2 Parallel Execution and Memory Model
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#693-zero-values" class="md-nav__link">
    <span class="md-ellipsis">
      6.9.3 Zero Values
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#694-taking-the-address-of-an-elaborated-expression" class="md-nav__link">
    <span class="md-ellipsis">
      6.9.4 Taking the Address of an Elaborated Expression
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#695-evaluating-value-references" class="md-nav__link">
    <span class="md-ellipsis">
      6.9.5 Evaluating Value References
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#696-evaluating-function-applications" class="md-nav__link">
    <span class="md-ellipsis">
      6.9.6 Evaluating Function Applications
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#697-evaluating-method-applications" class="md-nav__link">
    <span class="md-ellipsis">
      6.9.7 Evaluating Method Applications
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#698-evaluating-union-cases" class="md-nav__link">
    <span class="md-ellipsis">
      6.9.8 Evaluating Union Cases
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#699-evaluating-field-lookups" class="md-nav__link">
    <span class="md-ellipsis">
      6.9.9 Evaluating Field Lookups
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#6910-evaluating-array-expressions" class="md-nav__link">
    <span class="md-ellipsis">
      6.9.10 Evaluating Array Expressions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#6911-evaluating-record-expressions" class="md-nav__link">
    <span class="md-ellipsis">
      6.9.11 Evaluating Record Expressions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#6912-evaluating-function-expressions" class="md-nav__link">
    <span class="md-ellipsis">
      6.9.12 Evaluating Function Expressions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#6913-evaluating-object-expressions" class="md-nav__link">
    <span class="md-ellipsis">
      6.9.13 Evaluating Object Expressions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#6914-evaluating-definition-expressions" class="md-nav__link">
    <span class="md-ellipsis">
      6.9.14 Evaluating Definition Expressions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#6915-evaluating-integer-for-loops" class="md-nav__link">
    <span class="md-ellipsis">
      6.9.15 Evaluating Integer For Loops
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#6916-evaluating-while-loops" class="md-nav__link">
    <span class="md-ellipsis">
      6.9.16 Evaluating While Loops
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#6917-evaluating-static-coercion-expressions" class="md-nav__link">
    <span class="md-ellipsis">
      6.9.17 Evaluating Static Coercion Expressions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#6918-evaluating-dynamic-type-test-expressions" class="md-nav__link">
    <span class="md-ellipsis">
      6.9.18 Evaluating Dynamic Type-Test Expressions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#6919-evaluating-dynamic-coercion-expressions" class="md-nav__link">
    <span class="md-ellipsis">
      6.9.19 Evaluating Dynamic Coercion Expressions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#6920-evaluating-sequential-execution-expressions" class="md-nav__link">
    <span class="md-ellipsis">
      6.9.20 Evaluating Sequential Execution Expressions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#6921-evaluating-try-with-expressions" class="md-nav__link">
    <span class="md-ellipsis">
      6.9.21 Evaluating Try-with Expressions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#6922-evaluating-try-finally-expressions" class="md-nav__link">
    <span class="md-ellipsis">
      6.9.22 Evaluating Try-finally Expressions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#6923-evaluating-addressof-expressions" class="md-nav__link">
    <span class="md-ellipsis">
      6.9.23 Evaluating AddressOf Expressions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#6924-values-with-underspecified-object-identity-and-type-identity" class="md-nav__link">
    <span class="md-ellipsis">
      6.9.24 Values with Underspecified Object Identity and Type Identity
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


  
  


<h1 id="6-expressions">6. Expressions</h1>
<p>The expression forms and related elements are as follows:</p>
<div class="highlight"><pre><span></span><code>expr :=
    const                               -- a constant value
    ( expr )                            -- block expression
    begin expr end                      -- block expression
    long-ident-or-op                    -- lookup expression
    expr &#39;.&#39; long-ident-or-op           -- dot lookup expression
    expr expr                           -- application expression
    expr ( expr )                       -- high precedence application
    expr &lt; types &gt;                      -- type application expression
    expr infix-op expr                  -- infix application expression
    prefix-op expr                      -- prefix application expression
    expr .[ expr ]                      -- indexed lookup expression
    expr .[ slice-ranges ]              -- slice expression
    expr &lt;- expr                        -- assignment expression
    expr , ... , expr                   -- tuple expression
    struct (expr , ... , expr)          -- struct tuple expression
    new type expr                       -- simple object expression
    { new base-call object-members interface-impls } -- object expression
    { field-initializers }              -- record expression
    { expr with field-initializers }    -- record cloning expression
    [ expr ; ... ; expr ]               -- list expression
    [| expr ; ... ; expr |]             -- array expression
    expr { comp-or-range-expr }         -- computation expression
    [ comp-or-range-expr ]              -- computed list expression
    [| comp-or-range-expr |]            -- computed array expression
    lazy expr                           -- delayed expression
    null                                -- the &quot;null&quot; value for a reference type
    expr : type                         -- type annotation
    expr :&gt; type                        -- static upcast coercion
    expr :? type                        -- dynamic type test
    expr :?&gt; type                       -- dynamic downcast coercion
    upcast expr                         -- static upcast expression
    downcast expr                       -- dynamic downcast expression
    let function-defn in expr           -- function definition expression
    let value-defn in expr              -- value definition expression
    let rec function-or-value-defns in expr -- recursive definition expression
    use ident = expr in expr            -- deterministic disposal expression
    use ident = fixed expr              -- pinned pointer expression
    fun argument-pats - &gt; expr          -- function expression
    function rules                      -- matching function expression
    expr ; expr                         -- sequential execution expression
    match expr with rules               -- match expression
    try expr with rules                 -- try/with expression
    try expr finally expr               -- try/finally expression
    if expr then expr elif-branches? else-branch? -- conditional expression
    while expr do expr done             -- while loop
    for ident = expr to expr do expr done -- simple for loop
    for pat in expr - or-range-expr do expr done -- enumerable for loop
    assert expr                         -- assert expression
    &lt;@ expr @&gt;                          -- quoted expression
    &lt;@@ expr @@&gt;                        -- quoted expression

    %expr                              -- expression splice
    %%expr                              -- weakly typed expression splice

    (static-typars : (member-sig) expr) -– static member invocation
</code></pre></div>
<p>Expressions are defined in terms of patterns and other entities that are discussed later in this
specification. The following constructs are also used:</p>
<div class="highlight"><pre><span></span><code>exprs := expr &#39;,&#39; ... &#39;,&#39; expr

expr-or-range-expr :=
    expr
    range-expr

elif-branches := elif-branch ... elif-branch

elif-branch := elif expr then expr

else-branch := else expr

function-or-value-defn :=
    function-defn
    value-defn

function-defn :=
    inline? access? ident-or-op typar-defns? argument-pats return-type? = expr

value-defn :=
    mutable? access? pat typar-defns? return-type? = expr

return-type :=
    : type

function-or-value-defns :=
    function-or-value-defn and ... and function-or-value-defn

argument-pats := atomic-pat ... atomic-pat

field-initializer :=
    long-ident = expr -- field initialization

field-initializers := field-initializer ; ... ; field-initializer

object-construction :=
    type expr -- construction expression
    type      -- interface construction expression

base-call :=
    object-construction          -- anonymous base construction
    object-construction as ident -- named base construction

interface-impls := interface-impl ... interface-impl

interface-impl :=
    interface type object-members? -- interface implementation

object-members := with member-defns end

member-defns := member-defn ... member-defn
</code></pre></div>
<p>Computation and range expressions are defined in terms of the following productions:</p>
<div class="highlight"><pre><span></span><code>comp-or-range-expr :=
    comp-expr
    short-comp-expr
    range-expr

comp-expr :=
    let! pat = expr in comp-expr    -- binding computation
    let pat = expr in comp-expr
    do! expr in comp-expr           -- sequential computation
    do expr in comp-expr
    use! pat = expr in comp-expr    -- auto cleanup computation
    use pat = expr in comp-expr
    yield! expr                     -- yield computation
    yield expr                      -- yield result
    return! expr                    -- return computation
    return expr                     -- return result
    if expr then comp - expr        -- control flow or imperative action
    if expr then expr else comp-expr
    match! expr with pat -&gt; comp-expr | ... | pat -&gt; comp-expr
    match expr with pat -&gt; comp-expr | ... | pat -&gt; comp-expr
    try comp - expr with pat -&gt; comp-expr | ... | pat -&gt; comp-expr
    try comp - expr finally expr
    while expr do comp - expr done
    for ident = expr to expr do comp - expr done
    for pat in expr - or-range-expr do comp - expr done
    comp - expr ; comp - expr
    expr

short-comp-expr :=
    for pat in expr-or-range-expr -&gt; expr -- yield result

range-expr :=
    expr .. expr                    -- range sequence
    expr .. expr .. expr            -- range sequence with skip

slice-ranges := slice-range , ... , slice-range

slice-range :=
    expr                            -- slice of one element of dimension
    expr ..                         -- slice from index to end
    .. expr                         -- slice from start to index
    expr .. expr                    -- slice from index to index
    &#39;*&#39;                             -- slice from start to end
</code></pre></div>
<h2 id="61-some-checking-and-inference-terminology">6.1 Some Checking and Inference Terminology</h2>
<p>The rules applied to check individual expressions are described in the following subsections. Where
necessary, these sections reference specific inference procedures such as <em>Name Resolution</em> (<a href="../inference-procedures/#141-name-resolution">§14.1</a>)
and <em>Constraint Solving</em> (<a href="../inference-procedures/#145-constraint-solving">§14.5</a>).</p>
<p>All expressions are assigned a static type through type checking and inference. During type checking,
each expression is checked with respect to an <em>initial type</em>. The initial type establishes some of the
information available to resolve method overloading and other language constructs. We also use the
following terminology:</p>
<ul>
<li>
<p>The phrase “the type <code>ty1</code> is asserted to be equal to the type <code>ty2</code>” or simply “<code>ty1 = ty2</code> is asserted”
    indicates that the constraint “<code>ty1 = ty2</code>” is added to the current inference constraints.</p>
</li>
<li>
<p>The phrase “<code>ty1</code> is asserted to be a subtype of <code>ty2</code>” or simply “<code>ty1 :&gt; ty2</code> is asserted” indicates
    that the constraint <code>ty1 :&gt; ty2</code> is added to the current inference constraints.</p>
</li>
<li>The phrase “type <code>ty</code> is known to ...” indicates that the initial type satisfies the given property
    given the current inference constraints.</li>
<li>The phrase “the expression <code>expr</code> has type <code>ty</code> ” means the initial type of the expression is asserted
    to be equal to <code>ty</code>.</li>
</ul>
<p>Additionally:</p>
<ul>
<li>The addition of constraints to the type inference constraint set fails if it causes an inconsistent
    set of constraints (<a href="../inference-procedures/#145-constraint-solving">§14.5</a>). In this case either an error is reported or, if we are only attempting to
    <em>assert</em> the condition, the state of the inference procedure is left unchanged and the test fails.</li>
</ul>
<h2 id="62-elaboration-and-elaborated-expressions">6.2 Elaboration and Elaborated Expressions</h2>
<p>Checking an expression generates an <em>elaborated expression</em> in a simpler, reduced language that
effectively contains a fully resolved and annotated form of the expression. The elaborated
expression provides more explicit information than the source form. For example, the elaborated
form of <code>System.Console.WriteLine("Hello")</code> indicates exactly which overloaded method definition
the call has resolved to.</p>
<!-- Elaborated forms are underlined in this specification, for example, <u>let x = 1 in x + x</u>. -->

<p>Except for this extra resolution information, elaborated forms are syntactically a subset of syntactic
expressions, and in some cases (such as constants) the elaborated form is the same as the source
form. This specification uses the following elaborated forms:</p>
<ul>
<li>Constants</li>
<li>Resolved value references: <code>path</code></li>
<li>Lambda expressions: <code>(fun ident -&gt; expr)</code></li>
<li>Primitive object expressions</li>
<li>Data expressions (tuples, union cases, array creation, record creation)</li>
<li>Default initialization expressions</li>
<li>Local definitions of values: <code>let ident = expr in expr</code></li>
<li>Local definitions of functions:
    <code>let rec ident = expr and ... and ident = expr in expr</code></li>
<li>Applications of methods and functions (with static overloading resolved)</li>
<li>Dynamic type coercions: <code>expr :?&gt; type</code></li>
<li>Dynamic type tests: <code>expr :? type</code></li>
<li>For-loops: <code>for ident in ident to ident do expr done</code></li>
<li>While-loops: <code>while expr do expr done</code></li>
<li>Sequencing: <code>expr; expr</code></li>
<li>Try-with: <code>try expr with expr</code></li>
<li>Try-finally: <code>try expr finally expr</code></li>
<li>The constructs required for the elaboration of pattern matching (<a href="../patterns/#7-patterns">§7.</a>).</li>
<li>Null tests</li>
<li>Switches on integers and other types</li>
<li>Switches on union cases</li>
<li>Switches on the runtime types of objects</li>
</ul>
<p>The following constructs are used in the elaborated forms of expressions that make direct
assignments to local variables and arrays and generate “byref” pointer values. The operations are
loosely named after their corresponding primitive constructs in the CLI.</p>
<ul>
<li>Assigning to a byref-pointer: <code>expr &lt;-stobj expr</code></li>
<li>Generating a byref-pointer by taking the address of a mutable value: <code>&amp;path</code>.</li>
<li>Generating a byref-pointer by taking the address of a record field: <code>&amp;(expr.field)</code></li>
<li>Generating a byref-pointer by taking the address of an array element: <code>&amp;(expr.[expr])</code></li>
</ul>
<p>Elaborated expressions form the basis for evaluation (see <a href="./#69-evaluation-of-elaborated-forms">§6.9</a>) and for the expression trees that
<em>quoted expressions</em> return (see <a href="./#68-quoted-expressions">§6.8</a>).</p>
<p>By convention, when describing the process of elaborating compound expressions, we omit the
process of recursively elaborating sub-expressions.</p>
<h2 id="63-data-expressions">6.3 Data Expressions</h2>
<p>This section describes the following data expressions:</p>
<ul>
<li>Simple constant expressions</li>
<li>Tuple expressions</li>
<li>List expressions</li>
<li>Array expressions</li>
<li>Record expressions</li>
<li>Copy-and-update record expressions</li>
<li>Function expressions</li>
<li>Object expressions</li>
<li>Delayed expressions</li>
<li>Computation expressions</li>
<li>Sequence expressions</li>
<li>Range expressions</li>
<li>Lists via sequence expressions</li>
<li>Arrays via sequence expressions</li>
<li>Null expressions</li>
<li>'printf' formats</li>
</ul>
<h3 id="631-simple-constant-expressions">6.3.1 Simple Constant Expressions</h3>
<p>Simple constant expressions are numeric, string, Boolean and unit constants. For example:</p>
<div class="highlight"><pre><span></span><code>3y              // sbyte
32uy            // byte
17s             // int16
18us            // uint16
86              // int/int32
99u             // uint32
99999999L       // int64
10328273UL      // uint64
1.              // float/double
1.01            // float/double
1.01e10         // float/double
1.0f            // float32/single
1.01f           // float32/single
1.01e10f        // float32/single
99999999n       // nativeint    (System.IntPtr)
10328273un      // unativeint   (System.UIntPtr)
99999999I       // bigint       (System.Numerics.BigInteger or user-specified)
&#39;a&#39;             // char         (System.Char)
&quot;3&quot;             // string       (String)
&quot;c:\\home&quot;      // string       (System.String)
@&quot;c:\home&quot;      // string       (Verbatim Unicode, System.String)
&quot;ASCII&quot;B        // byte[]
()              // unit         (FSharp.Core.Unit)
false           // bool         (System.Boolean)
true            // bool         (System.Boolean)
</code></pre></div>
<p>Simple constant expressions have the corresponding simple type and elaborate to the corresponding
simple constant value.</p>
<p>Integer literals with the suffixes <code>Q</code>, <code>R</code>, <code>Z</code>, <code>I</code>, <code>N</code>, <code>G</code> are processed using the following syntactic translation:</p>
<div class="highlight"><pre><span></span><code>xxxx&lt;suffix&gt;
    For xxxx = 0                → NumericLiteral&lt;suffix&gt;.FromZero()
    For xxxx = 1                → NumericLiteral&lt;suffix&gt;.FromOne()
    For xxxx in the Int32 range → NumericLiteral&lt;suffix&gt;.FromInt32(xxxx)
    For xxxx in the Int64 range → NumericLiteral&lt;suffix&gt;.FromInt64(xxxx)
    For other numbers           → NumericLiteral&lt;suffix&gt;.FromString(&quot;xxxx&quot;)
</code></pre></div>
<p>For example, defining a module <code>NumericLiteralZ</code> as below enables the use of the literal form <code>32Z</code> to
generate a sequence of 32 ‘Z’ characters. No literal syntax is available for numbers outside the range
of 32-bit integers.</p>
<div class="highlight"><pre><span></span><code><span class="k">module</span><span class="w"> </span><span class="nn">NumericLiteralZ</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="k">let</span><span class="w"> </span><span class="nv">FromZero</span><span class="bp">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;&quot;</span>
<span class="w">    </span><span class="k">let</span><span class="w"> </span><span class="nv">FromOne</span><span class="bp">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;Z&quot;</span>
<span class="w">    </span><span class="k">let</span><span class="w"> </span><span class="nv">FromInt32</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nn">String</span><span class="p">.</span><span class="n">replicate</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="s">&quot;Z&quot;</span>
</code></pre></div>
<p>F# compilers may optimize on the assumption that calls to numeric literal functions always
terminate, are idempotent, and do not have observable side effects.</p>
<h3 id="632-tuple-expressions">6.3.2 Tuple Expressions</h3>
<p>An expression of the form <code>expr1 , ..., exprn</code> is a <em>tuple expression</em>. For example:</p>
<div class="highlight"><pre><span></span><code><span class="k">let</span><span class="w"> </span><span class="nv">three</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="s">&quot;3&quot;</span><span class="o">)</span>
<span class="k">let</span><span class="w"> </span><span class="nv">blastoff</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">(</span><span class="mi">10</span><span class="o">,</span><span class="mi">9</span><span class="o">,</span><span class="mi">8</span><span class="o">,</span><span class="mi">7</span><span class="o">,</span><span class="mi">6</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">)</span>
</code></pre></div>
<p>The expression has the type <code>S&lt;ty1 * ... * tyn&gt;</code> for fresh types <code>ty1 ... tyn</code> and fresh pseudo-type <code>S</code> that indicates the "structness" (i.e. reference tuple or struct tuple) of the tuple. Each individual
expression <code>expri</code> is checked using initial type <code>tyi</code>. The pseudo-type <code>S</code> participates in type checking similar to normal types until it is resolved to either reference or struct tuple, with a default of reference tuple.</p>
<p>An expression of the form <code>struct (expr1 , ..., exprn)</code> is a <em>struct tuple expression</em>. For example:</p>
<div class="highlight"><pre><span></span><code><span class="k">let</span><span class="w"> </span><span class="nv">pair</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">)</span>
</code></pre></div>
<p>A <em>struct tuple expression</em> is checked in the same way as a <em>tuple expression</em>, but the pseudo-type <code>S</code> is resolved to struct tuple.</p>
<p>Tuple types and expressions that have <code>S</code> resolved to reference tuple are translated into applications of a family of .NET types named
<a href="https://learn.microsoft.com/dotnet/api/system.tuple"><code>System.Tuple</code></a>. Tuple types <code>ty1 * ... * tyn</code> are translated as follows:</p>
<ul>
<li>For <code>n &lt;= 7</code> the elaborated form is <code>Tuple&lt;ty1 ,... , tyn&gt;</code>.</li>
<li>For larger <code>n</code> , tuple types are shorthand for applications of the additional F# library type
    System.Tuple&lt;_&gt; as follows:</li>
<li>For <code>n = 8</code> the elaborated form is <code>Tuple&lt;ty1, ..., ty7, Tuple&lt;ty8&gt;&gt;</code>.</li>
<li>For <code>9 &lt;= n</code> the elaborated form is <code>Tuple&lt;ty1, ..., ty7, tyB&gt;</code> where <code>tyB</code> is the converted form of
       the type <code>(ty8 * ... * tyn)</code>.</li>
</ul>
<p>Tuple expressions <code>(expr1, ..., exprn)</code> are translated as follows:</p>
<ul>
<li>For <code>n &lt;= 7</code> the elaborated form <code>new Tuple&lt;ty1, ..., tyn&gt;(expr1, ..., exprn)</code>.</li>
<li>For <code>n = 8</code> the elaborated form <code>new Tuple&lt;ty1, ..., ty7, Tuple&lt;ty8&gt;&gt;(expr1, ..., expr7, new Tuple&lt;ty8&gt;(expr8)</code>.</li>
<li>For <code>9 &lt;= n</code> the elaborated form <code>new Tuple&lt;ty1, ... ty7, ty8n&gt;(expr1, ..., expr7, new ty8n(e8n)</code>
    where <code>ty8n</code> is the type <code>(ty8 * ... * tyn)</code> and <code>expr8n</code> is the elaborated form of the expression
    <code>expr8, ..., exprn</code>.</li>
</ul>
<p>When considered as static types, tuple types are distinct from their encoded form. However, the
encoded form of tuple values and types is visible in the F# type system through runtime types. For
example, <code>typeof&lt;int * int&gt;</code> is equivalent to <code>typeof&lt;System.Tuple&lt;int,int&gt;&gt;</code>, and <code>(1 ,2)</code> has the
runtime type <code>System.Tuple&lt;int,int&gt;</code>. Likewise, <code>(1,2,3,4,5,6,7,8,9)</code> has the runtime type
<code>Tuple&lt;int,int,int,int,int,int,int,Tuple&lt;int,int&gt;&gt;</code>.</p>
<p>Tuple types and expressions that have <code>S</code> resolved to struct tuple are translated in the same way to <a href="https://learn.microsoft.com/dotnet/api/system.valuetuple"><code>System.ValueTuple</code></a> .</p>
<blockquote>
<p>Note: The above encoding is invertible and the substitution of types for type variables
preserves this inversion. This means, among other things, that the F# reflection library
can correctly report tuple types based on runtime System.Type and System.ValueTuple values. The inversion is
defined by:
<br>- For the runtime type <code>Tuple&lt;ty1, ..., tyN&gt;</code> when <code>n &lt;= 7</code>, the corresponding F# tuple
    type is <code>ty1 * ... * tyN</code>
<br>- For the runtime type <code>Tuple&lt;ty1, ..., Tuple&lt;tyN&gt;&gt;</code> when <code>n = 8</code>, the corresponding F#
    tuple type is <code>ty1 * ... * ty8</code>
<br>- For the runtime type <code>Tuple&lt;ty1, ..., ty7, ty8n&gt;</code> , if <code>ty8n</code> corresponds to the F# tuple
    type <code>ty8 * ... * tyN</code>, then the corresponding runtime type is <code>ty1 * ... * tyN</code>.<br>Runtime types of other forms do not have a corresponding tuple type. In particular,
runtime types that are instantiations of the eight-tuple type <code>Tuple&lt;_, _, _, _, _, _, _, _ &gt;</code>
must always have <code>Tuple&lt;_&gt;</code> in the final position. Syntactic types that have some other
form of type in this position are not permitted, and if such an instantiation occurs in F#
code or CLI library metadata that is referenced by F# code, an F# implementation may
report an error.</p>
</blockquote>
<h3 id="633-list-expressions">6.3.3 List Expressions</h3>
<p>An expression of the form <code>[expr1 ; ...; exprn]</code> is a <em>list expression</em>. The initial type of the expression is
asserted to be <code>FSharp.Collections.List&lt;ty&gt;</code> for a fresh type <code>ty</code>.</p>
<p>If <code>ty</code> is a named type, each expression <code>expri</code> is checked using a fresh type <code>ty'</code> as its initial type, with
the constraint <code>ty' :&gt; ty</code>. Otherwise, each expression <code>expri</code> is checked using <code>ty</code> as its initial type.</p>
<p>List expressions elaborate to uses of <code>FSharp.Collections.List&lt;_&gt;</code> as
<code>op_Cons(expr1 ,(op_Cons(_expr2 ... op_Cons(exprn, op_Nil) ...)</code> where <code>op_Cons</code> and <code>op_Nil</code> are the
union cases with symbolic names <code>::</code> and <code>[]</code> respectively.</p>
<h3 id="634-array-expressions">6.3.4 Array Expressions</h3>
<p>An expression of the form <code>[|expr1; ...; exprn|]</code> is an <em>array expression</em>. The initial type of the
expression is asserted to be <code>ty[]</code> for a fresh type <code>ty</code>.</p>
<p>If this assertion determines that <code>ty</code> is a named type, each expression <code>expri</code> is checked using a fresh
type <code>ty'</code> as its initial type, with the constraint <code>ty' :&gt; ty</code>. Otherwise, each expression <code>expri</code> is
checked using <code>ty</code> as its initial type.</p>
<p>Array expressions are a primitive elaborated form.</p>
<blockquote>
<p>Note: The F# implementation ensures that large arrays of constants of type <code>bool</code>, <code>char</code>,
<code>byte</code>, <code>sbyte</code>, <code>int16</code>, <code>uint16</code>, <code>int32</code>, <code>uint32</code>, <code>int64</code>, and <code>uint64</code> are compiled to an efficient
binary representation based on a call to
<code>System.Runtime.CompilerServices.RuntimeHelpers.InitializeArray</code>.</p>
</blockquote>
<h3 id="635-record-expressions">6.3.5 Record Expressions</h3>
<p>An expression of the form <code>{field-initializer1; ... ; field-initializern}</code> is a <em>record
construction expression</em>. For example:</p>
<div class="highlight"><pre><span></span><code><span class="k">type</span><span class="w"> </span><span class="nc">Data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="n">Count</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">int</span><span class="o">;</span><span class="w"> </span><span class="n">Name</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">string</span><span class="w"> </span><span class="o">}</span>
<span class="k">let</span><span class="w"> </span><span class="nv">data1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="n">Count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="o">;</span><span class="w"> </span><span class="n">Name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;Hello&quot;</span><span class="o">;</span><span class="w"> </span><span class="o">}</span>
<span class="k">let</span><span class="w"> </span><span class="nv">data2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="n">Name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;Hello&quot;</span><span class="o">;</span><span class="w"> </span><span class="n">Count</span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">}</span>
</code></pre></div>
<p>In the following example, <code>data4</code> uses a long identifier to indicate the relevant field:</p>
<div class="highlight"><pre><span></span><code><span class="k">module</span><span class="w"> </span><span class="nn">M</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="k">type</span><span class="w"> </span><span class="nc">Data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="n">Age</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">int</span><span class="o">;</span><span class="w"> </span><span class="n">Name</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">string</span><span class="o">;</span><span class="w"> </span><span class="n">Height</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="o">}</span>

<span class="k">let</span><span class="w"> </span><span class="nv">data3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="nn">M</span><span class="p">.</span><span class="n">Age</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">17</span><span class="o">;</span><span class="w"> </span><span class="nn">M</span><span class="p">.</span><span class="n">Name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;John&quot;</span><span class="o">;</span><span class="w"> </span><span class="nn">M</span><span class="p">.</span><span class="n">Height</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">186</span><span class="o">.</span><span class="mi">0</span><span class="w"> </span><span class="o">}</span>
<span class="k">let</span><span class="w"> </span><span class="nv">data4</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="n">data3</span><span class="w"> </span><span class="k">with</span><span class="w"> </span><span class="nn">M</span><span class="p">.</span><span class="n">Name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;Bill&quot;</span><span class="o">;</span><span class="w"> </span><span class="nn">M</span><span class="p">.</span><span class="n">Height</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">176</span><span class="o">.</span><span class="mi">0</span><span class="w"> </span><span class="o">}</span>
</code></pre></div>
<p>Fields may also be referenced by using the name of the containing type:</p>
<div class="highlight"><pre><span></span><code><span class="k">module</span><span class="w"> </span><span class="nn">M2</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="k">type</span><span class="w"> </span><span class="nc">Data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="n">Age</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">int</span><span class="o">;</span><span class="w"> </span><span class="n">Name</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">string</span><span class="o">;</span><span class="w"> </span><span class="n">Height</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="o">}</span>

<span class="k">let</span><span class="w"> </span><span class="nv">data5</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="nn">M2</span><span class="p">.</span><span class="nn">Data</span><span class="p">.</span><span class="n">Age</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">17</span><span class="o">;</span><span class="w"> </span><span class="nn">M2</span><span class="p">.</span><span class="nn">Data</span><span class="p">.</span><span class="n">Name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;John&quot;</span><span class="o">;</span><span class="w"> </span><span class="nn">M2</span><span class="p">.</span><span class="nn">Data</span><span class="p">.</span><span class="n">Height</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">186</span><span class="o">.</span><span class="mi">0</span><span class="w"> </span><span class="o">}</span>
<span class="k">let</span><span class="w"> </span><span class="nv">data6</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="n">data5</span><span class="w"> </span><span class="k">with</span><span class="w"> </span><span class="nn">M2</span><span class="p">.</span><span class="nn">Data</span><span class="p">.</span><span class="n">Name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;Bill&quot;</span><span class="o">;</span><span class="w"> </span><span class="nn">M2</span><span class="p">.</span><span class="nn">Data</span><span class="p">.</span><span class="n">Height</span><span class="o">=</span><span class="mi">176</span><span class="o">.</span><span class="mi">0</span><span class="w"> </span><span class="o">}</span>

<span class="k">open</span><span class="w"> </span><span class="nn">M2</span>
<span class="k">let</span><span class="w"> </span><span class="nv">data7</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="nn">Data</span><span class="p">.</span><span class="n">Age</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">17</span><span class="o">;</span><span class="w"> </span><span class="nn">Data</span><span class="p">.</span><span class="n">Name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;John&quot;</span><span class="o">;</span><span class="w"> </span><span class="nn">Data</span><span class="p">.</span><span class="n">Height</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">186</span><span class="o">.</span><span class="mi">0</span><span class="w"> </span><span class="o">}</span>
<span class="k">let</span><span class="w"> </span><span class="nv">data8</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="n">data5</span><span class="w"> </span><span class="k">with</span><span class="w"> </span><span class="nn">Data</span><span class="p">.</span><span class="n">Name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;Bill&quot;</span><span class="o">;</span><span class="w"> </span><span class="nn">Data</span><span class="p">.</span><span class="n">Height</span><span class="o">=</span><span class="mi">176</span><span class="o">.</span><span class="mi">0</span><span class="w"> </span><span class="o">}</span>
</code></pre></div>
<p>Each <code>field-initializeri</code> has the form <code>field-labeli = expri</code>. Each <code>field-labeli</code> is a <code>long-ident</code>,
which must resolve to a field <code>F</code> i in a unique record type <code>R</code> as follows:</p>
<ul>
<li>If <code>field-labeli</code> is a single identifier <code>fld</code> and the initial type is known to be a record type
    <code>R&lt;_, ..., _&gt;</code> that has field <code>Fi</code> with name <code>fld</code>, then the field label resolves to <code>Fi</code>.</li>
<li>If <code>field-labeli</code> is not a single identifier or if the initial type is a variable type, then the field label
    is resolved by performing <em>Field Label Resolution</em> (see <a href="../inference-procedures/#141-name-resolution">§14.1</a>) on <code>field-labeli</code>. This procedure
    results in a set of fields <code>FSeti</code>. Each element of this set has a corresponding record type, thus
    resulting in a set of record types <code>RSeti</code>. The intersection of all <code>RSeti</code> must yield a single record
    type <code>R</code>, and each field then resolves to the corresponding field in <code>R</code>.
    The set of fields must be complete. That is, each field in record type <code>R</code> must have exactly one
    field definition. Each referenced field must be accessible (see <a href="../namespaces-and-modules/#105-accessibility-annotations">§10.5</a>), as must the type <code>R</code>.</li>
</ul>
<p>After all field labels are resolved, the overall record expression is asserted to be of type
<code>R&lt;ty1, ..., tyN&gt;</code> for fresh types <code>ty1, ..., tyN</code>. Each <code>expri</code> is then checked in turn. The initial type is
determined as follows:</p>
<ol>
<li>Assume the type of the corresponding field <code>Fi</code> in <code>R&lt;ty1, ..., tyN&gt;</code> is <code>ftyi</code></li>
<li>If the type of <code>Fi</code> prior to taking into account the instantiation <code>&lt;ty1, ..., tyN&gt;</code> is a named type, then
    the initial type is a fresh type inference variable <code>fty'i</code> with a constraint <code>fty'i :&gt; ftyi</code>.</li>
<li>Otherwise the initial type is <code>ftyi</code>.</li>
</ol>
<p>Primitive record constructions are an elaborated form in which the fields appear in the same order
as in the record type definition. Record expressions themselves elaborate to a form that may
introduce local value definitions to ensure that expressions are evaluated in the same order that the
field definitions appear in the original expression. For example:</p>
<div class="highlight"><pre><span></span><code><span class="k">type</span><span class="w"> </span><span class="nc">R</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">{</span><span class="n">b</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">int</span><span class="o">;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">int</span><span class="w"> </span><span class="o">}</span>
<span class="o">{</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="o">;</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">}</span>
</code></pre></div>
<p>The expression on the last line elaborates to <code>let v = 1 + 1 in { b = 2; a = v }</code>.</p>
<p>Records expressions are also used for object initializations in additional object constructor
definitions (<a href="../type-definitions/#863-additional-object-constructors-in-classes">§8.6.3</a>). For example:</p>
<div class="highlight"><pre><span></span><code><span class="k">type</span><span class="w"> </span><span class="nc">C</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="k">val</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">int</span>
<span class="w">    </span><span class="k">val</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">int</span>
<span class="w">    </span><span class="k">new</span><span class="bp">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="o">;</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">}</span>
</code></pre></div>
<blockquote>
<p>Note: The following record initialization form is deprecated:
<br><code>{ new type with Field1 = expr1 and ... and Fieldn = exprn }</code>
<br>The F# implementation allows the use of this form only with uppercase identifiers.
<br>F# code should not use this expression form. A future version of the F# language will
issue a deprecation warning.</p>
</blockquote>
<h3 id="636-copy-and-update-record-expressions">6.3.6 Copy-and-update Record Expressions</h3>
<p>A <em>copy-and-update record expression</em> has the following form:</p>
<div class="highlight"><pre><span></span><code>{ expr with field-initializers }
</code></pre></div>
<p>where <code>field-initializers</code> is of the following form:</p>
<div class="highlight"><pre><span></span><code>field-label1 = expr1; ...; field-labeln = exprn
</code></pre></div>
<p>Each <code>field-labeli</code> is a <code>long-ident</code>. In the following example, <code>data2</code> is defined by using such an
expression:</p>
<div class="highlight"><pre><span></span><code><span class="k">type</span><span class="w"> </span><span class="nc">Data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="n">Age</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">int</span><span class="o">;</span><span class="w"> </span><span class="n">Name</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">string</span><span class="o">;</span><span class="w"> </span><span class="n">Height</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="o">}</span>
<span class="k">let</span><span class="w"> </span><span class="nv">data1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="n">Age</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">17</span><span class="o">;</span><span class="w"> </span><span class="n">Name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;John&quot;</span><span class="o">;</span><span class="w"> </span><span class="n">Height</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">186</span><span class="o">.</span><span class="mi">0</span><span class="w"> </span><span class="o">}</span>
<span class="k">let</span><span class="w"> </span><span class="nv">data2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="n">data1</span><span class="w"> </span><span class="k">with</span><span class="w"> </span><span class="n">Name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;Bill&quot;</span><span class="o">;</span><span class="w"> </span><span class="n">Height</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">176</span><span class="o">.</span><span class="mi">0</span><span class="w"> </span><span class="o">}</span>
</code></pre></div>
<p>The expression <code>expr</code> is first checked with the same initial type as the overall expression. Next, the
field definitions are resolved by using the same technique as for record expressions. Each field label
must resolve to a field <code>Fi</code> in a single record type <code>R</code> , all of whose fields are accessible. After all field
labels are resolved, the overall record expression is asserted to be of type <code>R&lt;ty1, ..., tyN&gt;</code> for fresh
types <code>ty1, ..., tyN</code>. Each <code>expri</code> is then checked in turn with initial type that results from the following
procedure:</p>
<ol>
<li>Assume the type of the corresponding field <code>Fi</code> in <code>R&lt;ty1, ..., tyN&gt;</code> is <code>ftyi</code>.</li>
<li>If the type of <code>Fi</code> before considering the instantiation <code>&lt;ty1, ..., tyN&gt;</code> is a named type, then the
    initial type is a fresh type inference variable <code>fty'i</code> with a constraint <code>fty'i :&gt; ftyi</code>.</li>
<li>Otherwise, the initial type is <code>ftyi</code>.</li>
</ol>
<p>A copy-and-update record expression elaborates as if it were a record expression written as follows:</p>
<p><code>let v = expr in { field-label1 = expr1; ...; field-labeln = exprn; F1 = v.F1; ...; FM = v.FM }</code>
where <code>F1 ... FM</code> are the fields of <code>R</code> that are not defined in <code>field-initializers</code> and <code>v</code> is a fresh
variable.</p>
<h3 id="637-function-expressions">6.3.7 Function Expressions</h3>
<p>An expression of the form <code>fun pat1 ... patn -&gt; expr</code> is a <em>function expression</em>. For example:</p>
<div class="highlight"><pre><span></span><code><span class="o">(</span><span class="k">fun</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="o">)</span>
<span class="o">(</span><span class="k">fun</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span><span class="o">)</span>
<span class="o">(</span><span class="k">fun</span><span class="w"> </span><span class="o">[</span><span class="n">x</span><span class="o">]</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">x</span><span class="o">)</span><span class="w"> </span><span class="c1">// note, incomplete match</span>
<span class="o">(</span><span class="k">fun</span><span class="w"> </span><span class="o">(</span><span class="n">x</span><span class="o">,</span><span class="n">y</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">z</span><span class="o">,</span><span class="n">w</span><span class="o">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">w</span><span class="o">)</span>
</code></pre></div>
<p>Function expressions that involve only variable patterns are a primitive elaborated form. Function
expressions that involve non-variable patterns elaborate as if they had been written as follows:</p>
<div class="highlight"><pre><span></span><code><span class="k">fun</span><span class="w"> </span><span class="n">v1</span><span class="w"> </span><span class="o">...</span><span class="w"> </span><span class="n">vn</span><span class="w"> </span><span class="o">-&gt;</span>
<span class="w">    </span><span class="k">let</span><span class="w"> </span><span class="nv">pat1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="mi">1</span>
<span class="w">    </span><span class="o">...</span>
<span class="w">    </span><span class="k">let</span><span class="w"> </span><span class="nv">patn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vn</span>
<span class="w">    </span><span class="n">expr</span>
</code></pre></div>
<p>No pattern matching is performed until all arguments have been received. For example, the
following does not raise a <code>MatchFailureException</code> exception:</p>
<div class="highlight"><pre><span></span><code><span class="k">let</span><span class="w"> </span><span class="nv">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">fun</span><span class="w"> </span><span class="o">[</span><span class="n">x</span><span class="o">]</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">y</span>
<span class="k">let</span><span class="w"> </span><span class="nv">g</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="bp">[]</span><span class="w"> </span><span class="c1">// ok</span>
</code></pre></div>
<p>However, if a third line is added, a <code>MatchFailureException</code> exception is raised:</p>
<div class="highlight"><pre><span></span><code><span class="k">let</span><span class="w"> </span><span class="nv">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">g</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="c1">// MatchFailureException is raised</span>
</code></pre></div>
<h3 id="638-object-expressions">6.3.8 Object Expressions</h3>
<p>An expression of the following form is an <em>object expression</em> :</p>
<div class="highlight"><pre><span></span><code><span class="o">{</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ty0</span><span class="w"> </span><span class="n">args</span><span class="o">-</span><span class="n">expr</span><span class="o">?</span><span class="w"> </span><span class="k">object</span><span class="o">-</span><span class="n">members</span>
<span class="w">  </span><span class="k">interface</span><span class="w"> </span><span class="n">ty1</span><span class="w"> </span><span class="k">object</span><span class="o">-</span><span class="n">members1</span>
<span class="w">  </span><span class="o">...</span>
<span class="w">  </span><span class="k">interface</span><span class="w"> </span><span class="n">tyn</span><span class="w"> </span><span class="k">object</span><span class="o">-</span><span class="n">membersn</span><span class="w"> </span><span class="o">}</span>
</code></pre></div>
<p>In the case of the interface declarations, the <code>object-members</code> are optional and are considered empty
if absent. Each set of <code>object-members</code> has the form:</p>
<div class="highlight"><pre><span></span><code>with member-defns end?
</code></pre></div>
<p>Lexical filtering inserts simulated <code>$end</code> tokens when lightweight syntax is used.</p>
<p>Each member of an object expression members can use the keyword <code>member</code>, <code>override</code>, or <code>default</code>.
The keyword <code>member</code> can be used even when overriding a member or implementing an interface.</p>
<p>For example:</p>
<div class="highlight"><pre><span></span><code><span class="k">let</span><span class="w"> </span><span class="nv">obj1</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="o">{</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nn">System</span><span class="p">.</span><span class="nn">Collections</span><span class="p">.</span><span class="nn">Generic</span><span class="p">.</span><span class="n">IComparer</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;</span><span class="w"> </span><span class="k">with</span>
<span class="w">        </span><span class="k">member</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="nf">Compare</span><span class="o">(</span><span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="o">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">compare</span><span class="w"> </span><span class="o">(</span><span class="n">a</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">7</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">b</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">7</span><span class="o">)</span><span class="w"> </span><span class="o">}</span>

<span class="k">let</span><span class="w"> </span><span class="nv">obj2</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="o">{</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nn">System</span><span class="p">.</span><span class="n">Object</span><span class="bp">()</span><span class="w"> </span><span class="k">with</span>
<span class="w">        </span><span class="k">member</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="nf">ToString</span><span class="w"> </span><span class="bp">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;Hello&quot;</span><span class="w"> </span><span class="o">}</span>

<span class="k">let</span><span class="w"> </span><span class="nv">obj3</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="o">{</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nn">System</span><span class="p">.</span><span class="n">Object</span><span class="bp">()</span><span class="w"> </span><span class="k">with</span>
<span class="w">        </span><span class="k">member</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="nf">ToString</span><span class="w"> </span><span class="bp">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;Hello, base.ToString() = &quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="k">base</span><span class="o">.</span><span class="n">ToString</span><span class="bp">()</span><span class="w"> </span><span class="o">}</span>

<span class="k">let</span><span class="w"> </span><span class="nv">obj4</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="o">{</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nn">System</span><span class="p">.</span><span class="n">Object</span><span class="bp">()</span><span class="w"> </span><span class="k">with</span>
<span class="w">        </span><span class="k">member</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="nf">Finalize</span><span class="bp">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">printfn</span><span class="w"> </span><span class="s">&quot;Finalize&quot;</span><span class="o">;</span>
<span class="w">    </span><span class="k">interface</span><span class="w"> </span><span class="nn">System</span><span class="p">.</span><span class="n">IDisposable</span><span class="w"> </span><span class="k">with</span>
<span class="w">        </span><span class="k">member</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="nf">Dispose</span><span class="bp">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">printfn</span><span class="w"> </span><span class="s">&quot;Dispose&quot;</span><span class="o">;</span><span class="w"> </span><span class="o">}</span>
</code></pre></div>
<p>An object expression can specify additional interfaces beyond those required to fulfill the abstract
slots of the type being implemented. For example, <code>obj4</code> in the preceding examples has static type
<code>System.Object</code> but the object additionally implements the interface <code>System.IDisposable</code>. The
additional interfaces are not part of the static type of the overall expression, but can be revealed
through type tests.</p>
<p>Object expressions are statically checked as follows.</p>
<ol>
<li>
<p>First, <code>ty0</code> to <code>tyn</code> are checked to verify that they are named types. The overall type of the
expression is <code>ty0</code> and is asserted to be equal to the initial type of the expression. However, if <code>ty0</code>
is type equivalent to <code>System.Object</code> and <code>ty1</code> exists, then the overall type is instead <code>ty1</code>.</p>
</li>
<li>
<p>The type <code>ty0</code> must be a class or interface type. The base construction argument <code>args-expr</code> must
    appear if and only if <code>ty0</code> is a class type. The type must have one or more accessible constructors;
    the call to these constructors is resolved and elaborated using <em>Method Application Resolution</em>
    (see <a href="../inference-procedures/#144-method-application-resolution">§14.4</a>). Except for <code>ty0</code>, each <code>tyi</code> must be an interface type.</p>
</li>
<li>The F# compiler attempts to associate each member with a unique <em>dispatch slot</em> by using
    <em>dispatch slot inference</em> (<a href="../inference-procedures/#147-dispatch-slot-inference">§14.7</a>). If a unique matching dispatch slot is found, then the argument
    types and return type of the member are constrained to be precisely those of the dispatch slot.</li>
<li>The arguments, patterns, and expressions that constitute the bodies of all implementing
    members are next checked one by one to verify the following:<ul>
<li>For each member, the “this” value for the member is in scope and has type <code>ty0</code>.</li>
<li>Each member of an object expression can initially access the protected members of <code>ty0</code>.</li>
<li>If the variable <code>base-ident</code> appears, it must be named <code>base</code>, and in each member a base
   variable with this name is in scope. Base variables can be used only in the member
   implementations of an object expression, and are subject to the same limitations as byref
   values described in <a href="../inference-procedures/#149-byref-safety-analysis">§14.9</a>.</li>
</ul>
</li>
</ol>
<p>The object must satisfy <em>dispatch slot checking</em> (<a href="../inference-procedures/#148-dispatch-slot-checking">§14.8</a>) which ensures that a one-to-one mapping
exists between dispatch slots and their implementations.</p>
<p>Object expressions elaborate to a primitive form. At execution, each object expression creates an
object whose runtime type is compatible with all of the <code>tyi</code> that have a dispatch map that is the
result of <em>dispatch slot checking</em> (<a href="../inference-procedures/#148-dispatch-slot-checking">§14.8</a>).</p>
<p>The following example shows how to both implement an interface and override a method from
<code>System.Object</code>. The overall type of the expression is <code>INewIdentity</code>.</p>
<div class="highlight"><pre><span></span><code><span class="k">type</span><span class="w"> </span><span class="nc">public</span><span class="w"> </span><span class="n">INewIdentity</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="k">abstract</span><span class="w"> </span><span class="n">IsAnonymous</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">bool</span>

<span class="k">let</span><span class="w"> </span><span class="nv">anon</span><span class="w"> </span><span class="o">=</span>
<span class="o">{</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nn">System</span><span class="p">.</span><span class="n">Object</span><span class="bp">()</span><span class="w"> </span><span class="k">with</span>
<span class="w">    </span><span class="k">member</span><span class="w"> </span><span class="n">i</span><span class="p">.</span><span class="nf">ToString</span><span class="bp">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;anonymous&quot;</span>
<span class="w">  </span><span class="k">interface</span><span class="w"> </span><span class="n">INewIdentity</span><span class="w"> </span><span class="k">with</span>
<span class="w">    </span><span class="k">member</span><span class="w"> </span><span class="n">i</span><span class="p">.</span><span class="nf">IsAnonymous</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">true</span><span class="w"> </span><span class="o">}</span>
</code></pre></div>
<h3 id="639-delayed-expressions">6.3.9 Delayed Expressions</h3>
<p>An expression of the form <code>lazy expr</code> is a <em>delayed expression</em>. For example:</p>
<div class="highlight"><pre><span></span><code><span class="k">lazy</span><span class="w"> </span><span class="o">(</span><span class="n">printfn</span><span class="w"> </span><span class="s">&quot;hello world&quot;</span><span class="o">)</span>
</code></pre></div>
<p>is syntactic sugar for</p>
<div class="highlight"><pre><span></span><code><span class="k">new</span><span class="w"> </span><span class="nn">System</span><span class="p">.</span><span class="n">Lazy</span><span class="w"> </span><span class="o">(</span><span class="k">fun</span><span class="w"> </span><span class="bp">()</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">expr</span><span class="w"> </span><span class="o">)</span>
</code></pre></div>
<p>The behavior of the <code>System.Lazy</code> library type ensures that expression <code>expr</code> is evaluated on demand in
response to a <code>.Value</code> operation on the lazy value.</p>
<h3 id="6310-computation-expressions">6.3.10 Computation Expressions</h3>
<p>The following expression forms are all <em>computation expressions</em> :</p>
<div class="highlight"><pre><span></span><code>expr { for ... }
expr { let ... }
expr { let! ... }
expr { use ... }
expr { while ... }
expr { yield ... }
expr { yield! ... }
expr { try ... }
expr { return ... }
expr { return! ... }
expr { match! ... }
</code></pre></div>
<p>More specifically, computation expressions have the following form:</p>
<div class="highlight"><pre><span></span><code>builder-expr { cexpr }
</code></pre></div>
<p>where <code>cexpr</code> is, syntactically, the grammar of expressions with the additional constructs that are
defined in <code>comp-expr</code>. Computation expressions are used for sequences and other non-standard
interpretations of the F# expression syntax. For a fresh variable <code>b</code>, the expression</p>
<div class="highlight"><pre><span></span><code>builder-expr { cexpr }
</code></pre></div>
<p>translates to</p>
<div class="highlight"><pre><span></span><code>let b = builder-expr in {| cexpr |}C
</code></pre></div>
<p>The type of <code>b</code> must be a named type after the checking of builder-expr. The subscript indicates that
custom operations (<code>C</code>) are acceptable but are not required.</p>
<p>If the inferred type of <code>b</code> has one or more of the <code>Run</code>, <code>Delay</code>, or <code>Quote</code> methods when <code>builder-expr</code> is
checked, the translation involves those methods. For example, when all three methods exist, the
same expression translates to:</p>
<div class="highlight"><pre><span></span><code>let b = builder-expr in b.Run (&lt;@ b.Delay(fun () -&gt; {| cexpr |}C) &gt;@)
</code></pre></div>
<p>If a <code>Run</code> method does not exist on the inferred type of b, the call to <code>Run</code> is omitted. Likewise, if no
<code>Delay</code> method exists on the type of <code>b</code>, that call and the inner lambda are omitted, so the expression
translates to the following:</p>
<div class="highlight"><pre><span></span><code>let b = builder-expr in b.Run (&lt;@ {| cexpr |}C &gt;@)
</code></pre></div>
<p>Similarly, if a <code>Quote</code> method exists on the inferred type of <code>b</code>, at-signs <code>&lt;@ @&gt;</code> are placed around <code>{| cexpr |}C</code>
or <code>b.Delay(fun () -&gt; {| cexpr |}C)</code> if a <code>Delay</code> method also exists.</p>
<p>The translation <code>{| cexpr |}C</code> , which rewrites computation expressions to core language expressions,
is defined recursively according to the following rules:</p>
<p><code>{| cexpr |}C = T (cexpr, [], fun v -&gt; v, true)</code></p>
<p>During the translation, we use the helper function {| cexpr |}0 to denote a translation that does not
involve custom operations:</p>
<p><code>{| cexpr |}0 = T (cexpr, [], fun v -&gt; v, false)</code></p>
<div class="highlight"><pre><span></span><code>T (e, V , C , q) where e : the computation expression being translated
                       V : a set of scoped variables
                       C : continuation (or context where “e” occurs,
                           up to a hole to be filled by the result of translating “e”)
                       q : Boolean that indicates whether a custom operator is allowed
</code></pre></div>
<!-- start of weird section -->

<p>Then, T is defined for each computation expression e:</p>
<p><strong>T</strong> (let p = e in ce, <strong>V</strong> , <strong>C</strong> , q) = <strong>T</strong> (ce, <strong>V</strong>  <code>var</code> (p), v. <strong>C</strong> (let p = e in v), q)</p>
<p><strong>T</strong> (let! p = e in ce, <strong>V</strong> , <strong>C</strong> , q) = <strong>T</strong> (ce, <strong>V</strong>  <code>var</code> (p), v. <strong>C</strong> (b.Bind( <code>src</code> (e),fun p -&gt; v), q)</p>
<p><strong>T</strong> (yield e, <strong>V</strong> , <strong>C</strong> , q) = <strong>C</strong> (b.Yield(e))</p>
<p><strong>T</strong> (yield! e, <strong>V</strong> , <strong>C</strong> , q) = <strong>C</strong> (b.YieldFrom( <code>src</code> (e)))</p>
<p><strong>T</strong> (return e, <strong>V</strong> , <strong>C</strong> , q) = <strong>C</strong> (b.Return(e))</p>
<p><strong>T</strong> (return! e, <strong>V</strong> , <strong>C</strong> , q) = <strong>C</strong> (b.ReturnFrom( <code>src</code> (e)))</p>
<p><strong>T</strong> (use p = e in ce, <strong>V</strong> , <strong>C</strong> , q) = <strong>C</strong> (b.Using(e, fun p -&gt; {| <code>ce</code> |} 0 ))</p>
<p><strong>T</strong> (use! p = e in ce, <strong>V</strong> , <strong>C</strong> , q) = <strong>C</strong> (b.Bind( <code>src</code> (e), fun p -&gt; b.Using(p, fun p -&gt; {| <code>ce</code> |} 0 ))</p>
<p><strong>T</strong> (match e with pi - &gt; cei, <strong>V</strong> , <strong>C</strong> , q) = <strong>C</strong> (match e with pi - &gt; {| <code>ce</code> i |} 0 )</p>
<p><strong>T</strong> (match! e with pi - &gt; cei, <strong>V</strong> , <strong>C</strong> , q) = <strong>C</strong> (let! p = e in match p with pi - &gt; {| <code>ce</code> i |} 0 )</p>
<p><strong>T</strong> (while e do ce, <strong>V</strong> , <strong>C</strong> , q) = <strong>T</strong> (ce, <strong>V</strong> , v. <strong>C</strong> (b.While(fun () -&gt; e, b.Delay(fun () -&gt; v))), q)</p>
<p><strong>T</strong> (try ce with pi - &gt; cei, <strong>V</strong> , <strong>C</strong> , q) =
Assert(not q); <strong>C</strong> (b.TryWith(b.Delay(fun () -&gt; {| <code>ce</code> |} 0 ), fun pi - &gt; {| <code>ce</code> i |} 0 ))</p>
<p><strong>T</strong> (try ce finally e, <strong>V</strong> , <strong>C</strong> , q) =
Assert(not q); <strong>C</strong> (b.TryFinally(b.Delay(fun () -&gt; {| <code>ce</code> |} 0 ), fun () -&gt; e))</p>
<p><strong>T</strong> (if e then ce, <strong>V</strong> , <strong>C</strong> , q) = <strong>T</strong> (ce, <strong>V</strong> , v. <strong>C</strong> (if e then v else b.Zero()), q)</p>
<p><strong>T</strong> (if e then ce1 else ce2 , <strong>V</strong> , <strong>C</strong> , q) = Assert(not q); <strong>C</strong> (if e then {| <code>ce</code> 1 |} 0 ) else {| <code>ce</code> 2 |} 0 )</p>
<p><strong>T</strong> (for x = e1 to e2 do ce, <strong>V</strong> , <strong>C</strong> , q) = <strong>T</strong> (for x in e1 .. e2 do ce, <strong>V</strong> , <strong>C</strong> , q)</p>
<p><strong>T</strong> (for p1 in e1 do joinOp p2 in e2 onWord (e3 <code>eop</code> e4 ) ce, <strong>V</strong> , <strong>C</strong> , q) =
Assert(q); <strong>T</strong> (for <code>pat</code> ( <strong>V</strong> ) in b.Join( <code>src</code> (e1 ), <code>src</code> (e2 ), p1 .e3 , p2 .e4 ,
p1. p2 .(p1 ,p2 )) do ce, <strong>V</strong> , <strong>C</strong> , q)</p>
<p><strong>T</strong> (for p1 in e1 do groupJoinOp p2 in e2 onWord (e3 <code>eop</code> e4) into p3 ce, <strong>V</strong> , <strong>C</strong> , q) =
Assert(q); <strong>T</strong> (for <code>pat</code> ( <strong>V</strong> ) in b.GroupJoin( <code>src</code> (e1),
<code>src</code> (e2), p1.e3, p2.e4, p1. p3.(p1,p3)) do ce, <strong>V</strong> , <strong>C</strong> , q)</p>
<p><strong>T</strong> (for x in e do ce, <strong>V</strong> , <strong>C</strong> , q) = <strong>T</strong> (ce, <strong>V</strong>  {x}, v. <strong>C</strong> (b.For( <code>src</code> (e), fun x -&gt; v)), q)</p>
<p><strong>T</strong> (do e in ce, <strong>V</strong> , <strong>C</strong> , q) = <strong>T</strong> (ce, <strong>V</strong> , v. <strong>C</strong> (e; v), q)</p>
<p><strong>T</strong> (do! e in ce, <strong>V</strong> , <strong>C</strong> , q) = <strong>T</strong> (let! () = e in ce, <strong>V</strong> , <strong>C</strong> , q)</p>
<p><strong>T</strong> (joinOp p2 in e2 on (e3 <code>eop</code> e4) ce, <strong>V</strong> , <strong>C</strong> , q) =
<strong>T</strong> (for <code>pat</code> ( <strong>V</strong> ) in <strong>C</strong> ({| yield <code>exp</code> ( <strong>V</strong> ) |}0) do join p2 in e2 onWord (e3 <code>eop</code> e4) ce, <strong>V</strong> , v.v, q)</p>
<p><strong>T</strong> (groupJoinOp p2 in e2 onWord (e3 eop e4) into p3 ce, <strong>V</strong> , <strong>C</strong> , q) =
<strong>T</strong> (for <code>pat</code> ( <strong>V</strong> ) in <strong>C</strong> ({| yield <code>exp</code> ( <strong>V</strong> ) |}0) do groupJoin p2 in e2 on (e3 <code>eop</code> e4) into p3 ce,
<strong>V</strong> , v.v, q)</p>
<p><strong>T</strong> ([<CustomOperator("Cop")>]cop arg, <strong>V</strong> , <strong>C</strong> , q) = Assert (q); [| cop arg, <strong>C</strong> (b.Yield <code>exp</code> ( <strong>V</strong> )) |] <strong>V</strong></p>
<p><strong>T</strong> ([<CustomOperator("Cop", MaintainsVarSpaceUsingBind=true)>]cop arg; e, <strong>V</strong> , <strong>C</strong> , q) =
Assert (q); <strong>CL</strong> (cop arg; e, <strong>V</strong> , <strong>C</strong> (b.Return <code>exp</code> ( <strong>V</strong> )), false)</p>
<p><strong>T</strong> ([<CustomOperator("Cop")>]cop arg; e, <strong>V</strong> , <strong>C</strong> , q) =
Assert (q); <strong>CL</strong> (cop arg; e, <strong>V</strong> , <strong>C</strong> (b.Yield <code>exp</code> ( <strong>V</strong> )), false)</p>
<p><strong>T</strong> (ce1; ce2, <strong>V</strong> , <strong>C</strong> , q) = <strong>C</strong> (b.Combine({| ce1 |}0, b.Delay(fun () -&gt; {| ce2 |}0)))</p>
<p><strong>T</strong> (do! e;, <strong>V</strong> , <strong>C</strong> , q) = <strong>T</strong> (let! () = <code>src</code> (e) in b.Return(), <strong>V</strong> , <strong>C</strong> , q)</p>
<p><strong>T</strong> (e;, <strong>V</strong> , <strong>C</strong> , q) = <strong>C</strong> (e;b.Zero())</p>
<p>The following notes apply to the translations:</p>
<ul>
<li>The lambda expression (fun f x -&gt; b) is represented by x.b.</li>
<li>The auxiliary function var (p) denotes a set of variables that are introduced by a pattern p. For
    example:
    var(x) = {x}, var((x,y)) = {x,y} or var(S (x,y)) = {x,y}
    where S is a type constructor.</li>
<li> is an update operator for a set V to denote extended variable spaces. It updates the existing
    variables. For example, {x,y}  var((x,z)) becomes {x,y,z} where the second x replaces the
    first x.</li>
<li>The auxiliary function pat ( <strong>V</strong> ) denotes a pattern tuple that represents a set of variables in <strong>V</strong>. For
    example, pat({x,y}) becomes (x,y), where x and y represent pattern expressions.</li>
<li>
<p>The auxiliary function exp ( <strong>V</strong> ) denotes a tuple expression that represents a set of variables in <strong>V</strong>.
    For example, exp ({x,y}) becomes (x,y), where x and y represent variable expressions.</p>
</li>
<li>
<p>The auxiliary function src (e) denotes b.Source(e) if the innermost ForEach is from the user
    code instead of generated by the translation, and a builder b contains a Source method.
    Otherwise, src (e) denotes e.</p>
</li>
<li>Assert() checks whether a custom operator is allowed. If not, an error message is reported.
    Custom operators may not be used within try/with, try/finally, if/then/else, use, match, or
    sequential execution expressions such as (e1;e2). For example, you cannot use if/then/else in
    any computation expressions for which a builder defines any custom operators, even if the
    custom operators are not used.</li>
<li>The operator eop denotes one of =, ?=, =? or ?=?.</li>
<li>joinOp and onWord represent keywords for join-like operations that are declared in
    CustomOperationAttribute. For example, [<CustomOperator("join", IsLikeJoin=true,
    JoinConditionWord="on")>] declares “join” and “on”.</li>
<li>Similarly, groupJoinOp represents a keyword for groupJoin-like operations, declared in
    CustomOperationAttribute. For example, [<CustomOperator("groupJoin",
    IsLikeGroupJoin=true, JoinConditionWord="on")>] declares “groupJoin” and “on”.</li>
<li>The auxiliary translation <strong>CL</strong> is defined as follows:</li>
</ul>
<div class="highlight"><pre><span></span><code>CL (e1, V, e2, bind) where e1: the computation expression being translated
V : a set of scoped variables
e2 : the expression that will be translated after e1 is done
bind: indicator if it is for Bind (true) or iterator (false).
</code></pre></div>
<p>The following shows translations for the uses of CL in the preceding computation expressions:</p>
<div class="highlight"><pre><span></span><code>CL (cop arg, V , e’, bind) = [| cop arg, e’ |] V
CL ([&lt;MaintainsVariableSpaceUsingBind=true&gt;]cop arg into p; e, V , e’, bind) =
T (let! p = e’ in e, [], v.v, true)
CL (cop arg into p; e, V , e’, bind) = T (for p in e’ do e, [], v.v, true)
CL ([&lt;MaintainsVariableSpace=true&gt;]cop arg; e, V , e’, bind) =
CL (e, V , [| cop arg, e’ |] V , true)
CL ([&lt;MaintainsVariableSpaceUsingBind=true&gt;]cop arg; e, V , e’, bind) =
CL (e, V , [| cop arg, e’ |] V , true)
CL (cop arg; e, V , e’, bind) = CL (e, [], [| cop arg, e’ |] V , false)
CL (e, V , e’, true) = T (let! pat ( V ) = e’ in e, V , v.v, true)
CL (e, V , e’, false) = T (for pat ( V ) in e’ do e, V , v.v, true)
</code></pre></div>
<ul>
<li>The auxiliary translation [| e1, e2 |]V is defined as follows:</li>
</ul>
<p>[|[ e1, e2 |] <strong>V</strong> where e1: the custom operator available in a build
e2 : the context argument that will be passed to a custom operator
<strong>V</strong> : a list of bound variables</p>
<div class="highlight"><pre><span></span><code>[|[&lt;CustomOperator(&quot; Cop&quot;)&gt;] cop [&lt;ProjectionParameter&gt;] arg, e |] V =
b.Cop (e, fun pat ( V) - &gt; arg)
[|[&lt;CustomOperator(&quot;Cop&quot;)&gt;] cop arg, e |] V = b.Cop (e, arg)
</code></pre></div>
<ul>
<li>The final two translation rules (for do! e; and do! e;) apply only for the final expression in the
    computation expression. The semicolon (;) can be omitted.</li>
</ul>
<p>The following attributes specify custom operations:</p>
<ul>
<li><code>CustomOperationAttribute</code> indicates that a member of a builder type implements a custom
    operation in a computation expression. The attribute has one parameter: the name of the
    custom operation. The operation can have the following properties:</li>
<li><code>MaintainsVariableSpace</code> indicates that the custom operation maintains the variable space of
       a computation expression.</li>
<li><code>MaintainsVariableSpaceUsingBind</code> indicates that the custom operation maintains the
       variable space of a computation expression through the use of a bind operation.</li>
<li><code>AllowIntoPattern</code> indicates that the custom operation supports the use of ‘into’ immediately
       following the operation in a computation expression to consume the result of the operation.</li>
<li><code>IsLikeJoin</code> indicates that the custom operation is similar to a join in a sequence
       computation, which supports two inputs and a correlation constraint.</li>
<li><code>IsLikeGroupJoin</code> indicates that the custom operation is similar to a group join in a sequence
       computation, which support two inputs and a correlation constraint, and generates a group.</li>
<li><code>JoinConditionWord</code> indicates the names used for the ‘on’ part of the custom operator for
       join-like operators.</li>
<li><code>ProjectionParameterAttribute</code> indicates that, when a custom operation is used in a
    computation expression, a parameter is automatically parameterized by the variable space of
    the computation expression.</li>
</ul>
<!-- end of weird section -->

<p>The following examples show how the translation works. Assume the following simple sequence
builder:</p>
<div class="highlight"><pre><span></span><code><span class="k">type</span><span class="w"> </span><span class="nc">SimpleSequenceBuilder</span><span class="bp">()</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="k">member</span><span class="w"> </span><span class="n">__</span><span class="p">.</span><span class="nf">For</span><span class="w"> </span><span class="o">(</span><span class="n">source</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">seq</span><span class="o">&lt;</span><span class="k">&#39;</span><span class="n">a</span><span class="o">&gt;,</span><span class="w"> </span><span class="n">body</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">&#39;</span><span class="n">a</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">seq</span><span class="o">&lt;</span><span class="k">&#39;</span><span class="n">b</span><span class="o">&gt;)</span><span class="w"> </span><span class="o">=</span>
<span class="w">        </span><span class="n">seq</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">source</span><span class="w"> </span><span class="k">do</span><span class="w"> </span><span class="k">yield</span><span class="o">!</span><span class="w"> </span><span class="n">body</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">}</span>
<span class="w">    </span><span class="k">member</span><span class="w"> </span><span class="n">__</span><span class="p">.</span><span class="nf">Yield</span><span class="w"> </span><span class="o">(</span><span class="n">item</span><span class="o">:</span><span class="k">&#39;</span><span class="n">a</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">seq</span><span class="o">&lt;</span><span class="k">&#39;</span><span class="n">a</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">seq</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="k">yield</span><span class="w"> </span><span class="n">item</span><span class="w"> </span><span class="o">}</span>

<span class="k">let</span><span class="w"> </span><span class="nv">myseq</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SimpleSequenceBuilder</span><span class="bp">()</span>
</code></pre></div>
<p>Then, the expression</p>
<div class="highlight"><pre><span></span><code><span class="n">myseq</span><span class="w"> </span><span class="o">{</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">..</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="k">do</span>
<span class="w">    </span><span class="k">yield</span><span class="w"> </span><span class="n">i</span><span class="o">*</span><span class="n">i</span>
<span class="w">    </span><span class="o">}</span>
</code></pre></div>
<p>translates to</p>
<div class="highlight"><pre><span></span><code><span class="k">let</span><span class="w"> </span><span class="nv">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">myseq</span>
<span class="n">b</span><span class="o">.</span><span class="n">For</span><span class="o">([</span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="o">],</span><span class="w"> </span><span class="k">fun</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">-&gt;</span>
<span class="w">    </span><span class="n">b</span><span class="o">.</span><span class="n">Yield</span><span class="o">(</span><span class="n">i</span><span class="o">*</span><span class="n">i</span><span class="o">))</span>
</code></pre></div>
<p><code>CustomOperationAttribute</code> allows us to define custom operations. For example, the simple sequence
builder can have a custom operator, “where”:</p>
<div class="highlight"><pre><span></span><code><span class="k">type</span><span class="w"> </span><span class="nc">SimpleSequenceBuilder</span><span class="bp">()</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="k">member</span><span class="w"> </span><span class="n">__</span><span class="p">.</span><span class="nf">For</span><span class="w"> </span><span class="o">(</span><span class="n">source</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">seq</span><span class="o">&lt;</span><span class="k">&#39;</span><span class="n">a</span><span class="o">&gt;,</span><span class="w"> </span><span class="n">body</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">&#39;</span><span class="n">a</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">seq</span><span class="o">&lt;</span><span class="k">&#39;</span><span class="n">b</span><span class="o">&gt;)</span><span class="w"> </span><span class="o">=</span>
<span class="w">        </span><span class="n">seq</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">source</span><span class="w"> </span><span class="k">do</span><span class="w"> </span><span class="k">yield</span><span class="o">!</span><span class="w"> </span><span class="n">body</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">}</span>
<span class="w">    </span><span class="k">member</span><span class="w"> </span><span class="n">__</span><span class="p">.</span><span class="nf">Yield</span><span class="w"> </span><span class="o">(</span><span class="n">item</span><span class="o">:</span><span class="k">&#39;</span><span class="n">a</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">seq</span><span class="o">&lt;</span><span class="k">&#39;</span><span class="n">a</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">seq</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="k">yield</span><span class="w"> </span><span class="n">item</span><span class="w"> </span><span class="o">}</span>
<span class="w">    </span><span class="o">[&lt;</span><span class="n">CustomOperation</span><span class="o">(</span><span class="s">&quot;where&quot;</span><span class="o">)&gt;]</span>
<span class="w">    </span><span class="k">member</span><span class="w"> </span><span class="n">__</span><span class="p">.</span><span class="nf">Where</span><span class="w"> </span><span class="o">(</span><span class="n">source</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">seq</span><span class="o">&lt;</span><span class="k">&#39;</span><span class="n">a</span><span class="o">&gt;,</span><span class="w"> </span><span class="n">f</span><span class="o">:</span><span class="w"> </span><span class="k">&#39;</span><span class="n">a</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">bool</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">seq</span><span class="o">&lt;</span><span class="k">&#39;</span><span class="n">a</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nn">Seq</span><span class="p">.</span><span class="n">filter</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">source</span>

<span class="k">let</span><span class="w"> </span><span class="nv">myseq</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SimpleSequenceBuilder</span><span class="bp">()</span>
</code></pre></div>
<p>Then, the expression</p>
<div class="highlight"><pre><span></span><code><span class="n">myseq</span><span class="w"> </span><span class="o">{</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">..</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="k">do</span>
<span class="w">    </span><span class="n">where</span><span class="w"> </span><span class="o">(</span><span class="k">fun</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">5</span><span class="o">)</span>
<span class="w">    </span><span class="o">}</span>
</code></pre></div>
<p>translates to</p>
<div class="highlight"><pre><span></span><code><span class="k">let</span><span class="w"> </span><span class="nv">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">myseq</span>
<span class="w">    </span><span class="n">b</span><span class="o">.</span><span class="n">Where</span><span class="o">(</span>
<span class="w">        </span><span class="n">b</span><span class="o">.</span><span class="n">For</span><span class="o">([</span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="o">],</span><span class="w"> </span><span class="k">fun</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">-&gt;</span>
<span class="w">            </span><span class="n">b</span><span class="o">.</span><span class="n">Yield</span><span class="w"> </span><span class="o">(</span><span class="n">i</span><span class="o">)),</span>
<span class="w">        </span><span class="k">fun</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">5</span><span class="o">)</span>
</code></pre></div>
<p><code>ProjectionParameterAttribute</code> automatically adds a parameter from the variable space of the
computation expression. For example, <code>ProjectionParameterAttribute</code> can be attached to the second
argument of the <code>where</code> operator:</p>
<div class="highlight"><pre><span></span><code><span class="k">type</span><span class="w"> </span><span class="nc">SimpleSequenceBuilder</span><span class="bp">()</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="k">member</span><span class="w"> </span><span class="n">__</span><span class="p">.</span><span class="nf">For</span><span class="w"> </span><span class="o">(</span><span class="n">source</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">seq</span><span class="o">&lt;</span><span class="k">&#39;</span><span class="n">a</span><span class="o">&gt;,</span><span class="w"> </span><span class="n">body</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">&#39;</span><span class="n">a</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">seq</span><span class="o">&lt;</span><span class="k">&#39;</span><span class="n">b</span><span class="o">&gt;)</span><span class="w"> </span><span class="o">=</span>
<span class="w">        </span><span class="n">seq</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">source</span><span class="w"> </span><span class="k">do</span><span class="w"> </span><span class="k">yield</span><span class="o">!</span><span class="w"> </span><span class="n">body</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">}</span>
<span class="w">    </span><span class="k">member</span><span class="w"> </span><span class="n">__</span><span class="p">.</span><span class="nf">Yield</span><span class="w"> </span><span class="o">(</span><span class="n">item</span><span class="o">:</span><span class="k">&#39;</span><span class="n">a</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">seq</span><span class="o">&lt;</span><span class="k">&#39;</span><span class="n">a</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">seq</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="k">yield</span><span class="w"> </span><span class="n">item</span><span class="w"> </span><span class="o">}</span>
<span class="w">    </span><span class="o">[&lt;</span><span class="n">CustomOperation</span><span class="o">(</span><span class="s">&quot;where&quot;</span><span class="o">)&gt;]</span>
<span class="w">    </span><span class="k">member</span><span class="w"> </span><span class="n">__</span><span class="p">.</span><span class="nf">Where</span><span class="w"> </span><span class="o">(</span><span class="n">source</span><span class="o">:</span><span class="w"> </span><span class="n">seq</span><span class="o">&lt;</span><span class="k">&#39;</span><span class="n">a</span><span class="o">&gt;,</span><span class="w"> </span><span class="o">[&lt;</span><span class="n">ProjectionParameter</span><span class="o">&gt;]</span><span class="n">f</span><span class="o">:</span><span class="w"> </span><span class="k">&#39;</span><span class="n">a</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">bool</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">seq</span><span class="o">&lt;</span><span class="k">&#39;</span><span class="n">a</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span>
<span class="w">        </span><span class="nn">Seq</span><span class="p">.</span><span class="n">filter</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">source</span>

<span class="k">let</span><span class="w"> </span><span class="nv">myseq</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SimpleSequenceBuilder</span><span class="bp">()</span>
</code></pre></div>
<p>Then, the expression</p>
<div class="highlight"><pre><span></span><code><span class="n">myseq</span><span class="w"> </span><span class="o">{</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">..</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="k">do</span>
<span class="w">    </span><span class="n">where</span><span class="w"> </span><span class="o">(</span><span class="n">i</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">5</span><span class="o">)</span>
<span class="w">    </span><span class="o">}</span>
</code></pre></div>
<p>translates to</p>
<div class="highlight"><pre><span></span><code><span class="k">let</span><span class="w"> </span><span class="nv">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">myseq</span>
<span class="n">b</span><span class="o">.</span><span class="n">Where</span><span class="o">(</span>
<span class="w">    </span><span class="n">b</span><span class="o">.</span><span class="n">For</span><span class="o">([</span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="o">],</span><span class="w"> </span><span class="k">fun</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">-&gt;</span>
<span class="w">        </span><span class="n">b</span><span class="o">.</span><span class="n">Yield</span><span class="w"> </span><span class="o">(</span><span class="n">i</span><span class="o">)),</span>
<span class="w">    </span><span class="k">fun</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">5</span><span class="o">)</span>
</code></pre></div>
<p><code>ProjectionParameterAttribute</code> is useful when a let binding appears between <code>ForEach</code> and the
custom operators. For example, the expression</p>
<div class="highlight"><pre><span></span><code><span class="n">myseq</span><span class="w"> </span><span class="o">{</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">..</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="k">do</span>
<span class="w">    </span><span class="k">let</span><span class="w"> </span><span class="nv">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">i</span>
<span class="w">    </span><span class="n">where</span><span class="w"> </span><span class="o">(</span><span class="n">i</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">49</span><span class="o">)</span>
<span class="w">    </span><span class="o">}</span>
</code></pre></div>
<p>translates to</p>
<div class="highlight"><pre><span></span><code><span class="k">let</span><span class="w"> </span><span class="nv">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">myseq</span>
<span class="n">b</span><span class="o">.</span><span class="n">Where</span><span class="o">(</span>
<span class="w">    </span><span class="n">b</span><span class="o">.</span><span class="n">For</span><span class="o">([</span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="o">],</span><span class="w"> </span><span class="k">fun</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">-&gt;</span>
<span class="w">        </span><span class="k">let</span><span class="w"> </span><span class="nv">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">i</span>
<span class="w">        </span><span class="n">b</span><span class="o">.</span><span class="n">Yield</span><span class="w"> </span><span class="o">(</span><span class="n">i</span><span class="o">,</span><span class="n">j</span><span class="o">)),</span>
<span class="w">    </span><span class="k">fun</span><span class="w"> </span><span class="o">(</span><span class="n">i</span><span class="o">,</span><span class="n">j</span><span class="o">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">49</span><span class="o">)</span>
</code></pre></div>
<p>Without <code>ProjectionParameterAttribute</code>, a user would be required to write “<code>fun (i,j) -&gt;</code>” explicitly.</p>
<p>Now, assume that we want to write the condition “<code>where (i &gt; 5 &amp;&amp; j &lt; 49)</code>” in the following
syntax:</p>
<div class="highlight"><pre><span></span><code><span class="n">where</span><span class="w"> </span><span class="o">(</span><span class="n">i</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">5</span><span class="o">)</span>
<span class="n">where</span><span class="w"> </span><span class="o">(</span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">49</span><span class="o">)</span>
</code></pre></div>
<p>To support this style, the <code>where</code> custom operator should produce a computation that has the same
variable space as the input computation. That is, <code>j</code> should be available in the second <code>where</code>. The
following example uses the <code>MaintainsVariableSpace</code> property on the custom operator to specify this
behavior:</p>
<div class="highlight"><pre><span></span><code><span class="k">type</span><span class="w"> </span><span class="nc">SimpleSequenceBuilder</span><span class="bp">()</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="k">member</span><span class="w"> </span><span class="n">__</span><span class="p">.</span><span class="nf">For</span><span class="w"> </span><span class="o">(</span><span class="n">source</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">seq</span><span class="o">&lt;</span><span class="k">&#39;</span><span class="n">a</span><span class="o">&gt;,</span><span class="w"> </span><span class="n">body</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">&#39;</span><span class="n">a</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">seq</span><span class="o">&lt;</span><span class="k">&#39;</span><span class="n">b</span><span class="o">&gt;)</span><span class="w"> </span><span class="o">=</span>
<span class="w">        </span><span class="n">seq</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">source</span><span class="w"> </span><span class="k">do</span><span class="w"> </span><span class="k">yield</span><span class="o">!</span><span class="w"> </span><span class="n">body</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">}</span>
<span class="w">    </span><span class="k">member</span><span class="w"> </span><span class="n">__</span><span class="p">.</span><span class="nf">Yield</span><span class="w"> </span><span class="o">(</span><span class="n">item</span><span class="o">:</span><span class="k">&#39;</span><span class="n">a</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">seq</span><span class="o">&lt;</span><span class="k">&#39;</span><span class="n">a</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">seq</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="k">yield</span><span class="w"> </span><span class="n">item</span><span class="w"> </span><span class="o">}</span>
<span class="w">    </span><span class="o">[&lt;</span><span class="n">CustomOperation</span><span class="o">(</span><span class="s">&quot;where&quot;</span><span class="o">,</span><span class="w"> </span><span class="n">MaintainsVariableSpace</span><span class="o">=</span><span class="k">true</span><span class="o">)&gt;]</span>
<span class="w">    </span><span class="k">member</span><span class="w"> </span><span class="n">__</span><span class="p">.</span><span class="nf">Where</span><span class="w"> </span><span class="o">(</span><span class="n">source</span><span class="o">:</span><span class="w"> </span><span class="n">seq</span><span class="o">&lt;</span><span class="k">&#39;</span><span class="n">a</span><span class="o">&gt;,</span><span class="w"> </span><span class="o">[&lt;</span><span class="n">ProjectionParameter</span><span class="o">&gt;]</span><span class="n">f</span><span class="o">:</span><span class="w"> </span><span class="k">&#39;</span><span class="n">a</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">bool</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">seq</span><span class="o">&lt;</span><span class="k">&#39;</span><span class="n">a</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span>
<span class="w">        </span><span class="nn">Seq</span><span class="p">.</span><span class="n">filter</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">source</span>

<span class="k">let</span><span class="w"> </span><span class="nv">myseq</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SimpleSequenceBuilder</span><span class="bp">()</span>
</code></pre></div>
<p>Then, the expression</p>
<div class="highlight"><pre><span></span><code><span class="n">myseq</span><span class="w"> </span><span class="o">{</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">..</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="k">do</span>
<span class="w">    </span><span class="k">let</span><span class="w"> </span><span class="nv">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">i</span>
<span class="w">    </span><span class="n">where</span><span class="w"> </span><span class="o">(</span><span class="n">i</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">5</span><span class="o">)</span>
<span class="w">    </span><span class="n">where</span><span class="w"> </span><span class="o">(</span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">49</span><span class="o">)</span>
<span class="w">    </span><span class="o">}</span>
</code></pre></div>
<p>translates to</p>
<div class="highlight"><pre><span></span><code><span class="k">let</span><span class="w"> </span><span class="nv">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">myseq</span>
<span class="n">b</span><span class="o">.</span><span class="n">Where</span><span class="o">(</span>
<span class="w">    </span><span class="n">b</span><span class="o">.</span><span class="n">Where</span><span class="o">(</span>
<span class="w">        </span><span class="n">b</span><span class="o">.</span><span class="n">For</span><span class="o">([</span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="o">],</span><span class="w"> </span><span class="k">fun</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">-&gt;</span>
<span class="w">            </span><span class="k">let</span><span class="w"> </span><span class="nv">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">i</span>
<span class="w">            </span><span class="n">b</span><span class="o">.</span><span class="n">Yield</span><span class="w"> </span><span class="o">(</span><span class="n">i</span><span class="o">,</span><span class="n">j</span><span class="o">)),</span>
<span class="w">        </span><span class="k">fun</span><span class="w"> </span><span class="o">(</span><span class="n">i</span><span class="o">,</span><span class="n">j</span><span class="o">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">5</span><span class="o">),</span>
<span class="w">    </span><span class="k">fun</span><span class="w"> </span><span class="o">(</span><span class="n">i</span><span class="o">,</span><span class="n">j</span><span class="o">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">49</span><span class="o">)</span>
</code></pre></div>
<p>When we may not want to produce the variable space but rather want to explicitly express the chain
of the <code>where</code> operator, we can design this simple sequence builder in a slightly different way. For
example, we can express the same expression in the following way:</p>
<div class="highlight"><pre><span></span><code><span class="n">myseq</span><span class="w"> </span><span class="o">{</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">..</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="k">do</span>
<span class="w">    </span><span class="n">where</span><span class="w"> </span><span class="o">(</span><span class="n">i</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">5</span><span class="o">)</span><span class="w"> </span><span class="n">into</span><span class="w"> </span><span class="n">j</span>
<span class="w">    </span><span class="n">where</span><span class="w"> </span><span class="o">(</span><span class="n">j</span><span class="o">*</span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">49</span><span class="o">)</span>
<span class="w">    </span><span class="o">}</span>
</code></pre></div>
<p>In this example, instead of having a let-binding (for <code>j</code> in the previous example) and passing variable
space (including <code>j</code>) down to the chain, we can introduce a special syntax that captures a value into a
pattern variable and passes only this variable down to the chain, which is arguably more readable.
For this case, <code>AllowIntoPattern</code> allows the custom operation to have an <code>into</code> syntax:</p>
<div class="highlight"><pre><span></span><code><span class="k">type</span><span class="w"> </span><span class="nc">SimpleSequenceBuilder</span><span class="bp">()</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="k">member</span><span class="w"> </span><span class="n">__</span><span class="p">.</span><span class="nf">For</span><span class="w"> </span><span class="o">(</span><span class="n">source</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">seq</span><span class="o">&lt;</span><span class="k">&#39;</span><span class="n">a</span><span class="o">&gt;,</span><span class="w"> </span><span class="n">body</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">&#39;</span><span class="n">a</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">seq</span><span class="o">&lt;</span><span class="k">&#39;</span><span class="n">b</span><span class="o">&gt;)</span><span class="w"> </span><span class="o">=</span>
<span class="w">        </span><span class="n">seq</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">source</span><span class="w"> </span><span class="k">do</span><span class="w"> </span><span class="k">yield</span><span class="o">!</span><span class="w"> </span><span class="n">body</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">}</span>
<span class="w">    </span><span class="k">member</span><span class="w"> </span><span class="n">__</span><span class="p">.</span><span class="nf">Yield</span><span class="w"> </span><span class="o">(</span><span class="n">item</span><span class="o">:</span><span class="k">&#39;</span><span class="n">a</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">seq</span><span class="o">&lt;</span><span class="k">&#39;</span><span class="n">a</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">seq</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="k">yield</span><span class="w"> </span><span class="n">item</span><span class="w"> </span><span class="o">}</span>

<span class="w">    </span><span class="o">[&lt;</span><span class="n">CustomOperation</span><span class="o">(</span><span class="s">&quot;where&quot;</span><span class="o">,</span><span class="w"> </span><span class="n">AllowIntoPattern</span><span class="o">=</span><span class="k">true</span><span class="o">)&gt;]</span>
<span class="w">    </span><span class="k">member</span><span class="w"> </span><span class="n">__</span><span class="p">.</span><span class="nf">Where</span><span class="w"> </span><span class="o">(</span><span class="n">source</span><span class="o">:</span><span class="w"> </span><span class="n">seq</span><span class="o">&lt;</span><span class="k">&#39;</span><span class="n">a</span><span class="o">&gt;,</span><span class="w"> </span><span class="o">[&lt;</span><span class="n">ProjectionParameter</span><span class="o">&gt;]</span><span class="n">f</span><span class="o">:</span><span class="w"> </span><span class="k">&#39;</span><span class="n">a</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">bool</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">seq</span><span class="o">&lt;</span><span class="k">&#39;</span><span class="n">a</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span>
<span class="w">        </span><span class="nn">Seq</span><span class="p">.</span><span class="n">filter</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">source</span>

<span class="k">let</span><span class="w"> </span><span class="nv">myseq</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SimpleSequenceBuilder</span><span class="bp">()</span>
</code></pre></div>
<p>Then, the expression</p>
<div class="highlight"><pre><span></span><code><span class="n">myseq</span><span class="w"> </span><span class="o">{</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">..</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="k">do</span>
<span class="w">    </span><span class="n">where</span><span class="w"> </span><span class="o">(</span><span class="n">i</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">5</span><span class="o">)</span><span class="w"> </span><span class="n">into</span><span class="w"> </span><span class="n">j</span>
<span class="w">    </span><span class="n">where</span><span class="w"> </span><span class="o">(</span><span class="n">j</span><span class="o">*</span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">49</span><span class="o">)</span>
<span class="w">    </span><span class="o">}</span>
</code></pre></div>
<p>translates to</p>
<div class="highlight"><pre><span></span><code><span class="k">let</span><span class="w"> </span><span class="nv">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">myseq</span>
<span class="n">b</span><span class="o">.</span><span class="n">Where</span><span class="o">(</span>
<span class="w">    </span><span class="n">b</span><span class="o">.</span><span class="n">For</span><span class="o">(</span>
<span class="w">        </span><span class="n">b</span><span class="o">.</span><span class="n">Where</span><span class="o">(</span>
<span class="w">            </span><span class="n">b</span><span class="o">.</span><span class="n">For</span><span class="o">([</span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="o">],</span><span class="w"> </span><span class="k">fun</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">b</span><span class="o">.</span><span class="n">Yield</span><span class="w"> </span><span class="o">(</span><span class="n">i</span><span class="o">))</span>
<span class="w">            </span><span class="k">fun</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">i</span><span class="o">&gt;</span><span class="mi">5</span><span class="o">),</span>
<span class="w">        </span><span class="k">fun</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">b</span><span class="o">.</span><span class="n">Yield</span><span class="w"> </span><span class="o">(</span><span class="n">j</span><span class="o">)),</span>
<span class="w">    </span><span class="k">fun</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">j</span><span class="o">*</span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">49</span><span class="o">)</span>
</code></pre></div>
<p>Note that the <code>into</code> keyword is not customizable, unlike <code>join</code> and <code>on</code>.</p>
<p>In addition to <code>MaintainsVariableSpace</code>, <code>MaintainsVariableSpaceUsingBind</code> is provided to pass
variable space down to the chain in a different way. For example:</p>
<div class="highlight"><pre><span></span><code><span class="k">type</span><span class="w"> </span><span class="nc">SimpleSequenceBuilder</span><span class="bp">()</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="k">member</span><span class="w"> </span><span class="n">__</span><span class="p">.</span><span class="nf">For</span><span class="w"> </span><span class="o">(</span><span class="n">source</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">seq</span><span class="o">&lt;</span><span class="k">&#39;</span><span class="n">a</span><span class="o">&gt;,</span><span class="w"> </span><span class="n">body</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">&#39;</span><span class="n">a</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">seq</span><span class="o">&lt;</span><span class="k">&#39;</span><span class="n">b</span><span class="o">&gt;)</span><span class="w"> </span><span class="o">=</span>
<span class="w">        </span><span class="n">seq</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">source</span><span class="w"> </span><span class="k">do</span><span class="w"> </span><span class="k">yield</span><span class="o">!</span><span class="w"> </span><span class="n">body</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">}</span>
<span class="w">    </span><span class="k">member</span><span class="w"> </span><span class="n">__</span><span class="p">.</span><span class="nf">Return</span><span class="w"> </span><span class="o">(</span><span class="n">item</span><span class="o">:</span><span class="k">&#39;</span><span class="n">a</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">seq</span><span class="o">&lt;</span><span class="k">&#39;</span><span class="n">a</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">seq</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="k">yield</span><span class="w"> </span><span class="n">item</span><span class="w"> </span><span class="o">}</span>
<span class="w">    </span><span class="k">member</span><span class="w"> </span><span class="n">__</span><span class="p">.</span><span class="nf">Bind</span><span class="w"> </span><span class="o">(</span><span class="n">value</span><span class="w"> </span><span class="o">,</span><span class="w"> </span><span class="n">cont</span><span class="o">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cont</span><span class="w"> </span><span class="n">value</span>
<span class="w">    </span><span class="o">[&lt;</span><span class="n">CustomOperation</span><span class="o">(</span><span class="s">&quot;where&quot;</span><span class="o">,</span><span class="w"> </span><span class="n">MaintainsVariableSpaceUsingBind</span><span class="o">=</span><span class="k">true</span><span class="o">,</span><span class="w"> </span><span class="n">AllowIntoPattern</span><span class="o">=</span><span class="k">true</span><span class="o">)&gt;]</span>
<span class="w">    </span><span class="k">member</span><span class="w"> </span><span class="n">__</span><span class="p">.</span><span class="nf">Where</span><span class="w"> </span><span class="o">(</span><span class="n">source</span><span class="o">:</span><span class="w"> </span><span class="n">seq</span><span class="o">&lt;</span><span class="k">&#39;</span><span class="n">a</span><span class="o">&gt;,</span><span class="w"> </span><span class="o">[&lt;</span><span class="n">ProjectionParameter</span><span class="o">&gt;]</span><span class="n">f</span><span class="o">:</span><span class="w"> </span><span class="k">&#39;</span><span class="n">a</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">bool</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">seq</span><span class="o">&lt;</span><span class="k">&#39;</span><span class="n">a</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span>
<span class="w">        </span><span class="nn">Seq</span><span class="p">.</span><span class="n">filter</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">source</span>

<span class="k">let</span><span class="w"> </span><span class="nv">myseq</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SimpleSequenceBuilder</span><span class="bp">()</span>
</code></pre></div>
<p>The presence of <code>MaintainsVariableSpaceUsingBindAttribute</code> requires <code>Return</code> and <code>Bind</code> methods
during the translation.</p>
<p>Then, the expression</p>
<div class="highlight"><pre><span></span><code><span class="n">myseq</span><span class="w"> </span><span class="o">{</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">..</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="k">do</span>
<span class="w">    </span><span class="n">where</span><span class="w"> </span><span class="o">(</span><span class="n">i</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">i</span><span class="o">*</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">49</span><span class="o">)</span><span class="w"> </span><span class="n">into</span><span class="w"> </span><span class="n">j</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">j</span>
<span class="w">    </span><span class="o">}</span>
</code></pre></div>
<p>translates to</p>
<div class="highlight"><pre><span></span><code><span class="k">let</span><span class="w"> </span><span class="nv">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">myseq</span>
<span class="n">b</span><span class="o">.</span><span class="n">Bind</span><span class="o">(</span>
<span class="w">    </span><span class="n">b</span><span class="o">.</span><span class="n">Where</span><span class="o">(</span><span class="nn">B</span><span class="p">.</span><span class="n">For</span><span class="o">([</span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="o">],</span><span class="w"> </span><span class="k">fun</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">b</span><span class="o">.</span><span class="n">Return</span><span class="w"> </span><span class="o">(</span><span class="n">i</span><span class="o">)),</span>
<span class="w">        </span><span class="k">fun</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">i</span><span class="o">*</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">49</span><span class="o">),</span>
<span class="w">    </span><span class="k">fun</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">b</span><span class="o">.</span><span class="n">Return</span><span class="w"> </span><span class="o">(</span><span class="n">j</span><span class="o">))</span>
</code></pre></div>
<p>where <code>Bind</code> is called to capture the pattern variable <code>j</code>. Note that <code>For</code> and <code>Yield</code> are called to capture
the pattern variable when <code>MaintainsVariableSpace</code> is used.</p>
<p>Certain properties on the <code>CustomOperationAttribute</code> introduce join-like operators. The following
example shows how to use the <code>IsLikeJoin</code> property.</p>
<div class="highlight"><pre><span></span><code><span class="k">type</span><span class="w"> </span><span class="nc">SimpleSequenceBuilder</span><span class="bp">()</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="k">member</span><span class="w"> </span><span class="n">__</span><span class="p">.</span><span class="nf">For</span><span class="w"> </span><span class="o">(</span><span class="n">source</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">seq</span><span class="o">&lt;</span><span class="k">&#39;</span><span class="n">a</span><span class="o">&gt;,</span><span class="w"> </span><span class="n">body</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">&#39;</span><span class="n">a</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">seq</span><span class="o">&lt;</span><span class="k">&#39;</span><span class="n">b</span><span class="o">&gt;)</span><span class="w"> </span><span class="o">=</span>
<span class="w">        </span><span class="n">seq</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">source</span><span class="w"> </span><span class="k">do</span><span class="w"> </span><span class="k">yield</span><span class="o">!</span><span class="w"> </span><span class="n">body</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">}</span>
<span class="w">    </span><span class="k">member</span><span class="w"> </span><span class="n">__</span><span class="p">.</span><span class="nf">Yield</span><span class="w"> </span><span class="o">(</span><span class="n">item</span><span class="o">:</span><span class="k">&#39;</span><span class="n">a</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">seq</span><span class="o">&lt;</span><span class="k">&#39;</span><span class="n">a</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">seq</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="k">yield</span><span class="w"> </span><span class="n">item</span><span class="w"> </span><span class="o">}</span>
<span class="w">    </span><span class="o">[&lt;</span><span class="n">CustomOperation</span><span class="o">(</span><span class="s">&quot;merge&quot;</span><span class="o">,</span><span class="w"> </span><span class="n">IsLikeJoin</span><span class="o">=</span><span class="k">true</span><span class="o">,</span><span class="w"> </span><span class="n">JoinConditionWord</span><span class="o">=</span><span class="s">&quot;whenever&quot;</span><span class="o">)&gt;]</span>
<span class="w">    </span><span class="k">member</span><span class="w"> </span><span class="n">__</span><span class="p">.</span><span class="nf">Merge</span><span class="w"> </span><span class="o">(</span><span class="n">src1</span><span class="o">:</span><span class="n">seq</span><span class="o">&lt;</span><span class="k">&#39;</span><span class="n">a</span><span class="o">&gt;,</span><span class="w"> </span><span class="n">src2</span><span class="o">:</span><span class="n">seq</span><span class="o">&lt;</span><span class="k">&#39;</span><span class="n">a</span><span class="o">&gt;,</span><span class="w"> </span><span class="n">ks1</span><span class="o">,</span><span class="w"> </span><span class="n">ks2</span><span class="o">,</span><span class="w"> </span><span class="n">ret</span><span class="o">)</span><span class="w"> </span><span class="o">=</span>
<span class="w">        </span><span class="n">seq</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">src1</span><span class="w"> </span><span class="k">do</span>
<span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">src2</span><span class="w"> </span><span class="k">do</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="n">ks1</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ks2</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="k">then</span><span class="w"> </span><span class="k">yield</span><span class="o">((</span><span class="n">ret</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">)</span><span class="w"> </span><span class="n">b</span><span class="o">)</span>
<span class="w">        </span><span class="o">}</span>

<span class="k">let</span><span class="w"> </span><span class="nv">myseq</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SimpleSequenceBuilder</span><span class="bp">()</span>
</code></pre></div>
<p><code>IsLikeJoin</code> indicates that the custom operation is similar to a join in a sequence computation; that
is, it supports two inputs and a correlation constraint.</p>
<p>The expression</p>
<div class="highlight"><pre><span></span><code><span class="n">myseq</span><span class="w"> </span><span class="o">{</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">..</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="k">do</span>
<span class="w">    </span><span class="n">merge</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="o">[</span><span class="mi">5</span><span class="w"> </span><span class="o">..</span><span class="w"> </span><span class="mi">15</span><span class="o">]</span><span class="w"> </span><span class="n">whenever</span><span class="w"> </span><span class="o">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">j</span><span class="o">)</span>
<span class="w">    </span><span class="k">yield</span><span class="w"> </span><span class="n">j</span>
<span class="w">    </span><span class="o">}</span>
</code></pre></div>
<p>translates to</p>
<div class="highlight"><pre><span></span><code><span class="k">let</span><span class="w"> </span><span class="nv">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">myseq</span>
<span class="n">b</span><span class="o">.</span><span class="n">For</span><span class="o">(</span>
<span class="w">    </span><span class="n">b</span><span class="o">.</span><span class="n">Merge</span><span class="o">([</span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="o">],</span><span class="w"> </span><span class="o">[</span><span class="mi">5</span><span class="o">..</span><span class="mi">15</span><span class="o">],</span>
<span class="w">            </span><span class="k">fun</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">i</span><span class="o">,</span><span class="w"> </span><span class="k">fun</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">j</span><span class="o">,</span>
<span class="w">            </span><span class="k">fun</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="k">fun</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="o">(</span><span class="n">i</span><span class="o">,</span><span class="n">j</span><span class="o">)),</span>
<span class="w">    </span><span class="k">fun</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">b</span><span class="o">.</span><span class="n">Yield</span><span class="w"> </span><span class="o">(</span><span class="n">j</span><span class="o">))</span>
</code></pre></div>
<p>This translation implicitly places type constraints on the expected form of the builder methods. For
example, for the <code>async</code> builder found in the <code>FSharp.Control</code> library, the translation phase
corresponds to implementing a builder of a type that has the following member signatures:</p>
<div class="highlight"><pre><span></span><code><span class="k">type</span><span class="w"> </span><span class="nc">AsyncBuilder</span><span class="w"> </span><span class="k">with</span>
<span class="w">    </span><span class="k">member</span><span class="w"> </span><span class="n">For</span><span class="o">:</span><span class="w"> </span><span class="n">seq</span><span class="o">&lt;</span><span class="k">&#39;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="o">(</span><span class="k">&#39;</span><span class="n">T</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">Async</span><span class="o">&lt;</span><span class="kt">unit</span><span class="o">&gt;)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">Async</span><span class="o">&lt;</span><span class="kt">unit</span><span class="o">&gt;</span>
<span class="w">    </span><span class="k">member</span><span class="w"> </span><span class="n">Zero</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">unit</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">Async</span><span class="o">&lt;</span><span class="kt">unit</span><span class="o">&gt;</span>
<span class="w">    </span><span class="k">member</span><span class="w"> </span><span class="n">Combine</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">Async</span><span class="o">&lt;</span><span class="kt">unit</span><span class="o">&gt;</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">Async</span><span class="o">&lt;</span><span class="k">&#39;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">Async</span><span class="o">&lt;</span><span class="k">&#39;</span><span class="n">T</span><span class="o">&gt;</span>
<span class="w">    </span><span class="k">member</span><span class="w"> </span><span class="n">While</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="o">(</span><span class="kt">unit</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">bool</span><span class="o">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">Async</span><span class="o">&lt;</span><span class="kt">unit</span><span class="o">&gt;</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">Async</span><span class="o">&lt;</span><span class="kt">unit</span><span class="o">&gt;</span>
<span class="w">    </span><span class="k">member</span><span class="w"> </span><span class="n">Return</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">&#39;</span><span class="n">T</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">Async</span><span class="o">&lt;</span><span class="k">&#39;</span><span class="n">T</span><span class="o">&gt;</span>
<span class="w">    </span><span class="k">member</span><span class="w"> </span><span class="n">Delay</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="o">(</span><span class="kt">unit</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">Async</span><span class="o">&lt;</span><span class="k">&#39;</span><span class="n">T</span><span class="o">&gt;)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">Async</span><span class="o">&lt;</span><span class="k">&#39;</span><span class="n">T</span><span class="o">&gt;</span>
<span class="w">    </span><span class="k">member</span><span class="w"> </span><span class="n">Using</span><span class="o">:</span><span class="w"> </span><span class="k">&#39;</span><span class="n">T</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="o">(</span><span class="k">&#39;</span><span class="n">T</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">Async</span><span class="o">&lt;</span><span class="k">&#39;</span><span class="n">U</span><span class="o">&gt;)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">Async</span><span class="o">&lt;</span><span class="k">&#39;</span><span class="n">U</span><span class="o">&gt;</span>
<span class="w">        </span><span class="k">when</span><span class="w"> </span><span class="k">&#39;</span><span class="n">U</span><span class="w"> </span><span class="o">:&gt;</span><span class="w"> </span><span class="nn">System</span><span class="p">.</span><span class="n">IDisposable</span>
<span class="w">    </span><span class="k">member</span><span class="w"> </span><span class="n">Bind</span><span class="o">:</span><span class="w"> </span><span class="n">Async</span><span class="o">&lt;</span><span class="k">&#39;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="o">(</span><span class="k">&#39;</span><span class="n">T</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">Async</span><span class="o">&lt;</span><span class="k">&#39;</span><span class="n">U</span><span class="o">&gt;)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">Async</span><span class="o">&lt;</span><span class="k">&#39;</span><span class="n">U</span><span class="o">&gt;</span>
<span class="w">    </span><span class="k">member</span><span class="w"> </span><span class="n">TryFinally</span><span class="o">:</span><span class="w"> </span><span class="n">Async</span><span class="o">&lt;</span><span class="k">&#39;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="o">(</span><span class="kt">unit</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">unit</span><span class="o">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">Async</span><span class="o">&lt;</span><span class="k">&#39;</span><span class="n">T</span><span class="o">&gt;</span>
<span class="w">    </span><span class="k">member</span><span class="w"> </span><span class="n">TryWith</span><span class="o">:</span><span class="w"> </span><span class="n">Async</span><span class="o">&lt;</span><span class="k">&#39;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="o">(</span><span class="kt">exn</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">Async</span><span class="o">&lt;</span><span class="k">&#39;</span><span class="n">T</span><span class="o">&gt;)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">Async</span><span class="o">&lt;</span><span class="k">&#39;</span><span class="n">T</span><span class="o">&gt;</span>
</code></pre></div>
<p>The following example shows a common approach to implementing a new computation expression
builder for a monad. The example uses computation expressions to define computations that can be
partially run by executing them step-by-step, for example, up to a time limit.</p>
<div class="highlight"><pre><span></span><code><span class="sd">/// Computations that can cooperatively yield by returning a continuation</span>
<span class="k">type</span><span class="w"> </span><span class="nc">Eventually</span><span class="o">&lt;</span><span class="k">&#39;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="o">|</span><span class="w"> </span><span class="n">Done</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="k">&#39;</span><span class="n">T</span>
<span class="w">    </span><span class="o">|</span><span class="w"> </span><span class="n">NotYetDone</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="o">(</span><span class="kt">unit</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">Eventually</span><span class="o">&lt;</span><span class="k">&#39;</span><span class="n">T</span><span class="o">&gt;)</span>

<span class="o">[&lt;</span><span class="n">CompilationRepresentation</span><span class="o">(</span><span class="nn">CompilationRepresentationFlags</span><span class="p">.</span><span class="n">ModuleSuffix</span><span class="o">)&gt;]</span>
<span class="k">module</span><span class="w"> </span><span class="nn">Eventually</span><span class="w"> </span><span class="o">=</span>

<span class="w">    </span><span class="sd">/// The bind for the computations. Stitch &#39;k&#39; on to the end of the computation.</span>
<span class="w">    </span><span class="sd">/// Note combinators like this are usually written in the reverse way,</span>
<span class="w">    </span><span class="sd">/// for example,</span>
<span class="w">    </span><span class="sd">/// e |&gt; bind k</span>
<span class="w">    </span><span class="k">let</span><span class="w"> </span><span class="nv">rec</span><span class="w"> </span><span class="n">bind</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="o">=</span>
<span class="w">        </span><span class="k">match</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="k">with</span>
<span class="w">        </span><span class="o">|</span><span class="w"> </span><span class="n">Done</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">NotYetDone</span><span class="w"> </span><span class="o">(</span><span class="k">fun</span><span class="w"> </span><span class="bp">()</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">x</span><span class="o">)</span>
<span class="w">        </span><span class="o">|</span><span class="w"> </span><span class="n">NotYetDone</span><span class="w"> </span><span class="n">work</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">NotYetDone</span><span class="w"> </span><span class="o">(</span><span class="k">fun</span><span class="w"> </span><span class="bp">()</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">bind</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">(</span><span class="n">work</span><span class="bp">()</span><span class="o">))</span>

<span class="w">    </span><span class="sd">/// The return for the computations.</span>
<span class="w">    </span><span class="k">let</span><span class="w"> </span><span class="nv">result</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Done</span><span class="w"> </span><span class="n">x</span>

<span class="w">    </span><span class="k">type</span><span class="w"> </span><span class="nc">OkOrException</span><span class="o">&lt;</span><span class="k">&#39;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span>
<span class="w">        </span><span class="o">|</span><span class="w"> </span><span class="n">Ok</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="k">&#39;</span><span class="n">T</span>
<span class="w">        </span><span class="o">|</span><span class="w"> </span><span class="n">Exception</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="nn">System</span><span class="p">.</span><span class="n">Exception</span>

<span class="w">    </span><span class="sd">/// The catch for the computations. Stitch try/with throughout</span>
<span class="w">    </span><span class="sd">/// the computation and return the overall result as an OkOrException.</span>
<span class="w">    </span><span class="k">let</span><span class="w"> </span><span class="nv">rec</span><span class="w"> </span><span class="n">catch</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="o">=</span>
<span class="w">        </span><span class="k">match</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="k">with</span>
<span class="w">        </span><span class="o">|</span><span class="w"> </span><span class="n">Done</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">(</span><span class="n">Ok</span><span class="w"> </span><span class="n">x</span><span class="o">)</span>
<span class="w">        </span><span class="o">|</span><span class="w"> </span><span class="n">NotYetDone</span><span class="w"> </span><span class="n">work</span><span class="w"> </span><span class="o">-&gt;</span>
<span class="w">            </span><span class="n">NotYetDone</span><span class="w"> </span><span class="o">(</span><span class="k">fun</span><span class="w"> </span><span class="bp">()</span><span class="w"> </span><span class="o">-&gt;</span>
<span class="w">                </span><span class="k">let</span><span class="w"> </span><span class="nv">res</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">try</span><span class="w"> </span><span class="n">Ok</span><span class="o">(</span><span class="n">work</span><span class="bp">()</span><span class="o">)</span><span class="w"> </span><span class="k">with</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">Exception</span><span class="w"> </span><span class="n">e</span>
<span class="w">                </span><span class="k">match</span><span class="w"> </span><span class="n">res</span><span class="w"> </span><span class="k">with</span>
<span class="w">                </span><span class="o">|</span><span class="w"> </span><span class="n">Ok</span><span class="w"> </span><span class="n">cont</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">catch</span><span class="w"> </span><span class="n">cont</span><span class="w"> </span><span class="c1">// note, a tailcall</span>
<span class="w">                </span><span class="o">|</span><span class="w"> </span><span class="n">Exception</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">(</span><span class="n">Exception</span><span class="w"> </span><span class="n">e</span><span class="o">))</span>

<span class="w">    </span><span class="sd">/// The delay operator.</span>
<span class="w">    </span><span class="k">let</span><span class="w"> </span><span class="nv">delay</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">NotYetDone</span><span class="w"> </span><span class="o">(</span><span class="k">fun</span><span class="w"> </span><span class="bp">()</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">f</span><span class="bp">()</span><span class="o">)</span>

<span class="w">    </span><span class="sd">/// The stepping action for the computations.</span>
<span class="w">    </span><span class="k">let</span><span class="w"> </span><span class="nv">step</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span>
<span class="w">        </span><span class="k">match</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="k">with</span>
<span class="w">        </span><span class="o">|</span><span class="w"> </span><span class="n">Done</span><span class="w"> </span><span class="o">_</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">c</span>
<span class="w">        </span><span class="o">|</span><span class="w"> </span><span class="n">NotYetDone</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="bp">()</span>

<span class="w">    </span><span class="c1">// The rest of the operations are boilerplate.</span>

<span class="w">    </span><span class="sd">/// The tryFinally operator.</span>
<span class="w">    </span><span class="sd">/// This is boilerplate in terms of &quot;result&quot;, &quot;catch&quot; and &quot;bind&quot;.</span>
<span class="w">    </span><span class="k">let</span><span class="w"> </span><span class="nv">tryFinally</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="n">compensation</span><span class="w"> </span><span class="o">=</span>
<span class="w">        </span><span class="n">catch</span><span class="w"> </span><span class="o">(</span><span class="n">e</span><span class="o">)</span>
<span class="w">        </span><span class="o">|&gt;</span><span class="w"> </span><span class="n">bind</span><span class="w"> </span><span class="o">(</span><span class="k">fun</span><span class="w"> </span><span class="n">res</span><span class="w"> </span><span class="o">-&gt;</span>
<span class="w">            </span><span class="n">compensation</span><span class="bp">()</span><span class="o">;</span>
<span class="w">            </span><span class="k">match</span><span class="w"> </span><span class="n">res</span><span class="w"> </span><span class="k">with</span>
<span class="w">            </span><span class="o">|</span><span class="w"> </span><span class="n">Ok</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="n">v</span>
<span class="w">            </span><span class="o">|</span><span class="w"> </span><span class="n">Exception</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">raise</span><span class="w"> </span><span class="n">e</span><span class="o">)</span>

<span class="w">    </span><span class="sd">/// The tryWith operator.</span>
<span class="w">    </span><span class="sd">/// This is boilerplate in terms of &quot;result&quot;, &quot;catch&quot; and &quot;bind&quot;.</span>
<span class="w">    </span><span class="k">let</span><span class="w"> </span><span class="nv">tryWith</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="n">handler</span><span class="w"> </span><span class="o">=</span>
<span class="w">        </span><span class="n">catch</span><span class="w"> </span><span class="n">e</span>
<span class="w">        </span><span class="o">|&gt;</span><span class="w"> </span><span class="n">bind</span><span class="w"> </span><span class="o">(</span><span class="k">function</span><span class="w"> </span><span class="n">Ok</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">Exception</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">handler</span><span class="w"> </span><span class="n">e</span><span class="o">)</span>

<span class="w">    </span><span class="sd">/// The whileLoop operator.</span>
<span class="w">    </span><span class="sd">/// This is boilerplate in terms of &quot;result&quot; and &quot;bind&quot;.</span>
<span class="w">    </span><span class="k">let</span><span class="w"> </span><span class="nv">rec</span><span class="w"> </span><span class="n">whileLoop</span><span class="w"> </span><span class="n">gd</span><span class="w"> </span><span class="n">body</span><span class="w"> </span><span class="o">=</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">gd</span><span class="bp">()</span><span class="w"> </span><span class="k">then</span><span class="w"> </span><span class="n">body</span><span class="w"> </span><span class="o">|&gt;</span><span class="w"> </span><span class="n">bind</span><span class="w"> </span><span class="o">(</span><span class="k">fun</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">whileLoop</span><span class="w"> </span><span class="n">gd</span><span class="w"> </span><span class="n">body</span><span class="o">)</span>
<span class="w">        </span><span class="k">else</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="bp">()</span>

<span class="w">    </span><span class="sd">/// The sequential composition operator</span>
<span class="w">    </span><span class="sd">/// This is boilerplate in terms of &quot;result&quot; and &quot;bind&quot;.</span>
<span class="w">    </span><span class="k">let</span><span class="w"> </span><span class="nv">combine</span><span class="w"> </span><span class="n">e1</span><span class="w"> </span><span class="n">e2</span><span class="w"> </span><span class="o">=</span>
<span class="w">        </span><span class="n">e1</span><span class="w"> </span><span class="o">|&gt;</span><span class="w"> </span><span class="n">bind</span><span class="w"> </span><span class="o">(</span><span class="k">fun</span><span class="w"> </span><span class="bp">()</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">e2</span><span class="o">)</span>

<span class="w">    </span><span class="sd">/// The using operator.</span>
<span class="w">    </span><span class="k">let</span><span class="w"> </span><span class="nv">using</span><span class="w"> </span><span class="o">(</span><span class="n">resource</span><span class="o">:</span><span class="w"> </span><span class="o">#</span><span class="nn">System</span><span class="p">.</span><span class="n">IDisposable</span><span class="o">)</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="o">=</span>
<span class="w">        </span><span class="n">tryFinally</span><span class="w"> </span><span class="o">(</span><span class="n">f</span><span class="w"> </span><span class="n">resource</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="k">fun</span><span class="w"> </span><span class="bp">()</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">resource</span><span class="o">.</span><span class="n">Dispose</span><span class="bp">()</span><span class="o">)</span>

<span class="w">    </span><span class="sd">/// The forLoop operator.</span>
<span class="w">    </span><span class="sd">/// This is boilerplate in terms of &quot;catch&quot;, &quot;result&quot; and &quot;bind&quot;.</span>
<span class="w">    </span><span class="k">let</span><span class="w"> </span><span class="nv">forLoop</span><span class="w"> </span><span class="o">(</span><span class="n">e</span><span class="o">:</span><span class="n">seq</span><span class="o">&lt;_&gt;)</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="o">=</span>
<span class="w">        </span><span class="k">let</span><span class="w"> </span><span class="nv">ie</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">e</span><span class="o">.</span><span class="n">GetEnumerator</span><span class="bp">()</span>
<span class="w">        </span><span class="n">tryFinally</span><span class="w"> </span><span class="o">(</span><span class="n">whileLoop</span><span class="w"> </span><span class="o">(</span><span class="k">fun</span><span class="w"> </span><span class="bp">()</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">ie</span><span class="o">.</span><span class="n">MoveNext</span><span class="bp">()</span><span class="o">)</span>
<span class="w">                              </span><span class="o">(</span><span class="n">delay</span><span class="w"> </span><span class="o">(</span><span class="k">fun</span><span class="w"> </span><span class="bp">()</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="k">let</span><span class="w"> </span><span class="nv">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ie</span><span class="o">.</span><span class="n">Current</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">v</span><span class="o">)))</span>
<span class="w">                   </span><span class="o">(</span><span class="k">fun</span><span class="w"> </span><span class="bp">()</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">ie</span><span class="o">.</span><span class="n">Dispose</span><span class="bp">()</span><span class="o">)</span>

<span class="c1">// Give the mapping for F# computation expressions.</span>
<span class="k">type</span><span class="w"> </span><span class="nc">EventuallyBuilder</span><span class="bp">()</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="k">member</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="nf">Bind</span><span class="o">(</span><span class="n">e</span><span class="o">,</span><span class="n">k</span><span class="o">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nn">Eventually</span><span class="p">.</span><span class="n">bind</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">e</span>
<span class="w">    </span><span class="k">member</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="nf">Return</span><span class="o">(</span><span class="n">v</span><span class="o">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nn">Eventually</span><span class="p">.</span><span class="n">result</span><span class="w"> </span><span class="n">v</span>
<span class="w">    </span><span class="k">member</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="nf">ReturnFrom</span><span class="o">(</span><span class="n">v</span><span class="o">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v</span>
<span class="w">    </span><span class="k">member</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="nf">Combine</span><span class="o">(</span><span class="n">e1</span><span class="o">,</span><span class="n">e2</span><span class="o">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nn">Eventually</span><span class="p">.</span><span class="n">combine</span><span class="w"> </span><span class="n">e1</span><span class="w"> </span><span class="n">e2</span>
<span class="w">    </span><span class="k">member</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="nf">Delay</span><span class="o">(</span><span class="n">f</span><span class="o">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nn">Eventually</span><span class="p">.</span><span class="n">delay</span><span class="w"> </span><span class="n">f</span>
<span class="w">    </span><span class="k">member</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="nf">Zero</span><span class="bp">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nn">Eventually</span><span class="p">.</span><span class="n">result</span><span class="w"> </span><span class="bp">()</span>
<span class="w">    </span><span class="k">member</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="nf">TryWith</span><span class="o">(</span><span class="n">e</span><span class="o">,</span><span class="n">handler</span><span class="o">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nn">Eventually</span><span class="p">.</span><span class="n">tryWith</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="n">handler</span>
<span class="w">    </span><span class="k">member</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="nf">TryFinally</span><span class="o">(</span><span class="n">e</span><span class="o">,</span><span class="n">compensation</span><span class="o">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nn">Eventually</span><span class="p">.</span><span class="n">tryFinally</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="n">compensation</span>
<span class="w">    </span><span class="k">member</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="nf">For</span><span class="o">(</span><span class="n">e</span><span class="o">:</span><span class="n">seq</span><span class="o">&lt;_&gt;,</span><span class="n">f</span><span class="o">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nn">Eventually</span><span class="p">.</span><span class="n">forLoop</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="n">f</span>
<span class="w">    </span><span class="k">member</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="nf">Using</span><span class="o">(</span><span class="n">resource</span><span class="o">,</span><span class="n">e</span><span class="o">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nn">Eventually</span><span class="p">.</span><span class="n">using</span><span class="w"> </span><span class="n">resource</span><span class="w"> </span><span class="n">e</span>

<span class="k">let</span><span class="w"> </span><span class="nv">eventually</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">EventuallyBuilder</span><span class="bp">()</span>
</code></pre></div>
<p>After the computations are defined, they can be built by using eventually { ... }:</p>
<div class="highlight"><pre><span></span><code><span class="k">let</span><span class="w"> </span><span class="nv">comp</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="n">eventually</span><span class="w"> </span><span class="o">{</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">..</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="k">do</span>
<span class="w">            </span><span class="n">printfn</span><span class="w"> </span><span class="s">&quot; x = %d&quot;</span><span class="w"> </span><span class="n">x</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="o">}</span>
</code></pre></div>
<p>These computations can now be stepped. For example:</p>
<div class="highlight"><pre><span></span><code><span class="k">let</span><span class="w"> </span><span class="nv">step</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nn">Eventually</span><span class="p">.</span><span class="n">step</span><span class="w"> </span><span class="n">x</span>
<span class="w">    </span><span class="n">comp</span><span class="w"> </span><span class="o">|&gt;</span><span class="w"> </span><span class="n">step</span>
<span class="c1">// returns &quot;NotYetDone &lt;closure&gt;&quot;</span>

<span class="n">comp</span><span class="w"> </span><span class="o">|&gt;</span><span class="w"> </span><span class="n">step</span><span class="w"> </span><span class="o">|&gt;</span><span class="w"> </span><span class="n">step</span>
<span class="c1">// prints &quot;x = 1&quot;</span>
<span class="c1">// returns &quot;NotYetDone &lt;closure&gt;&quot;</span>

<span class="n">comp</span><span class="w"> </span><span class="o">|&gt;</span><span class="w"> </span><span class="n">step</span><span class="w"> </span><span class="o">|&gt;</span><span class="w"> </span><span class="n">step</span><span class="w"> </span><span class="o">|&gt;</span><span class="w"> </span><span class="n">step</span><span class="w"> </span><span class="o">|&gt;</span><span class="w"> </span><span class="n">step</span><span class="w"> </span><span class="o">|&gt;</span><span class="w"> </span><span class="n">step</span><span class="w"> </span><span class="o">|&gt;</span><span class="w"> </span><span class="n">step</span>
<span class="c1">// prints &quot;x = 1&quot;</span>
<span class="c1">// prints &quot;x = 2&quot;</span>
<span class="c1">// returns “NotYetDone &lt;closure&gt;”</span>

<span class="n">comp</span><span class="w"> </span><span class="o">|&gt;</span><span class="w"> </span><span class="n">step</span><span class="w"> </span><span class="o">|&gt;</span><span class="w"> </span><span class="n">step</span><span class="w"> </span><span class="o">|&gt;</span><span class="w"> </span><span class="n">step</span><span class="w"> </span><span class="o">|&gt;</span><span class="w"> </span><span class="n">step</span><span class="w"> </span><span class="o">|&gt;</span><span class="w"> </span><span class="n">step</span><span class="w"> </span><span class="o">|&gt;</span><span class="w"> </span><span class="n">step</span><span class="w"> </span><span class="o">|&gt;</span><span class="w"> </span><span class="n">step</span><span class="w"> </span><span class="o">|&gt;</span><span class="w"> </span><span class="n">step</span>
<span class="c1">// prints &quot;x = 1&quot;</span>
<span class="c1">// prints &quot;x = 2&quot;</span>
<span class="c1">// returns &quot;Done 7&quot;</span>
</code></pre></div>
<h3 id="6311-sequence-expressions">6.3.11 Sequence Expressions</h3>
<p>An expression in one of the following forms is a <em>sequence expression</em> :</p>
<div class="highlight"><pre><span></span><code>seq { comp-expr }
seq { short-comp-expr }
</code></pre></div>
<p>For example:</p>
<div class="highlight"><pre><span></span><code><span class="n">seq</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="o">[</span><span class="w"> </span><span class="mi">1</span><span class="o">;</span><span class="w"> </span><span class="mi">2</span><span class="o">;</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">]</span><span class="w"> </span><span class="k">do</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="o">[</span><span class="mi">5</span><span class="o">;</span><span class="w"> </span><span class="mi">6</span><span class="o">]</span><span class="w"> </span><span class="k">do</span><span class="w"> </span><span class="k">yield</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">}</span>
<span class="n">seq</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="o">[</span><span class="w"> </span><span class="mi">1</span><span class="o">;</span><span class="w"> </span><span class="mi">2</span><span class="o">;</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">]</span><span class="w"> </span><span class="k">do</span><span class="w"> </span><span class="k">yield</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">}</span>
<span class="n">seq</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="o">[</span><span class="w"> </span><span class="mi">1</span><span class="o">;</span><span class="w"> </span><span class="mi">2</span><span class="o">;</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">]</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">}</span>
</code></pre></div>
<p>Logically speaking, sequence expressions can be thought of as computation expressions with a
builder of type <code>FSharp.Collections.SeqBuilder</code>. This type can be considered to be defined as
follows:</p>
<div class="highlight"><pre><span></span><code><span class="k">type</span><span class="w"> </span><span class="nc">SeqBuilder</span><span class="bp">()</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="k">member</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="nf">Yield</span><span class="w"> </span><span class="o">(</span><span class="n">v</span><span class="o">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nn">Seq</span><span class="p">.</span><span class="n">singleton</span><span class="w"> </span><span class="n">v</span>
<span class="w">    </span><span class="k">member</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="nf">YieldFrom</span><span class="w"> </span><span class="o">(</span><span class="n">s</span><span class="o">:</span><span class="n">seq</span><span class="o">&lt;_&gt;)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s</span>
<span class="w">    </span><span class="k">member</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="nf">Return</span><span class="w"> </span><span class="o">(</span><span class="bp">()</span><span class="o">:</span><span class="kt">unit</span><span class="o">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nn">Seq</span><span class="p">.</span><span class="n">empty</span>
<span class="w">    </span><span class="k">member</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="nf">Combine</span><span class="w"> </span><span class="o">(</span><span class="n">xs1</span><span class="o">,</span><span class="n">xs2</span><span class="o">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nn">Seq</span><span class="p">.</span><span class="n">append</span><span class="w"> </span><span class="n">xs1</span><span class="w"> </span><span class="n">xs2</span>
<span class="w">    </span><span class="k">member</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="nf">For</span><span class="w"> </span><span class="o">(</span><span class="n">xs</span><span class="o">,</span><span class="n">g</span><span class="o">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nn">Seq</span><span class="p">.</span><span class="n">collect</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">xs</span>
<span class="w">    </span><span class="k">member</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="nf">While</span><span class="w"> </span><span class="o">(</span><span class="n">guard</span><span class="o">,</span><span class="n">body</span><span class="o">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nn">SequenceExpressionHelpers</span><span class="p">.</span><span class="n">EnumerateWhile</span><span class="w"> </span><span class="n">guard</span><span class="w"> </span><span class="n">body</span>
<span class="w">    </span><span class="k">member</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="nf">TryFinally</span><span class="w"> </span><span class="o">(</span><span class="n">xs</span><span class="o">,</span><span class="n">compensation</span><span class="o">)</span><span class="w"> </span><span class="o">=</span>
<span class="w">        </span><span class="nn">SequenceExpressionHelpers</span><span class="p">.</span><span class="n">EnumerateThenFinally</span><span class="w"> </span><span class="n">xs</span><span class="w"> </span><span class="n">compensation</span>
<span class="w">    </span><span class="k">member</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="nf">Using</span><span class="w"> </span><span class="o">(</span><span class="n">resource</span><span class="o">,</span><span class="n">xs</span><span class="o">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nn">SequenceExpressionHelpers</span><span class="p">.</span><span class="n">EnumerateUsing</span><span class="w"> </span><span class="n">resource</span><span class="w"> </span><span class="n">xs</span>
</code></pre></div>
<blockquote>
<p>Note that this builder type is not actually defined in the F# library. Instead, sequence expressions are
elaborated directly. For details, see page 79 of the old pdf spec.</p>
</blockquote>
<!-- Text skipped during conversion -->

<h3 id="6312-range-expressions">6.3.12 Range Expressions</h3>
<p>Expressions of the following forms are <em>range expressions</em>.</p>
<div class="highlight"><pre><span></span><code>{ e1 .. e2 }
{ e1 .. e2 .. e3 }
seq { e1 .. e2 }
seq { e1 .. e2 .. e3 }
</code></pre></div>
<p>Range expressions generate sequences over a specified range. For example:</p>
<div class="highlight"><pre><span></span><code>seq { 1 .. 10 } // 1; 2; 3; 4; 5; 6; 7; 8; 9; 10
seq { 1 .. 2 .. 10 } // 1; 3; 5; 7; 9
</code></pre></div>
<p>Range expressions involving <code>expr1 .. expr2</code> are translated to uses of the <code>(..)</code> operator, and those
involving <code>expr1 .. expr1 .. expr3</code> are translated to uses of the <code>(.. ..)</code> operator:</p>
<div class="highlight"><pre><span></span><code>seq { e1 .. e2 } → ( .. ) e1 e2
seq { e1 .. e2 .. e3 } → ( .. .. ) e1 e2 e3
</code></pre></div>
<p>The default definition of these operators is in <code>FSharp.Core.Operators</code>. The ( <code>..</code> ) operator generates
an <code>IEnumerable&lt;_&gt;</code> for the range of values between the start (<code>expr1</code>) and finish (<code>expr2</code>) values, using
an increment of 1 (as defined by <code>FSharp.Core.LanguagePrimitives.GenericOne</code>). The <code>(.. ..)</code>
operator generates an <code>IEnumerable&lt;_&gt;</code> for the range of values between the start (<code>expr1</code>) and finish
(<code>expr3</code>) values, using an increment of <code>expr2</code>.</p>
<p>The <code>seq</code> keyword, which denotes the type of computation expression, can be omitted for simple
range expressions, but this is not recommended and might be deprecated in a future release. It is
always preferable to explicitly mark the type of a computation expression.</p>
<p>Range expressions also occur as part of the translated form of expressions, including the following:</p>
<ul>
<li><code>[ expr1 .. expr2 ]</code></li>
<li><code>[| expr1 .. expr2 |]</code></li>
<li><code>for var in expr1 .. expr2 do expr3</code></li>
</ul>
<p>A sequence iteration expression of the form <code>for var in expr1 .. expr2 do expr3 done</code> is sometimes
elaborated as a simple for loop-expression (<a href="./#657-simple-for-loop-expressions">§6.5.7</a>).</p>
<h3 id="6313-lists-via-sequence-expressions">6.3.13 Lists via Sequence Expressions</h3>
<p>A <em>list sequence expression</em> is an expression in one of the following forms</p>
<div class="highlight"><pre><span></span><code>[ comp-expr ]
[ short-comp-expr ]
[ range-expr ]
</code></pre></div>
<p>In all cases <code>[ cexpr ]</code> elaborates to <code>FSharp.Collections.Seq.toList(seq { cexpr })</code>.</p>
<p>For example:</p>
<div class="highlight"><pre><span></span><code><span class="k">let</span><span class="w"> </span><span class="nv">x2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">[</span><span class="w"> </span><span class="k">yield</span><span class="w"> </span><span class="mi">1</span><span class="o">;</span><span class="w"> </span><span class="k">yield</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">]</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="k">let</span><span class="w"> </span><span class="nv">x3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">[</span><span class="w"> </span><span class="k">yield</span><span class="w"> </span><span class="mi">1</span>
<span class="w">           </span><span class="k">if</span><span class="w"> </span><span class="nn">System</span><span class="p">.</span><span class="nn">DateTime</span><span class="p">.</span><span class="nn">Now</span><span class="p">.</span><span class="n">DayOfWeek</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nn">System</span><span class="p">.</span><span class="nn">DayOfWeek</span><span class="p">.</span><span class="n">Monday</span><span class="w"> </span><span class="k">then</span>
<span class="w">               </span><span class="k">yield</span><span class="w"> </span><span class="mi">2</span><span class="o">]</span>
</code></pre></div>
<h3 id="6314-arrays-sequence-expressions">6.3.14 Arrays Sequence Expressions</h3>
<p>An expression in one of the following forms is an <em>array sequence expression</em> :</p>
<div class="highlight"><pre><span></span><code>[| comp-expr |]
[| short-comp-expr |]
[| range-expr |]
</code></pre></div>
<p>In all cases <code>[| cexpr |]</code> elaborates to <code>FSharp.Collections.Seq.toArray(seq { cexpr })</code>.</p>
<p>For example:</p>
<div class="highlight"><pre><span></span><code><span class="k">let</span><span class="w"> </span><span class="nv">x2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">[|</span><span class="w"> </span><span class="k">yield</span><span class="w"> </span><span class="mi">1</span><span class="o">;</span><span class="w"> </span><span class="k">yield</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">|]</span>
<span class="k">let</span><span class="w"> </span><span class="nv">x3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">[|</span><span class="w"> </span><span class="k">yield</span><span class="w"> </span><span class="mi">1</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="nn">System</span><span class="p">.</span><span class="nn">DateTime</span><span class="p">.</span><span class="nn">Now</span><span class="p">.</span><span class="n">DayOfWeek</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nn">System</span><span class="p">.</span><span class="nn">DayOfWeek</span><span class="p">.</span><span class="n">Monday</span><span class="w"> </span><span class="k">then</span>
<span class="w">        </span><span class="k">yield</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">|]</span>
</code></pre></div>
<h3 id="6315-null-expressions">6.3.15 Null Expressions</h3>
<p>An expression in the form <code>null</code> is a <em>null expression</em>. A null expression imposes a nullness constraint
(<a href="../types-and-type-constraints/#522-nullness-constraints">§5.2.2</a>, <a href="../types-and-type-constraints/#548-nullness">§5.4.8</a>) on the initial type of the expression. The constraint ensures that the type directly
supports the value <code>null</code>.</p>
<p>Null expressions are a primitive elaborated form.</p>
<h3 id="6316-printf-formats">6.3.16 'printf' Formats</h3>
<p>Format strings are strings with <code>%</code> markers as format placeholders. Format strings are analyzed at
compile time and annotated with static and runtime type information as a result of that analysis.
They are typically used with one of the functions <code>printf</code>, <code>fprintf</code>, <code>sprintf</code>, or <code>bprintf</code> in the
<code>FSharp.Core.Printf</code> module. Format strings receive special treatment in order to type check uses of
these functions more precisely.</p>
<p>More concretely, a constant string is interpreted as a printf-style format string if it is expected to
have the type <code>FSharp.Core.PrintfFormat&lt;'Printer,'State,'Residue,'Result,'Tuple&gt;</code>. The string is
statically analyzed to resolve the generic parameters of the <code>PrintfFormat type</code>, of which <code>'Printer</code>
and <code>'Tuple</code> are the most interesting:</p>
<ul>
<li><code>'Printer</code> is the function type that is generated by applying a printf-like function to the format
    string.</li>
<li><code>'Tuple</code> is the type of the tuple of values that are generated by treating the string as a generator
    (for example, when the format string is used with a function similar to <code>scanf</code> in other
    languages).</li>
</ul>
<p>A format placeholder has the following shape:</p>
<p><code>%[flags][width][.precision][type]</code></p>
<p>where:</p>
<p><code>flags</code> are 0 , -, +, and the space character. The # flag is invalid and results in a compile-time error.</p>
<p><code>width</code> is an integer that specifies the minimum number of characters in the result.</p>
<p><code>precision</code> is the number of digits to the right of the decimal point for a floating-point type..</p>
<p><code>type</code> is as shown in the following table.</p>
<table>
<thead>
<tr>
<th>Placeholder string</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>%b</code></td>
<td><code>bool</code></td>
</tr>
<tr>
<td><code>%s</code></td>
<td><code>string</code></td>
</tr>
<tr>
<td><code>%c</code></td>
<td><code>char</code></td>
</tr>
<tr>
<td><code>%d, %i</code></td>
<td>One of the basic integer types.</br>A basic integer type is <code>byte</code>, <code>sbyte</code>, <code>int16</code>, <code>uint16</code>, <code>int32</code>, <code>uint32</code>, <code>int64</code>, <code>uint64</code>, <code>nativeint</code>, <code>unativeint</code>, or one of these types with a unit of measure</td>
</tr>
<tr>
<td><code>%u</code></td>
<td>Basic integer type formatted as an unsigned integer</td>
</tr>
<tr>
<td><code>%x</code></td>
<td>Basic integer type formatted as an unsigned hexadecimal integer with lowercase letters a through f.</td>
</tr>
<tr>
<td><code>%X</code></td>
<td>Basic integer type formatted as an unsigned hexadecimal integer with uppercase letters A through F.</td>
</tr>
<tr>
<td><code>%o</code></td>
<td>Basic integer type formatted as an unsigned octal integer.</td>
</tr>
<tr>
<td><code>%e, %E, %f, %F, %g, %G</code></td>
<td><code>float</code> or <code>float32</code>, possibly with a unit of measure</td>
</tr>
<tr>
<td><code>%M</code></td>
<td><code>System.Decimal</code>, possibly with a unit of measure</td>
</tr>
<tr>
<td><code>%O</code></td>
<td><code>System.Object</code>, possibly with a unit of measure</td>
</tr>
<tr>
<td><code>%A</code></td>
<td>Fresh variable type <code>'T</code></td>
</tr>
<tr>
<td><code>%a</code></td>
<td>Formatter of type <code>'State -&gt; 'T -&gt; 'Residue</code> for a fresh variable type <code>'T</code></td>
</tr>
<tr>
<td><code>%t</code></td>
<td>Formatter of type <code>'State -&gt; 'Residue</code></td>
</tr>
</tbody>
</table>
<p>For example, the format string "<code>%s %d %s</code>" is given the type <code>PrintfFormat&lt;(string -&gt; int -&gt; string -&gt; 'd), 'b, 'c, 'd, (string * int * string)&gt;</code> for fresh variable types <code>'b</code>, <code>'c</code>, <code>'d</code>. Applying <code>printf</code>
to it yields a function of type <code>string -&gt; int -&gt; string -&gt; unit</code>.</p>
<h2 id="64-application-expressions">6.4 Application Expressions</h2>
<h3 id="641-basic-application-expressions">6.4.1 Basic Application Expressions</h3>
<p>Application expressions involve variable names, dot-notation lookups, function applications, method
applications, type applications, and item lookups, as shown in the following table.</p>
<table>
<thead>
<tr>
<th>Expression</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>long-ident-or-op</code></td>
<td>Long-ident lookup expression</td>
</tr>
<tr>
<td><code>expr '.' long-ident-or-op</code></td>
<td>Dot lookup expression</td>
</tr>
<tr>
<td><code>expr expr</code></td>
<td>Function or member application expression</td>
</tr>
<tr>
<td><code>expr(expr)</code></td>
<td>High precedence function or member application expression</td>
</tr>
<tr>
<td><code>expr&lt;types&gt;</code></td>
<td>Type application expression</td>
</tr>
<tr>
<td><code>expr&lt; &gt;</code></td>
<td>Type application expression with an empty type list</td>
</tr>
<tr>
<td><code>type expr</code></td>
<td>Simple object expression</td>
</tr>
</tbody>
</table>
<p>The following are examples of application expressions:</p>
<div class="highlight"><pre><span></span><code><span class="nn">System</span><span class="p">.</span><span class="nn">Math</span><span class="p">.</span><span class="n">PI</span>
<span class="nn">System</span><span class="p">.</span><span class="nn">Math</span><span class="p">.</span><span class="nn">PI</span><span class="p">.</span><span class="n">ToString</span><span class="bp">()</span>
<span class="o">(</span><span class="mi">3</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">4</span><span class="o">).</span><span class="n">ToString</span><span class="bp">()</span>
<span class="nn">System</span><span class="p">.</span><span class="nn">Environment</span><span class="p">.</span><span class="n">GetEnvironmentVariable</span><span class="o">(</span><span class="s">&quot;PATH&quot;</span><span class="o">).</span><span class="n">Length</span>
<span class="nn">System</span><span class="p">.</span><span class="nn">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="o">(</span><span class="s">&quot;Hello World&quot;</span><span class="o">)</span>
</code></pre></div>
<p>Application expressions may start with object construction expressions that do not include the <code>new</code>
keyword:</p>
<div class="highlight"><pre><span></span><code><span class="nn">System</span><span class="p">.</span><span class="n">Object</span><span class="bp">()</span>
<span class="nn">System</span><span class="p">.</span><span class="nn">Collections</span><span class="p">.</span><span class="nn">Generic</span><span class="p">.</span><span class="n">List</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;(</span><span class="mi">10</span><span class="o">)</span>
<span class="nn">System</span><span class="p">.</span><span class="nn">Collections</span><span class="p">.</span><span class="nn">Generic</span><span class="p">.</span><span class="n">KeyValuePair</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span><span class="s">&quot;Three&quot;</span><span class="o">)</span>
<span class="nn">System</span><span class="p">.</span><span class="n">Object</span><span class="bp">()</span><span class="o">.</span><span class="n">GetType</span><span class="bp">()</span>
<span class="nn">System</span><span class="p">.</span><span class="nn">Collections</span><span class="p">.</span><span class="nn">Generic</span><span class="p">.</span><span class="n">Dictionary</span><span class="o">&lt;</span><span class="n">int</span><span class="o">,</span><span class="n">int</span><span class="o">&gt;(</span><span class="mi">10</span><span class="o">).[</span><span class="mi">1</span><span class="o">]</span>
</code></pre></div>
<p>If the <code>long-ident-or-op</code> starts with the special pseudo-identifier keyword <code>global</code>, F# resolves the
identifier with respect to the global namespace — that is, ignoring all <code>open</code> directives (see <a href="../inference-procedures/#142-resolving-application-expressions">§14.2</a>). For example:</p>
<div class="highlight"><pre><span></span><code><span class="k">global</span><span class="o">.</span><span class="n">System</span><span class="o">.</span><span class="n">Math</span><span class="o">.</span><span class="n">PI</span>
</code></pre></div>
<p>is resolved to <code>System.Math.PI</code> ignoring all <code>open</code> directives.</p>
<p>The checking of application expressions is described in detail as an algorithm in <a href="../inference-procedures/#142-resolving-application-expressions">§14.2</a>. To check an
application expression, the expression form is repeatedly decomposed into a <em>lead</em> expression <code>expr</code>
and a list of projections <code>projs</code> through the use of <em>Unqualified Lookup</em> (<a href="../inference-procedures/#1421-unqualified-lookup">§14.2.1</a>). This in turn uses
procedures such as <em>Expression-Qualified Lookup</em> and <em>Method Application Resolution</em>.</p>
<p>As described in <a href="../inference-procedures/#142-resolving-application-expressions">§14.2</a>, checking an application expression results in an elaborated expression that
contains a series of lookups and method calls. The elaborated expression may include:</p>
<ul>
<li>Uses of named values</li>
<li>Uses of union cases</li>
<li>Record constructions</li>
<li>Applications of functions</li>
<li>Applications of methods (including methods that access properties)</li>
<li>Applications of object constructors</li>
<li>Uses of fields, both static and instance</li>
<li>Uses of active pattern result elements</li>
</ul>
<p>Additional constructs may be inserted when resolving method calls into simpler primitives:</p>
<ul>
<li>
<p>The use of a method or value as a first-class function may result in a function expression.</p>
<p>For example, <code>System.Environment.GetEnvironmentVariable</code> elaborates to:
<code>(fun v -&gt; System.Environment.GetEnvironmentVariable(v))</code>
for some fresh variable <code>v</code>.</p>
</li>
<li>
<p>The use of post-hoc property setters results in the insertion of additional assignment and
    sequential execution expressions in the elaborated expression.</p>
<p>For example, <code>new System.Windows.Forms.Form(Text="Text")</code> elaborates to
<code>let v = new System.Windows.Forms.Form() in v.set_Text("Text"); v</code>
for some fresh variable <code>v</code>.</p>
</li>
<li>
<p>The use of optional arguments results in the insertion of <code>Some(_)</code> and <code>None</code> data constructions in
    the elaborated expression.</p>
</li>
</ul>
<p>For uses of active pattern results (see <a href="../namespaces-and-modules/#1024-active-pattern-definitions-in-modules">§10.2.4</a>), for result <code>i</code> in an active pattern that has <code>N</code> possible
results of types <code>types</code> , the elaborated expression form is a union case <code>ChoiceNOfi</code> of type
<code>FSharp.Core.Choice&lt;types&gt;</code>.</p>
<h3 id="642-object-construction-expressions">6.4.2 Object Construction Expressions</h3>
<p>An expression of the following form is an <em>object construction expression</em>:</p>
<div class="highlight"><pre><span></span><code>new ty ( e1 ... en )
</code></pre></div>
<p>An object construction expression constructs a new instance of a type, usually by calling a
constructor method on the type. For example:</p>
<div class="highlight"><pre><span></span><code><span class="k">new</span><span class="w"> </span><span class="nn">System</span><span class="p">.</span><span class="n">Object</span><span class="bp">()</span>
<span class="k">new</span><span class="w"> </span><span class="nn">System</span><span class="p">.</span><span class="nn">Collections</span><span class="p">.</span><span class="nn">Generic</span><span class="p">.</span><span class="n">List</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;</span><span class="bp">()</span>
<span class="k">new</span><span class="w"> </span><span class="nn">System</span><span class="p">.</span><span class="nn">Windows</span><span class="p">.</span><span class="nn">Forms</span><span class="p">.</span><span class="n">Form</span><span class="w"> </span><span class="o">(</span><span class="n">Text</span><span class="o">=</span><span class="s">&quot;Hello World&quot;</span><span class="o">)</span>
<span class="k">new</span><span class="w"> </span><span class="k">&#39;</span><span class="n">T</span><span class="bp">()</span>
</code></pre></div>
<p>The initial type of the expression is first asserted to be equal to <code>ty</code>. The type <code>ty</code> must not be an array,
record, union or tuple type. If <code>ty</code> is a named class or struct type:</p>
<ul>
<li><code>ty</code> must not be abstract.</li>
<li>If <code>ty</code> is a struct type, <code>n</code> is 0 , and <code>ty</code> does not have a constructor method that takes zero
    arguments, the expression elaborates to the default “zero-bit pattern” value for <code>ty</code>.</li>
<li>Otherwise, the type must have one or more accessible constructors. The overloading between
    these potential constructors is resolved and elaborated by using <em>Method Application Resolution</em>
    (see <a href="../inference-procedures/#144-method-application-resolution">§14.4</a>).</li>
</ul>
<p>If <code>ty</code> is a delegate type the expression is a <em>delegate implementation expression</em>.</p>
<ul>
<li>
<p>If the delegate type has an <code>Invoke</code> method that has the following signature</p>
<p><code>Invoke(ty1, ..., tyn) -&gt; rtyA</code> ,</p>
<p>then the overall expression must be in this form:</p>
<p><code>new ty(expr)</code> where <code>expr</code> has type <code>ty1 -&gt; ... -&gt; tyn -&gt; rtyB</code></p>
<p>If type <code>rtyA</code> is a CLI void type, then <code>rtyB</code> is unit, otherwise it is <code>rtyA</code>.</p>
</li>
<li>
<p>If any of the types <code>tyi</code> is a byref-type then an explicit function expression must be specified. That
    is, the overall expression must be of the form <code>new ty(fun pat1 ... patn -&gt; exprbody)</code>.</p>
</li>
</ul>
<p>If <code>ty</code> is a type variable:</p>
<ul>
<li>There must be no arguments (that is, <code>n = 0</code>).</li>
<li>
<p>The type variable is constrained as follows:</p>
<p><code>ty : (new : unit -&gt; ty )</code> -- CLI default constructor constraint</p>
</li>
<li>
<p>The expression elaborates to a call to
    <code>FSharp.Core.LanguagePrimitives.IntrinsicFunctions.CreateInstance&lt;ty&gt;()</code>, which in turn calls
    <code>System.Activator.CreateInstance&lt;ty&gt;()</code>, which in turn uses CLI reflection to find and call the
    null object constructor method for type <code>ty</code>. On return from this function, any exceptions are
    wrapped by using <code>System.TargetInvocationException</code>.</p>
</li>
</ul>
<h3 id="643-operator-expressions">6.4.3 Operator Expressions</h3>
<p>Operator expressions are specified in terms of their shallow syntactic translation to other constructs.
The following translations are applied in order:</p>
<div class="highlight"><pre><span></span><code>infix-or-prefix-op e1 → (~infix-or-prefix-op) e1
prefix-op e1 → (prefix-op) e1
e1 infix-op e2 → (infix-op) e1 e2
</code></pre></div>
<blockquote>
<p>Note: When an operator that may be used as either an infix or prefix operator is used in
prefix position, a tilde character ~ is added to the name of the operator during the
translation process.</p>
</blockquote>
<p>These rules are applied after applying the rules for dynamic operators (<a href="./#644-dynamic-operator-expressions">§6.4.4</a>).</p>
<p>The parenthesized operator name is then treated as an identifier and the standard rules for
unqualified name resolution (<a href="../inference-procedures/#141-name-resolution">§14.1</a>) in expressions are applied. The expression may resolve to a
specific definition of a user-defined or library-defined operator. For example:</p>
<div class="highlight"><pre><span></span><code><span class="k">let</span><span class="w"> </span><span class="o">(+++)</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">(</span><span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="o">)</span>
<span class="mi">3</span><span class="w"> </span><span class="o">+++</span><span class="w"> </span><span class="mi">4</span>
</code></pre></div>
<p>In some cases, the operator name resolves to a standard definition of an operator from the F#
library. For example, in the absence of an explicit definition of (+),</p>
<div class="highlight"><pre><span></span><code><span class="mi">3</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">4</span>
</code></pre></div>
<p>resolves to a use of the infix operator FSharp.Core.Operators.(+).</p>
<p>Some operators that are defined in the F# library receive special treatment in this specification. In
particular:</p>
<ul>
<li>The <code>&amp;expr</code> and <code>&amp;&amp;expr</code> address-of operators (<a href="./#645-the-addressof-operators">§6.4.5</a>)</li>
<li>The <code>expr &amp;&amp; expr</code> and <code>expr || expr</code> shortcut control flow operators (<a href="./#654-shortcut-operator-expressions">§6.5.4</a>)</li>
<li>The <code>%expr</code> and <code>%%expr</code> expression splice operators in quotations (<a href="./#683-expression-splices">§6.8.3</a>)</li>
<li>The library-defined operators, such as <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code>, <code>**</code>, <code>&lt;&lt;&lt;</code>, <code>&gt;&gt;&gt;</code>, <code>&amp;&amp;&amp;</code>, <code>|||</code>, and <code>^^^</code> (<a href="../the-f-library-fsharpcoredll/#182-basic-operators-and-functions-fsharpcoreoperators">§18.2</a>).</li>
</ul>
<p>If the operator does not resolve to a user-defined or library-defined operator, the name resolution
rules (<a href="../inference-procedures/#141-name-resolution">§14.1</a>) ensure that the operator resolves to an expression that implicitly uses a static member
invocation expression (§ ?) that involves the types of the operands. This means that the effective
behavior of an operator that is not defined in the F# library is to require a static member that has the
same name as the operator, on the type of one of the operands of the operator. In the following
code, the otherwise undefined operator <code>--&gt;</code> resolves to the static member on the <code>Receiver</code> type,
based on a type-directed resolution:</p>
<div class="highlight"><pre><span></span><code><span class="k">type</span><span class="w"> </span><span class="nc">Receiver</span><span class="o">(</span><span class="n">latestMessage</span><span class="o">:</span><span class="kt">string</span><span class="o">)</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="k">member</span><span class="w"> </span><span class="o">(&lt;--)</span><span class="w"> </span><span class="o">(</span><span class="n">receiver</span><span class="o">:</span><span class="n">Receiver</span><span class="o">,</span><span class="n">message</span><span class="o">:</span><span class="kt">string</span><span class="o">)</span><span class="w"> </span><span class="o">=</span>
<span class="w">        </span><span class="n">Receiver</span><span class="o">(</span><span class="n">message</span><span class="o">)</span>

<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="k">member</span><span class="w"> </span><span class="o">(--&gt;)</span><span class="w"> </span><span class="o">(</span><span class="n">message</span><span class="o">,</span><span class="n">receiver</span><span class="o">:</span><span class="n">Receiver</span><span class="o">)</span><span class="w"> </span><span class="o">=</span>
<span class="w">        </span><span class="n">Receiver</span><span class="o">(</span><span class="n">message</span><span class="o">)</span>

<span class="k">let</span><span class="w"> </span><span class="nv">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Receiver</span><span class="w"> </span><span class="s">&quot;no message&quot;</span>

<span class="n">r</span><span class="w"> </span><span class="o">&lt;--</span><span class="w"> </span><span class="s">&quot;Message One&quot;</span>

<span class="s">&quot;Message Two&quot;</span><span class="w"> </span><span class="o">--&gt;</span><span class="w"> </span><span class="n">r</span>
</code></pre></div>
<h3 id="644-dynamic-operator-expressions">6.4.4 Dynamic Operator Expressions</h3>
<p>Expressions of the following forms are <em>dynamic operator expressions:</em></p>
<div class="highlight"><pre><span></span><code>expr1 ? expr2
expr1 ? expr2 &lt;- expr3
</code></pre></div>
<p>These expressions are defined by their syntactic translation:</p>
<p><code>expr ? ident</code> → <code>(?) expr "ident"</code></p>
<p><code>expr1 ? (expr2)</code> → <code>(?) expr1 expr2</code></p>
<p><code>expr1 ? ident &lt;- expr2</code> → <code>(?&lt;-) expr1 "ident" expr2</code></p>
<p><code>expr1 ? (expr2) &lt;- expr3</code> → <code>(?&lt;-) expr1 expr2 expr3</code></p>
<p>Here <code>"ident"</code> is a string literal that contains the text of <code>ident</code>.</p>
<blockquote>
<p>Note: The F# core library <code>FSharp.Core.dll</code> does not define the <code>(?)</code> and <code>(?&lt;-)</code> operators.
However, user code may define these operators. For example, it is common to define
the operators to perform a dynamic lookup on the properties of an object by using
reflection.</p>
</blockquote>
<p>This syntactic translation applies regardless of the definition of the <code>(?)</code> and <code>(?&lt;-)</code> operators.
However, it does not apply to uses of the parenthesized operator names, as in the following:</p>
<div class="highlight"><pre><span></span><code><span class="o">(?)</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span>
</code></pre></div>
<h3 id="645-the-addressof-operators">6.4.5 The AddressOf Operators</h3>
<p>Under default definitions, expressions of the following forms are <em>address-of expressions,</em> called
<em>byref-address-of expression</em> and <em>nativeptr-address-of expression,</em> respectively:</p>
<div class="highlight"><pre><span></span><code>&amp; expr
&amp;&amp; expr
</code></pre></div>
<p>Such expressions take the address of a mutable local variable, byref-valued argument, field, array
element, or static mutable global variable.</p>
<p>For <code>&amp;expr</code> and <code>&amp;&amp;expr</code>, the initial type of the overall expression must be of the form <code>byref&lt;ty&gt;</code> and
<code>nativeptr&lt;ty&gt;</code> respectively, and the expression <code>expr</code> is checked with initial type <code>ty</code>.</p>
<p>The overall expression is elaborated recursively by taking the address of the elaborated form of <code>expr</code>,
written <code>AddressOf(expr, DefinitelyMutates)</code>, defined in <a href="./#694-taking-the-address-of-an-elaborated-expression">§6.9.4</a>.</p>
<p>Use of these operators may result in unverifiable or invalid common intermediate language (CIL)
code; when possible, a warning or error is generated. In general, their use is recommended only:</p>
<ul>
<li>To pass addresses where <code>byref</code> or <code>nativeptr</code> parameters are expected.</li>
<li>To pass a <code>byref</code> parameter on to a subsequent function.</li>
<li>When required to interoperate with native code.</li>
</ul>
<p>Addresses that are generated by the <code>&amp;&amp;</code> operator must not be passed to functions that are in tail call
position. The F# compiler does not check for this.</p>
<p>Direct uses of <code>byref</code> types, <code>nativeptr</code> types, or values in the <code>FSharp.NativeInterop</code> module may
result in invalid or unverifiable CIL code. In particular, <code>byref</code> and <code>nativeptr</code> types may NOT be used
within named types such as tuples or function types.</p>
<p>When calling an existing CLI signature that uses a CLI pointer type <code>ty*</code>, use a value of type
<code>nativeptr&lt;ty&gt;</code>.</p>
<blockquote>
<p>Note: The rules in this section apply to the following prefix operators, which are defined
in the F# core library for use with one argument.
<br><code>FSharp.Core.LanguagePrimitives.IntrinsicOperators.(~&amp;)</code>
<br><code>FSharp.Core.LanguagePrimitives.IntrinsicOperators.(~&amp;&amp;)</code>
<br>Other uses of these operators are not permitted.</p>
</blockquote>
<h3 id="646-lookup-expressions">6.4.6 Lookup Expressions</h3>
<p>Lookup expressions are specified by syntactic translation:</p>
<p><code>e1.[eargs]</code> → <code>e1.get_Item(eargs)</code></p>
<p><code>e1.[eargs] &lt;- e3</code> → <code>e .set_Item(eargs, e3)</code></p>
<p>In addition, for the purposes of resolving expressions of this form, array types of rank 1, 2, 3, and 4
are assumed to support a type extension that defines an <code>Item</code> property that has the following
signatures:</p>
<div class="highlight"><pre><span></span><code><span class="k">type</span><span class="w"> </span><span class="k">&#39;</span><span class="n">T</span><span class="bp">[]</span><span class="w"> </span><span class="k">with</span>
<span class="w">    </span><span class="k">member</span><span class="w"> </span><span class="n">arr</span><span class="p">.</span><span class="nf">Item</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">int</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="k">&#39;</span><span class="n">T</span>

<span class="k">type</span><span class="w"> </span><span class="k">&#39;</span><span class="n">T</span><span class="o">[,]</span><span class="w"> </span><span class="k">with</span>
<span class="w">    </span><span class="k">member</span><span class="w"> </span><span class="n">arr</span><span class="p">.</span><span class="nf">Item</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">int</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">int</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="k">&#39;</span><span class="n">T</span>

<span class="k">type</span><span class="w"> </span><span class="k">&#39;</span><span class="n">T</span><span class="o">[,,]</span><span class="w"> </span><span class="k">with</span>
<span class="w">    </span><span class="k">member</span><span class="w"> </span><span class="n">arr</span><span class="p">.</span><span class="nf">Item</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">int</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">int</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">int</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="k">&#39;</span><span class="n">T</span>

<span class="k">type</span><span class="w"> </span><span class="k">&#39;</span><span class="n">T</span><span class="o">[,,,]</span><span class="w"> </span><span class="k">with</span>
<span class="w">    </span><span class="k">member</span><span class="w"> </span><span class="n">arr</span><span class="p">.</span><span class="nf">Item</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">int</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">int</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">int</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">int</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="k">&#39;</span><span class="n">T</span>
</code></pre></div>
<p>In addition, if type checking determines that the type of <code>e1</code> is a named type that supports the
<code>DefaultMember</code> attribute, then the member name identified by the <code>DefaultMember</code> attribute is used
instead of Item.</p>
<h3 id="647-slice-expressions">6.4.7 Slice Expressions</h3>
<p>Slice expressions are defined by syntactic translation:</p>
<p><code>e1.[sliceArg1, ,,, sliceArgN]</code> → <code>e1.GetSlice(args1, ..., argsN)</code></p>
<p><code>e1.[sliceArg1, ,,, sliceArgN] &lt;- expr</code> → <code>e1.SetSlice(args1, ...,argsN, expr)</code></p>
<p>where each <code>sliceArgN</code> is one of the following and translated to <code>argsN</code> (giving one or two args) as
indicated</p>
<p><code>*</code> → <code>None, None</code></p>
<p><code>e1..</code> → <code>Some e1, None</code></p>
<p><code>..e2</code> → <code>None, Some e2</code></p>
<p><code>e1..e2</code> → <code>Some e1, Some e2</code></p>
<p><code>idx</code> → <code>idx</code></p>
<p>Because this is a shallow syntactic translation, the <code>GetSlice</code> and <code>SetSlice</code> name may be resolved by
any of the relevant <em>Name Resolution</em> (<a href="../inference-procedures/#141-name-resolution">§14.1</a>) techniques, including defining the method as a type
extension for an existing type.</p>
<p>For example, if a matrix type has the appropriate overloads of the GetSlice method (see below), it is
possible to do the following:</p>
<div class="highlight"><pre><span></span><code><span class="n">matrix</span><span class="o">.[</span><span class="mi">1</span><span class="o">..,*]</span><span class="w"> </span><span class="c1">// get rows 1.. from a matrix (returning a matrix)</span>
<span class="n">matrix</span><span class="o">.[</span><span class="mi">1</span><span class="o">..</span><span class="mi">3</span><span class="o">,*]</span><span class="w"> </span><span class="c1">// get rows 1..3 from a matrix (returning a matrix)</span>
<span class="n">matrix</span><span class="o">.[*,</span><span class="mi">1</span><span class="o">..</span><span class="mi">3</span><span class="o">]</span><span class="w"> </span><span class="c1">// get columns 1..3from a matrix (returning a matrix)</span>
<span class="n">matrix</span><span class="o">.[</span><span class="mi">1</span><span class="o">..</span><span class="mi">3</span><span class="o">,</span><span class="mi">1</span><span class="o">,.</span><span class="mi">3</span><span class="o">]</span><span class="w"> </span><span class="c1">// get a 3x3 sub-matrix (returning a matrix)</span>
<span class="n">matrix</span><span class="o">.[</span><span class="mi">3</span><span class="o">,*]</span><span class="w"> </span><span class="c1">// get row 3 from a matrix as a vector</span>
<span class="n">matrix</span><span class="o">.[*,</span><span class="mi">3</span><span class="o">]</span><span class="w"> </span><span class="c1">// get column 3 from a matrix as a vector</span>
</code></pre></div>
<p>In addition, CIL array types of rank 1 to 4 are assumed to support a type extension that defines a
method <code>GetSlice</code> that has the following signature:</p>
<div class="highlight"><pre><span></span><code><span class="k">type</span><span class="w"> </span><span class="k">&#39;</span><span class="n">T</span><span class="bp">[]</span><span class="w"> </span><span class="k">with</span>
<span class="w">    </span><span class="k">member</span><span class="w"> </span><span class="n">arr</span><span class="p">.</span><span class="nf">GetSlice</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="o">?</span><span class="n">start1</span><span class="o">:</span><span class="n">int</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="o">?</span><span class="n">end1</span><span class="o">:</span><span class="n">int</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="k">&#39;</span><span class="n">T</span><span class="bp">[]</span>
<span class="k">type</span><span class="w"> </span><span class="k">&#39;</span><span class="n">T</span><span class="o">[,]</span><span class="w"> </span><span class="k">with</span>
<span class="w">    </span><span class="k">member</span><span class="w"> </span><span class="n">arr</span><span class="p">.</span><span class="nf">GetSlice</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="o">?</span><span class="n">start1</span><span class="o">:</span><span class="n">int</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="o">?</span><span class="n">end1</span><span class="o">:</span><span class="n">int</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="o">?</span><span class="n">start2</span><span class="o">:</span><span class="n">int</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="o">?</span><span class="n">end2</span><span class="o">:</span><span class="n">int</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="k">&#39;</span><span class="n">T</span><span class="o">[,]</span>
<span class="w">    </span><span class="k">member</span><span class="w"> </span><span class="n">arr</span><span class="p">.</span><span class="nf">GetSlice</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">idx1</span><span class="o">:</span><span class="n">int</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="o">?</span><span class="n">start2</span><span class="o">:</span><span class="n">int</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="o">?</span><span class="n">end2</span><span class="o">:</span><span class="n">int</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="k">&#39;</span><span class="n">T</span><span class="bp">[]</span>
<span class="w">    </span><span class="k">member</span><span class="w"> </span><span class="n">arr</span><span class="p">.</span><span class="nf">GetSlice</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="o">?</span><span class="n">start1</span><span class="o">:</span><span class="n">int</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="o">?</span><span class="n">end1</span><span class="o">:</span><span class="n">int</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">idx2</span><span class="o">:</span><span class="n">int</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="k">&#39;</span><span class="n">T</span><span class="bp">[]</span>
<span class="k">type</span><span class="w"> </span><span class="k">&#39;</span><span class="n">T</span><span class="o">[,,]</span><span class="w"> </span><span class="k">with</span>
<span class="w">    </span><span class="k">member</span><span class="w"> </span><span class="n">arr</span><span class="p">.</span><span class="nf">GetSlice</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="o">?</span><span class="n">start1</span><span class="o">:</span><span class="n">int</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="o">?</span><span class="n">end1</span><span class="o">:</span><span class="n">int</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="o">?</span><span class="n">start2</span><span class="o">:</span><span class="n">int</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="o">?</span><span class="n">end2</span><span class="o">:</span><span class="n">int</span><span class="w"> </span><span class="o">*</span>
<span class="w">                          </span><span class="o">?</span><span class="n">start3</span><span class="o">:</span><span class="n">int</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="o">?</span><span class="n">end3</span><span class="o">:</span><span class="n">int</span>
<span class="w">                            </span><span class="o">-&gt;</span><span class="w"> </span><span class="k">&#39;</span><span class="n">T</span><span class="o">[,,]</span>
<span class="k">type</span><span class="w"> </span><span class="k">&#39;</span><span class="n">T</span><span class="o">[,,,]</span><span class="w"> </span><span class="k">with</span>
<span class="w">    </span><span class="k">member</span><span class="w"> </span><span class="n">arr</span><span class="p">.</span><span class="nf">GetSlice</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="o">?</span><span class="n">start1</span><span class="o">:</span><span class="n">int</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="o">?</span><span class="n">end1</span><span class="o">:</span><span class="n">int</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="o">?</span><span class="n">start2</span><span class="o">:</span><span class="n">int</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="o">?</span><span class="n">end2</span><span class="o">:</span><span class="n">int</span><span class="w"> </span><span class="o">*</span>
<span class="w">                          </span><span class="o">?</span><span class="n">start3</span><span class="o">:</span><span class="n">int</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="o">?</span><span class="n">end3</span><span class="o">:</span><span class="n">int</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="o">?</span><span class="n">start4</span><span class="o">:</span><span class="n">int</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="o">?</span><span class="n">end4</span><span class="o">:</span><span class="n">int</span>
<span class="w">                            </span><span class="o">-&gt;</span><span class="w"> </span><span class="k">&#39;</span><span class="n">T</span><span class="o">[,,,]</span>
</code></pre></div>
<p>In addition, CIL array types of rank 1 to 4 are assumed to support a type extension that defines a
method <code>SetSlice</code> that has the following signature:</p>
<div class="highlight"><pre><span></span><code><span class="k">type</span><span class="w"> </span><span class="k">&#39;</span><span class="n">T</span><span class="bp">[]</span><span class="w"> </span><span class="k">with</span>
<span class="w">    </span><span class="k">member</span><span class="w"> </span><span class="n">arr</span><span class="p">.</span><span class="nf">SetSlice</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="o">?</span><span class="n">start1</span><span class="o">:</span><span class="n">int</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="o">?</span><span class="n">end1</span><span class="o">:</span><span class="n">int</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">values</span><span class="o">:</span><span class="n">T</span><span class="bp">[]</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">unit</span>

<span class="k">type</span><span class="w"> </span><span class="k">&#39;</span><span class="n">T</span><span class="o">[,]</span><span class="w"> </span><span class="k">with</span>
<span class="w">    </span><span class="k">member</span><span class="w"> </span><span class="n">arr</span><span class="p">.</span><span class="nf">SetSlice</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="o">?</span><span class="n">start1</span><span class="o">:</span><span class="n">int</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="o">?</span><span class="n">end1</span><span class="o">:</span><span class="n">int</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="o">?</span><span class="n">start2</span><span class="o">:</span><span class="n">int</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="o">?</span><span class="n">end2</span><span class="o">:</span><span class="n">int</span><span class="w"> </span><span class="o">*</span>
<span class="w">                          </span><span class="n">values</span><span class="o">:</span><span class="n">T</span><span class="o">[,]</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">unit</span>
<span class="w">    </span><span class="k">member</span><span class="w"> </span><span class="n">arr</span><span class="p">.</span><span class="nf">SetSlice</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">idx1</span><span class="o">:</span><span class="n">int</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="o">?</span><span class="n">start2</span><span class="o">:</span><span class="n">int</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="o">?</span><span class="n">end2</span><span class="o">:</span><span class="n">int</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">values</span><span class="o">:</span><span class="n">T</span><span class="bp">[]</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">unit</span>
<span class="w">    </span><span class="k">member</span><span class="w"> </span><span class="n">arr</span><span class="p">.</span><span class="nf">SetSlice</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="o">?</span><span class="n">start1</span><span class="o">:</span><span class="n">int</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="o">?</span><span class="n">end1</span><span class="o">:</span><span class="n">int</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">idx2</span><span class="o">:</span><span class="n">int</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">values</span><span class="o">:</span><span class="n">T</span><span class="bp">[]</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">unit</span>

<span class="k">type</span><span class="w"> </span><span class="k">&#39;</span><span class="n">T</span><span class="o">[,,]</span><span class="w"> </span><span class="k">with</span>
<span class="w">    </span><span class="k">member</span><span class="w"> </span><span class="n">arr</span><span class="p">.</span><span class="nf">SetSlice</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="o">?</span><span class="n">start1</span><span class="o">:</span><span class="n">int</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="o">?</span><span class="n">end1</span><span class="o">:</span><span class="n">int</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="o">?</span><span class="n">start2</span><span class="o">:</span><span class="n">int</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="o">?</span><span class="n">end2</span><span class="o">:</span><span class="n">int</span><span class="w"> </span><span class="o">*</span>
<span class="w">                          </span><span class="o">?</span><span class="n">start3</span><span class="o">:</span><span class="n">int</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="o">?</span><span class="n">end3</span><span class="o">:</span><span class="n">int</span><span class="w"> </span><span class="o">*</span>
<span class="w">                          </span><span class="n">values</span><span class="o">:</span><span class="n">T</span><span class="o">[,,]</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">unit</span>

<span class="k">type</span><span class="w"> </span><span class="k">&#39;</span><span class="n">T</span><span class="o">[,,,]</span><span class="w"> </span><span class="k">with</span>
<span class="w">    </span><span class="k">member</span><span class="w"> </span><span class="n">arr</span><span class="p">.</span><span class="nf">SetSlice</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="o">?</span><span class="n">start1</span><span class="o">:</span><span class="n">int</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="o">?</span><span class="n">end1</span><span class="o">:</span><span class="n">int</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="o">?</span><span class="n">start2</span><span class="o">:</span><span class="n">int</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="o">?</span><span class="n">end2</span><span class="o">:</span><span class="n">int</span><span class="w"> </span><span class="o">*</span>
<span class="w">                          </span><span class="o">?</span><span class="n">start3</span><span class="o">:</span><span class="n">int</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="o">?</span><span class="n">end3</span><span class="o">:</span><span class="n">int</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="o">?</span><span class="n">start4</span><span class="o">:</span><span class="n">int</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="o">?</span><span class="n">end4</span><span class="o">:</span><span class="n">int</span><span class="w"> </span><span class="o">*</span>
<span class="w">                          </span><span class="n">values</span><span class="o">:</span><span class="n">T</span><span class="o">[,,,]</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">unit</span>
</code></pre></div>
<h3 id="648-member-constraint-invocation-expressions">6.4.8 Member Constraint Invocation Expressions</h3>
<p>An expression of the following form is a member constraint invocation expression:</p>
<div class="highlight"><pre><span></span><code>(static-typars : (member-sig) expr)
</code></pre></div>
<p>Type checking proceeds as follows:</p>
<ol>
<li>The expression is checked with initial type <code>ty</code>.</li>
<li>A statically resolved member constraint is applied (<a href="../types-and-type-constraints/#523-member-constraints">§5.2.3</a>):
    <br><code>static-typars: (member-sig)</code></li>
<li><code>ty</code> is asserted to be equal to the return type of the constraint.</li>
<li><code>expr</code> is checked with an initial type that corresponds to the argument types of the constraint.</li>
</ol>
<p>The elaborated form of the expression is a member invocation. For example:</p>
<div class="highlight"><pre><span></span><code><span class="k">let</span><span class="w"> </span><span class="nv">inline</span><span class="w"> </span><span class="n">speak</span><span class="w"> </span><span class="o">(</span><span class="n">a</span><span class="o">:</span><span class="w"> </span><span class="o">^</span><span class="n">a</span><span class="o">)</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="k">let</span><span class="w"> </span><span class="nv">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">(^</span><span class="n">a</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="o">(</span><span class="k">member</span><span class="w"> </span><span class="n">Speak</span><span class="o">:</span><span class="w"> </span><span class="kt">unit</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">string</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">a</span><span class="o">))</span>
<span class="w">    </span><span class="n">printfn</span><span class="w"> </span><span class="s">&quot;It said: %s&quot;</span><span class="w"> </span><span class="n">x</span>
<span class="w">    </span><span class="k">let</span><span class="w"> </span><span class="nv">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">(^</span><span class="n">a</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="o">(</span><span class="k">member</span><span class="w"> </span><span class="n">MakeNoise</span><span class="o">:</span><span class="w"> </span><span class="kt">unit</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">string</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="n">a</span><span class="o">))</span>
<span class="w">    </span><span class="n">printfn</span><span class="w"> </span><span class="s">&quot;Then it went: %s&quot;</span><span class="w"> </span><span class="n">y</span>

<span class="k">type</span><span class="w"> </span><span class="nc">Duck</span><span class="bp">()</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="k">member</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="nf">Speak</span><span class="bp">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;I&#39;m a duck&quot;</span>
<span class="w">    </span><span class="k">member</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="nf">MakeNoise</span><span class="bp">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;quack&quot;</span>
<span class="k">type</span><span class="w"> </span><span class="nc">Dog</span><span class="bp">()</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="k">member</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="nf">Speak</span><span class="bp">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;I&#39;m a dog&quot;</span>
<span class="w">    </span><span class="k">member</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="nf">MakeNoise</span><span class="bp">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;grrrr&quot;</span>

<span class="k">let</span><span class="w"> </span><span class="nv">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Duck</span><span class="bp">()</span>
<span class="k">let</span><span class="w"> </span><span class="nv">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Dog</span><span class="bp">()</span>
<span class="n">speak</span><span class="w"> </span><span class="n">x</span>
<span class="n">speak</span><span class="w"> </span><span class="n">y</span>
</code></pre></div>
<p>Outputs:</p>
<div class="highlight"><pre><span></span><code>It said: I&#39;m a duck
Then it went: quack
It said: I&#39;m a dog
Then it went: grrrr
</code></pre></div>
<h3 id="649-assignment-expressions">6.4.9 Assignment Expressions</h3>
<p>An expression of the following form is an <em>assignment expression</em> :</p>
<div class="highlight"><pre><span></span><code><span class="n">expr1</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">expr2</span>
</code></pre></div>
<p>A modified version of <em>Unqualified Lookup</em> (<a href="../inference-procedures/#1421-unqualified-lookup">§14.2.1</a>) is applied to the expression <code>expr1</code> using a fresh
expected result type <code>ty</code> , thus producing an elaborate expression <code>expr1</code>. The last qualification for <code>expr1</code>
must resolve to one of the following constructs:</p>
<ul>
<li>
<p>An invocation of a property with a setter method. The property may be an indexer.</p>
<p>Type checking incorporates <code>expr2</code> as the last argument in the method application resolution for
the setter method. The overall elaborated expression is a method call to this setter property and
includes the last argument.</p>
</li>
<li>
<p>A mutable value <code>path</code> of type <code>ty</code>.</p>
<p>Type checking of <code>expr2</code> uses the expected result type <code>ty</code> and generates an elaborated expression
<code>expr2</code>. The overall elaborated expression is an assignment to a value reference <code>&amp;path &lt;-stobj expr2</code>.</p>
</li>
<li>
<p>A reference to a value <code>path</code> of type <code>byref&lt;ty&gt;</code>.</p>
<p>Type checking of <code>expr2</code> uses the expected result type <code>ty</code> and generates an elaborated expression
<code>expr2</code>. The overall elaborated expression is an assignment to a value reference <code>path &lt;-stobj expr2</code>.</p>
</li>
<li>
<p>A reference to a mutable field <code>expr1a.field</code> with the actual result type <code>ty</code>.</p>
<p>Type checking of <code>expr2</code> uses the expected result type <code>ty</code> and generates an elaborated expression
<code>expr2</code>. The overall elaborated expression is an assignment to a field (see <a href="./#694-taking-the-address-of-an-elaborated-expression">§6.9.4</a>):</p>
<p><code>AddressOf(expr1a.field, DefinitelyMutates) &lt;-stobj expr2</code></p>
</li>
<li>
<p>A array lookup <code>expr1a.[expr1b]</code> where <code>expr1a</code> has type <code>ty[]</code>.</p>
<p>Type checking of expr2 uses the expected result type ty and generates thean elaborated
expression expr2. The overall elaborated expression is an assignment to a field (see <a href="./#694-taking-the-address-of-an-elaborated-expression">§6.9.4</a>):</p>
<p><code>AddressOf(expr1a.[expr1b], DefinitelyMutates) &lt;-stobj expr2</code></p>
<blockquote>
<p>Note: Because assignments have the preceding interpretations, local values must be
mutable so that primitive field assignments and array lookups can mutate their
immediate contents. In this context, “immediate” contents means the contents of a
mutable value type. For example, given</p>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="o">[&lt;</span><span class="n">Struct</span><span class="o">&gt;]</span>
<span class="k">type</span><span class="w"> </span><span class="nc">SA</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="k">new</span><span class="o">(</span><span class="n">v</span><span class="o">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">}</span>
<span class="w">    </span><span class="k">val</span><span class="w"> </span><span class="k">mutable</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">int</span>

<span class="o">[&lt;</span><span class="n">Struct</span><span class="o">&gt;]</span>
<span class="k">type</span><span class="w"> </span><span class="nc">SB</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="k">new</span><span class="o">(</span><span class="n">v</span><span class="o">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="n">sa</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">}</span>
<span class="w">    </span><span class="k">val</span><span class="w"> </span><span class="k">mutable</span><span class="w"> </span><span class="n">sa</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">SA</span>

<span class="k">let</span><span class="w"> </span><span class="nv">s1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SA</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
<span class="k">let</span><span class="w"> </span><span class="nv">mutable</span><span class="w"> </span><span class="n">s2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SA</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
<span class="k">let</span><span class="w"> </span><span class="nv">s3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SB</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
<span class="k">let</span><span class="w"> </span><span class="nv">mutable</span><span class="w"> </span><span class="n">s4</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SB</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
</code></pre></div>
<blockquote>
<p>Then these are not permitted:</p>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="n">s1</span><span class="o">.</span><span class="n">x</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="mi">3</span>
<span class="n">s3</span><span class="o">.</span><span class="n">sa</span><span class="o">.</span><span class="n">x</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="mi">3</span>
</code></pre></div>
<p>and these are:</p>
<div class="highlight"><pre><span></span><code><span class="n">s2</span><span class="o">.</span><span class="n">x</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="mi">3</span>
<span class="n">s4</span><span class="o">.</span><span class="n">sa</span><span class="o">.</span><span class="n">x</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="mi">3</span>
<span class="n">s4</span><span class="o">.</span><span class="n">sa</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">SA</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span>
</code></pre></div>
</li>
</ul>
<h2 id="65-control-flow-expressions">6.5 Control Flow Expressions</h2>
<h3 id="651-parenthesized-and-block-expressions">6.5.1 Parenthesized and Block Expressions</h3>
<p>A <em>parenthesized expression</em> has the following form:</p>
<div class="highlight"><pre><span></span><code>(expr)
</code></pre></div>
<p>A <em>block expression</em> has the following form:</p>
<div class="highlight"><pre><span></span><code>begin expr end
</code></pre></div>
<p>The expression <code>expr</code> is checked with the same initial type as the overall expression.</p>
<p>The elaborated form of the expression is simply the elaborated form of <code>expr</code>.</p>
<h3 id="652-sequential-execution-expressions">6.5.2 Sequential Execution Expressions</h3>
<p>A <em>sequential execution expression</em> has the following form:</p>
<div class="highlight"><pre><span></span><code>expr1 ; expr2
</code></pre></div>
<p>For example:</p>
<div class="highlight"><pre><span></span><code><span class="n">printfn</span><span class="w"> </span><span class="s">&quot;Hello&quot;</span><span class="o">;</span><span class="w"> </span><span class="n">printfn</span><span class="w"> </span><span class="s">&quot;World&quot;</span><span class="o">;</span><span class="w"> </span><span class="mi">3</span>
</code></pre></div>
<p>The <code>;</code> token is optional when both of the following are true:</p>
<ul>
<li>
<p>The expression <code>expr2</code> occurs on a subsequent line that starts in the same column as <code>expr1</code>.</p>
</li>
<li>
<p>The current pre-parse context that results from the syntax analysis of the program text is a
    <code>SeqBlock</code> (<a href="../lexical-filtering/#15-lexical-filtering">§15.</a>).</p>
</li>
</ul>
<p>When the semicolon is optional, parsing inserts a <code>$sep</code> token automatically and applies an additional
syntax rule for lightweight syntax (<a href="../lexical-filtering/#1511-basic-lightweight-syntax-rules-by-example">§15.1.1</a>). In practice, this means that code can omit the <code>;</code> token
for sequential execution expressions that implement functions or immediately follow tokens such as
<code>begin</code> and <code>(</code>.</p>
<p>The expression <code>expr1</code> is checked with an arbitrary initial type <code>ty</code>. After checking <code>expr1</code>, <code>ty</code> is asserted
to be equal to <code>unit</code>. If the assertion fails, a warning rather than an error is reported. The expression
<code>expr2</code> is then checked with the same initial type as the overall expression.</p>
<p>Sequential execution expressions are a primitive elaborated form.</p>
<h3 id="653-conditional-expressions">6.5.3 Conditional Expressions</h3>
<p>A <em>conditional expression</em> has the following forms</p>
<div class="highlight"><pre><span></span><code>if expr1a then expr1b
elif expr3a then expr2b
...
elif exprna then exprnb
else exprlast
</code></pre></div>
<p>The <code>elif</code> and <code>else</code> branches may be omitted. For example:</p>
<div class="highlight"><pre><span></span><code><span class="k">if</span><span class="w"> </span><span class="o">(</span><span class="mi">1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="o">)</span><span class="w"> </span><span class="k">then</span><span class="w"> </span><span class="s">&quot;ok&quot;</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="s">&quot;not ok&quot;</span>
<span class="k">if</span><span class="w"> </span><span class="o">(</span><span class="mi">1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="o">)</span><span class="w"> </span><span class="k">then</span><span class="w"> </span><span class="n">printfn</span><span class="w"> </span><span class="s">&quot;ok&quot;</span>
</code></pre></div>
<p>Conditional expressions are equivalent to pattern matching on Boolean values. For example, the
following expression forms are equivalent:</p>
<div class="highlight"><pre><span></span><code>if expr1 then expr2 else expr3
match (expr1: bool) with true -&gt; expr2 | false -&gt; expr3
</code></pre></div>
<p>If the <code>else</code> branch is omitted, the expression is a <em>sequential conditional expression</em> and is equivalent
to:</p>
<div class="highlight"><pre><span></span><code>match (expr1: bool) with true -&gt; expr2 | false -&gt; ()
</code></pre></div>
<p>with the exception that the initial type of the overall expression is first asserted to be <code>unit</code>.</p>
<h3 id="654-shortcut-operator-expressions">6.5.4 Shortcut Operator Expressions</h3>
<p>Under default definitions, expressions of the following form are respectively an <em>shortcut and expression</em> and a <em>shortcut or expression</em> :</p>
<div class="highlight"><pre><span></span><code>expr &amp;&amp; expr
expr || expr
</code></pre></div>
<p>These expressions are defined by their syntactic translation:</p>
<div class="highlight"><pre><span></span><code>expr1 &amp;&amp; expr2 → if expr1 then expr2 else false
expr1 || expr2 → if expr1 then true else expr2
</code></pre></div>
<blockquote>
<p>Note: The rules in this section apply when the following operators, as defined in the F#
    core library, are applied to two arguments.
    <br><code>FSharp.Core.LanguagePrimitives.IntrinsicOperators.(&amp;&amp;)</code>
    <br><code>FSharp.Core.LanguagePrimitives.IntrinsicOperators.(||)</code>
    <br>
    If the operator is not immediately applied to two arguments, it is interpreted as a strict
    function that evaluates both its arguments before use.</p>
</blockquote>
<h3 id="655-pattern-matching-expressions-and-functions">6.5.5 Pattern-Matching Expressions and Functions</h3>
<p>A <em>pattern-matching expression</em> has the following form:</p>
<div class="highlight"><pre><span></span><code>match expr with rules
</code></pre></div>
<p>Pattern matching is used to evaluate the given expression and select a rule (<a href="../patterns/#7-patterns">§7.</a>). For example:</p>
<div class="highlight"><pre><span></span><code><span class="k">match</span><span class="w"> </span><span class="o">(</span><span class="mi">3</span><span class="o">,</span><span class="w"> </span><span class="mi">2</span><span class="o">)</span><span class="w"> </span><span class="k">with</span>
<span class="o">|</span><span class="w"> </span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">printfn</span><span class="w"> </span><span class="s">&quot;j = %d&quot;</span><span class="w"> </span><span class="n">j</span>
<span class="o">|</span><span class="w"> </span><span class="n">i</span><span class="o">,</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">printfn</span><span class="w"> </span><span class="s">&quot;i = %d&quot;</span><span class="w"> </span><span class="n">i</span>
<span class="o">|</span><span class="w"> </span><span class="o">_</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">printfn</span><span class="w"> </span><span class="s">&quot;no match&quot;</span>
</code></pre></div>
<p>A <em>pattern-matching function</em> is an expression of the following form:</p>
<div class="highlight"><pre><span></span><code>function rules
</code></pre></div>
<p>A pattern-matching function is syntactic sugar for a single-argument function expression that is
followed by immediate matches on the argument. For example:</p>
<div class="highlight"><pre><span></span><code><span class="k">function</span>
<span class="o">|</span><span class="w"> </span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">printfn</span><span class="w"> </span><span class="s">&quot;j = %d&quot;</span><span class="w"> </span><span class="n">j</span>
<span class="o">|</span><span class="w"> </span><span class="o">_</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">printfn</span><span class="w"> </span><span class="s">&quot;no match&quot;</span>
</code></pre></div>
<p>is syntactic sugar for the following, where x is a fresh variable:</p>
<div class="highlight"><pre><span></span><code><span class="k">fun</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">-&gt;</span>
<span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="k">with</span>
<span class="w">    </span><span class="o">|</span><span class="w"> </span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">printfn</span><span class="w"> </span><span class="s">&quot;j = %d&quot;</span><span class="w"> </span><span class="n">j</span>
<span class="w">    </span><span class="o">|</span><span class="w"> </span><span class="o">_</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">printfn</span><span class="w"> </span><span class="s">&quot;no match&quot;</span>
</code></pre></div>
<h3 id="656-sequence-iteration-expressions">6.5.6 Sequence Iteration Expressions</h3>
<p>An expression of the following form is a <em>sequence iteration expression</em> :</p>
<div class="highlight"><pre><span></span><code>for pat in expr1 do expr2 done
</code></pre></div>
<p>The done token is optional if <code>expr2</code> appears on a later line and is indented from the column position
of the for token. In this case, parsing inserts a <code>$done</code> token automatically and applies an additional
syntax rule for lightweight syntax (<a href="../lexical-filtering/#1511-basic-lightweight-syntax-rules-by-example">§15.1.1</a>).</p>
<p>For example:</p>
<div class="highlight"><pre><span></span><code><span class="k">for</span><span class="w"> </span><span class="n">x</span><span class="o">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="o">[(</span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="mi">2</span><span class="o">);</span><span class="w"> </span><span class="o">(</span><span class="mi">3</span><span class="o">,</span><span class="w"> </span><span class="mi">4</span><span class="o">)]</span><span class="w"> </span><span class="k">do</span>
<span class="w">    </span><span class="n">printfn</span><span class="w"> </span><span class="s">&quot;x = %d, y = %d&quot;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span>
</code></pre></div>
<p>The expression <code>expr1</code> is checked with a fresh initial type <code>tyexpr</code>, which is then asserted to be a subtype
of type <code>IEnumerable&lt;ty&gt;</code>, for a fresh type <code>ty</code>. If the assertion succeeds, the expression elaborates to
the following, where <code>v</code> is of type <code>IEnumerator&lt;ty&gt;</code> and <code>pat</code> is a pattern of type <code>ty</code> :</p>
<div class="highlight"><pre><span></span><code><span class="k">let</span><span class="w"> </span><span class="nv">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">expr1</span><span class="o">.</span><span class="n">GetEnumerator</span><span class="bp">()</span>
<span class="k">try</span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="o">(</span><span class="n">v</span><span class="o">.</span><span class="n">MoveNext</span><span class="bp">()</span><span class="o">)</span><span class="w"> </span><span class="k">do</span>
<span class="w">        </span><span class="k">match</span><span class="w"> </span><span class="n">v</span><span class="o">.</span><span class="n">Current</span><span class="w"> </span><span class="k">with</span>
<span class="w">        </span><span class="o">|</span><span class="w"> </span><span class="n">pat</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">expr2</span>
<span class="w">        </span><span class="o">|</span><span class="w"> </span><span class="o">_</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="bp">()</span>
<span class="k">finally</span>
<span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="n">box</span><span class="o">(</span><span class="n">v</span><span class="o">)</span><span class="w"> </span><span class="k">with</span>
<span class="w">    </span><span class="o">|</span><span class="w"> </span><span class="o">:?</span><span class="w"> </span><span class="nn">System</span><span class="p">.</span><span class="n">IDisposable</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="o">.</span><span class="n">Dispose</span><span class="bp">()</span>
<span class="w">    </span><span class="o">|</span><span class="w"> </span><span class="o">_</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="bp">()</span>
</code></pre></div>
<p>If the assertion fails, the type <code>tyexpr</code> may also be of any static type that satisfies the “collection
pattern” of CLI libraries. If so, the <em>enumerable extraction</em> process is used to enumerate the type. In
particular, <code>tyexpr</code> may be any type that has an accessible GetEnumerator method that accepts zero
arguments and returns a value that has accessible MoveNext and Current properties. The type of <code>pat</code>
is the same as the return type of the Current property on the enumerator value. However, if the
Current property has return type obj and the collection type <code>ty</code> has an Item property with a more
specific (non-object) return type <code>ty2</code> , type <code>ty2</code> is used instead, and a dynamic cast is inserted to
convert v.Current to <code>ty2</code>.</p>
<p>A sequence iteration of the form</p>
<div class="highlight"><pre><span></span><code>for var in expr1 .. expr2 do expr3 done
</code></pre></div>
<p>where the type of <code>expr1</code> or <code>expr2</code> is equivalent to <code>int</code>, is elaborated as a simple for-loop expression
(<a href="./#657-simple-for-loop-expressions">§6.5.7</a>)</p>
<h3 id="657-simple-for-loop-expressions">6.5.7 Simple for-Loop Expressions</h3>
<p>An expression of the following form is a <em>simple for loop expression</em> :</p>
<div class="highlight"><pre><span></span><code>for var = expr1 to expr2 do expr3 done
</code></pre></div>
<p>The <code>done</code> token is optional when <code>e2</code> appears on a later line and is indented from the column position
of the <code>for</code> token. In this case, a <code>$done</code> token is automatically inserted, and an additional syntax rule
for lightweight syntax applies (<a href="../lexical-filtering/#1511-basic-lightweight-syntax-rules-by-example">§15.1.1</a>). For example:</p>
<div class="highlight"><pre><span></span><code><span class="k">for</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="mi">30</span><span class="w"> </span><span class="k">do</span>
<span class="w">    </span><span class="n">printfn</span><span class="w"> </span><span class="s">&quot;x = %d, x^2 = %d&quot;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">(</span><span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="o">)</span>
</code></pre></div>
<p>The bounds <code>expr1</code> and <code>expr2</code> are checked with initial type <code>int</code>. The overall type of the expression is
<code>unit</code>. A warning is reported if the body <code>expr3</code> of the <code>for</code> loop does not have static type <code>unit</code>.</p>
<p>The following shows the elaborated form of a simple for-loop expression for fresh variables <code>start</code>
and <code>finish</code>:</p>
<div class="highlight"><pre><span></span><code><span class="k">let</span><span class="w"> </span><span class="nv">start</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">expr1</span><span class="w"> </span><span class="k">in</span>
<span class="k">let</span><span class="w"> </span><span class="nv">finish</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">expr2</span><span class="w"> </span><span class="k">in</span>
<span class="k">for</span><span class="w"> </span><span class="n">var</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">start</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="n">finish</span><span class="w"> </span><span class="k">do</span><span class="w"> </span><span class="n">expr3</span><span class="w"> </span><span class="k">done</span>
</code></pre></div>
<p>For-loops over ranges that are specified by variables are a primitive elaborated form. When
executed, the iterated range includes both the starting and ending values in the range, with an
increment of 1.</p>
<p>An expression of the form</p>
<div class="highlight"><pre><span></span><code>for var in expr1 .. expr2 do expr3 done
</code></pre></div>
<p>is always elaborated as a simple for-loop expression whenever the type of <code>expr1</code> or <code>expr2</code> is
equivalent to <code>int</code>.</p>
<h3 id="658-while-expressions">6.5.8 While Expressions</h3>
<p>A <em>while loop expression</em> has the following form:</p>
<div class="highlight"><pre><span></span><code>while expr1 do expr2 done
</code></pre></div>
<p>The <code>done</code> token is optional when <code>expr2</code> appears on a subsequent line and is indented from the
column position of the <code>while</code>. In this case, a <code>$done</code> token is automatically inserted, and an additional
syntax rule for lightweight syntax applies (<a href="../lexical-filtering/#1511-basic-lightweight-syntax-rules-by-example">§15.1.1</a>).</p>
<p>For example:</p>
<div class="highlight"><pre><span></span><code><span class="k">while</span><span class="w"> </span><span class="nn">System</span><span class="p">.</span><span class="nn">DateTime</span><span class="p">.</span><span class="nn">Today</span><span class="p">.</span><span class="n">DayOfWeek</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nn">System</span><span class="p">.</span><span class="nn">DayOfWeek</span><span class="p">.</span><span class="n">Monday</span><span class="w"> </span><span class="k">do</span>
<span class="w">    </span><span class="n">printfn</span><span class="w"> </span><span class="s">&quot;I don&#39;t like Mondays&quot;</span>
</code></pre></div>
<p>The overall type of the expression is <code>unit</code>. The expression <code>expr1</code> is checked with initial type <code>bool</code>. A
warning is reported if the body <code>expr2</code> of the while loop cannot be asserted to have type <code>unit</code>.</p>
<h3 id="659-try-with-expressions">6.5.9 Try-with Expressions</h3>
<p>A <em>try-with expression</em> has the following form:</p>
<div class="highlight"><pre><span></span><code>try expr with rules
</code></pre></div>
<p>For example:</p>
<div class="highlight"><pre><span></span><code><span class="k">try</span><span class="w"> </span><span class="s">&quot;1&quot;</span><span class="w"> </span><span class="k">with</span><span class="w"> </span><span class="o">_</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="s">&quot;2&quot;</span>

<span class="k">try</span>
<span class="w">    </span><span class="n">failwith</span><span class="w"> </span><span class="s">&quot;fail&quot;</span>
<span class="k">with</span>
<span class="w">    </span><span class="o">|</span><span class="w"> </span><span class="n">Failure</span><span class="w"> </span><span class="n">msg</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="s">&quot;caught&quot;</span>
<span class="w">    </span><span class="o">|</span><span class="w"> </span><span class="o">:?</span><span class="w"> </span><span class="nn">System</span><span class="p">.</span><span class="n">InvalidOperationException</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="s">&quot;unexpected&quot;</span>
</code></pre></div>
<p>Expression <code>expr</code> is checked with the same initial type as the overall expression. The pattern matching
clauses are then checked with the same initial type and with input type <code>System.Exception</code>.</p>
<p>Try-with expressions are a primitive elaborated form.</p>
<h3 id="6510-reraise-expressions">6.5.10 Reraise Expressions</h3>
<p>A <em>reraise expression</em> is an application of the <code>reraise</code> F# library function. This function must be
applied to an argument and can be used only on the immediate right-hand side of <code>rules</code> in a try-with
expression.</p>
<div class="highlight"><pre><span></span><code><span class="k">try</span>
<span class="w">    </span><span class="n">failwith</span><span class="w"> </span><span class="s">&quot;fail&quot;</span>
<span class="k">with</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">printfn</span><span class="w"> </span><span class="s">&quot;Failing&quot;</span><span class="o">;</span><span class="w"> </span><span class="n">reraise</span><span class="bp">()</span>
</code></pre></div>
<blockquote>
<p>Note: The rules in this section apply to any use of the function
  <code>FSharp.Core.Operators.reraise</code>, which is defined in the F# core library.</p>
</blockquote>
<p>When executed, <code>reraise()</code> continues exception processing with the original exception information.</p>
<h3 id="6511-try-finally-expressions">6.5.11 Try-finally Expressions</h3>
<p>A <em>try-finally expression</em> has the following form:</p>
<div class="highlight"><pre><span></span><code>try expr1 finally expr2
</code></pre></div>
<p>For example:</p>
<div class="highlight"><pre><span></span><code><span class="k">try</span><span class="w"> </span><span class="s">&quot;1&quot;</span><span class="w"> </span><span class="k">finally</span><span class="w"> </span><span class="n">printfn</span><span class="w"> </span><span class="s">&quot;Finally!&quot;</span>

<span class="k">try</span>
<span class="w">    </span><span class="n">failwith</span><span class="w"> </span><span class="s">&quot;fail&quot;</span>
<span class="k">finally</span>
<span class="w">    </span><span class="n">printfn</span><span class="w"> </span><span class="s">&quot;Finally block&quot;</span>
</code></pre></div>
<p>Expression <code>expr1</code> is checked with the initial type of the overall expression. Expression <code>expr2</code> is
checked with arbitrary initial type, and a warning occurs if this type cannot then be asserted to be
equal to <code>unit</code>.</p>
<p>Try-finally expressions are a primitive elaborated form.</p>
<h3 id="6512-assertion-expressions">6.5.12 Assertion Expressions</h3>
<p>An <em>assertion expression</em> has the following form:</p>
<div class="highlight"><pre><span></span><code>assert expr
</code></pre></div>
<p>The expression <code>assert expr</code> is syntactic sugar for <code>System.Diagnostics.Debug.Assert(expr)</code></p>
<blockquote>
<p>Note: <code>System.Diagnostics.Debug.Assert</code> is a conditional method call. This means that
assertions are triggered only if the DEBUG conditional compilation symbol is defined.</p>
</blockquote>
<h2 id="66-definition-expressions">6.6 Definition Expressions</h2>
<p>A <em>definition expression</em> has one of the following forms:</p>
<div class="highlight"><pre><span></span><code>let function-defn in expr
let value-defn in expr
let rec function-or-value-defns in expr
use ident = expr1 in expr
</code></pre></div>
<p>Such an expression establishes a local function or value definition within the lexical scope of <code>expr</code>
and has the same overall type as <code>expr</code>.</p>
<p>In each case, the <code>in</code> token is optional if <code>expr</code> appears on a subsequent line and is aligned with the
token <code>let</code>. In this case, a <code>$in</code> token is automatically inserted, and an additional syntax rule for
lightweight syntax applies (<a href="../lexical-filtering/#1511-basic-lightweight-syntax-rules-by-example">§15.1.1</a>)</p>
<p>For example:</p>
<div class="highlight"><pre><span></span><code><span class="k">let</span><span class="w"> </span><span class="nv">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span>
<span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">x</span>
</code></pre></div>
<p>and</p>
<div class="highlight"><pre><span></span><code><span class="k">let</span><span class="w"> </span><span class="nv">x</span><span class="o">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">(</span><span class="s">&quot;One&quot;</span><span class="o">,</span><span class="w"> </span><span class="mi">1</span><span class="o">)</span>
<span class="n">x</span><span class="o">.</span><span class="n">Length</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span>
</code></pre></div>
<p>and</p>
<div class="highlight"><pre><span></span><code><span class="k">let</span><span class="w"> </span><span class="nv">id</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="o">(</span><span class="n">id</span><span class="w"> </span><span class="mi">3</span><span class="o">,</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="s">&quot;Three&quot;</span><span class="o">)</span>
</code></pre></div>
<p>and</p>
<div class="highlight"><pre><span></span><code><span class="k">let</span><span class="w"> </span><span class="nv">swap</span><span class="w"> </span><span class="o">(</span><span class="n">x</span><span class="o">,</span><span class="w"> </span><span class="n">y</span><span class="o">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">(</span><span class="n">y</span><span class="o">,</span><span class="n">x</span><span class="o">)</span>
<span class="nn">List</span><span class="p">.</span><span class="n">map</span><span class="w"> </span><span class="n">swap</span><span class="w"> </span><span class="o">[</span><span class="w"> </span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="mi">2</span><span class="o">);</span><span class="w"> </span><span class="o">(</span><span class="mi">3</span><span class="o">,</span><span class="w"> </span><span class="mi">4</span><span class="o">)</span><span class="w"> </span><span class="o">]</span>
</code></pre></div>
<p>and</p>
<div class="highlight"><pre><span></span><code><span class="k">let</span><span class="w"> </span><span class="nv">K</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="nn">List</span><span class="p">.</span><span class="n">map</span><span class="w"> </span><span class="o">(</span><span class="n">K</span><span class="w"> </span><span class="mi">3</span><span class="o">)</span><span class="w"> </span><span class="o">[</span><span class="w"> </span><span class="mi">1</span><span class="o">;</span><span class="w"> </span><span class="mi">2</span><span class="o">;</span><span class="w"> </span><span class="mi">3</span><span class="o">;</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="o">]</span>
</code></pre></div>
<p>Function and value definitions in expressions are similar to function and value definitions in class
definitions (<a href="../type-definitions/#86-class-type-definitions">§8.6</a>), modules (<a href="../namespaces-and-modules/#1021-function-and-value-definitions-in-modules">§10.2.1</a>), and computation expressions (<a href="./#6310-computation-expressions">§6.3.10</a>), with the following
exceptions:</p>
<ul>
<li>Function and value definitions in expressions may not define explicit generic parameters (<a href="../types-and-type-constraints/#53-type-parameter-definitions">§5.3</a>).
    For example, the following expression is rejected:
       <br><code>let f&lt;'T&gt; (x:'T) = x in f 3</code></li>
<li>Function and value definitions in expressions are not public and are not subject to arity analysis
    (<a href="../inference-procedures/#1411-arity-inference">§14.11</a>).</li>
<li>Any custom attributes that are specified on the declaration, parameters, and/or return
    arguments are ignored and result in a warning. As a result, function and value definitions in
    expressions may not have the <code>ThreadStatic</code> or <code>ContextStatic</code> attribute.</li>
</ul>
<h3 id="661-value-definition-expressions">6.6.1 Value Definition Expressions</h3>
<p>A value definition expression has the following form:</p>
<div class="highlight"><pre><span></span><code>let value-defn in expr
</code></pre></div>
<p>where <em>value-defn</em> has the form:</p>
<div class="highlight"><pre><span></span><code>mutable? access? pat typar-defns? return-type? = rhs-expr
</code></pre></div>
<p>Checking proceeds as follows:</p>
<ol>
<li>
<p>Check the <em>value-defn</em> (<a href="../inference-procedures/#146-checking-and-elaborating-function-value-and-member-definitions">§14.6</a>), which defines a group of identifiers <code>identj</code> with inferred types <code>tyj</code></p>
</li>
<li>
<p>Add the identifiers <code>identj</code> to the name resolution environment, each with corresponding type
    <code>tyj</code>.</p>
</li>
<li>Check the body <code>expr</code> against the initial type of the overall expression.</li>
</ol>
<p>In this case, the following rules apply:</p>
<ul>
<li>
<p>If <code>pat</code> is a single value pattern <code>ident</code>, the resulting elaborated form of the entire expression is</p>
<div class="highlight"><pre><span></span><code>let ident1 &lt;typars1&gt; = expr1 in
body-expr
</code></pre></div>
<p>where ident1 , typars1 and expr1 are defined in <a href="../inference-procedures/#146-checking-and-elaborating-function-value-and-member-definitions">§14.6</a>.</p>
</li>
<li>
<p>Otherwise, the resulting elaborated form of the entire expression is</p>
<div class="highlight"><pre><span></span><code>let tmp &lt;typars1 ... typars n&gt; = expr in
let ident1 &lt;typars1&gt; = expr1 in
...
let identn &lt;typarsn&gt; = exprn in
body-expr
</code></pre></div>
<p>where <code>tmp</code> is a fresh identifier and <code>identi</code>, <code>typarsi</code>, and <code>expri</code> all result from the compilation of
the pattern <code>pat</code> (<a href="../patterns/#7-patterns">§7.</a>) against the input <code>tmp</code>.</p>
</li>
</ul>
<p>Value definitions in expressions may be marked as <code>mutable</code>. For example:</p>
<div class="highlight"><pre><span></span><code><span class="k">let</span><span class="w"> </span><span class="nv">mutable</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span>
<span class="k">while</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="k">do</span>
<span class="w">    </span><span class="n">v</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span>
<span class="w">    </span><span class="n">printfn</span><span class="w"> </span><span class="s">&quot;v = %d&quot;</span><span class="w"> </span><span class="n">v</span>
</code></pre></div>
<p>Such variables are implicitly dereferenced each time they are used.</p>
<h3 id="662-function-definition-expressions">6.6.2 Function Definition Expressions</h3>
<p>A function definition expression has the form:</p>
<div class="highlight"><pre><span></span><code>let function-defn in expr
</code></pre></div>
<p>where <code>function-defn</code> has the form:</p>
<div class="highlight"><pre><span></span><code>inline? access? ident-or-op typar-defns? pat1 ... patn return-type? = rhs-expr
</code></pre></div>
<p>Checking proceeds as follows:</p>
<ol>
<li>Check the <code>function-defn</code> (<a href="../inference-procedures/#146-checking-and-elaborating-function-value-and-member-definitions">§14.6</a>), which defines <code>ident1</code>, <code>ty1</code>, <code>typars1</code> and <code>expr1</code></li>
<li>Add the identifier <code>ident1</code> to the name resolution environment, each with corresponding type <code>ty1</code>.</li>
<li>Check the body <code>expr</code> against the initial type of the overall expression.</li>
</ol>
<p>The resulting elaborated form of the entire expression is</p>
<div class="highlight"><pre><span></span><code>let ident1 &lt; typars1 &gt; = expr1 in
expr
</code></pre></div>
<p>where <code>ident1</code> , <code>typars1</code> and <code>expr1</code> are as defined in <a href="../inference-procedures/#146-checking-and-elaborating-function-value-and-member-definitions">§14.6</a>.</p>
<h3 id="663-recursive-definition-expressions">6.6.3 Recursive Definition Expressions</h3>
<p>An expression of the following form is a <em>recursive definition expression</em>:</p>
<div class="highlight"><pre><span></span><code>let rec function-or-value-defns in expr
</code></pre></div>
<p>The defined functions and values are available for use within their own definitions—that is can be
used within any of the expressions on the right-hand side of <code>function-or-value-defns</code>. Multiple
functions or values may be defined by using <code>let rec ... and ...</code>. For example:</p>
<div class="highlight"><pre><span></span><code><span class="k">let</span><span class="w"> </span><span class="nv">test</span><span class="bp">()</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="k">let</span><span class="w"> </span><span class="nv">rec</span><span class="w"> </span><span class="n">twoForward</span><span class="w"> </span><span class="n">count</span><span class="w"> </span><span class="o">=</span>
<span class="w">        </span><span class="n">printfn</span><span class="w"> </span><span class="s">&quot;at %d, taking two steps forward&quot;</span><span class="w"> </span><span class="n">count</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1000</span><span class="w"> </span><span class="k">then</span><span class="w"> </span><span class="s">&quot;got there!&quot;</span>
<span class="w">        </span><span class="k">else</span><span class="w"> </span><span class="n">oneBack</span><span class="w"> </span><span class="o">(</span><span class="n">count</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="o">)</span>
<span class="w">    </span><span class="ow">and</span><span class="w"> </span><span class="n">oneBack</span><span class="w"> </span><span class="n">count</span><span class="w"> </span><span class="o">=</span>
<span class="w">        </span><span class="n">printfn</span><span class="w"> </span><span class="s">&quot;at %d, taking one step back &quot;</span><span class="w"> </span><span class="n">count</span>
<span class="w">        </span><span class="n">twoForward</span><span class="w"> </span><span class="o">(</span><span class="n">count</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="o">)</span>

<span class="w">    </span><span class="n">twoForward</span><span class="w"> </span><span class="mi">1</span>

<span class="n">test</span><span class="bp">()</span>
</code></pre></div>
<p>In the example, the expression defines a set of recursive functions. If one or more recursive values
are defined, the recursive expressions are analyzed for safety (<a href="../inference-procedures/#1466-recursive-safety-analysis">§14.6.6</a>). This may result in warnings
(including some reported as compile-time errors) and runtime checks.</p>
<h3 id="664-deterministic-disposal-expressions">6.6.4 Deterministic Disposal Expressions</h3>
<p>A <em>deterministic disposal expression</em> has the form:</p>
<div class="highlight"><pre><span></span><code>use ident = expr1 in expr2
</code></pre></div>
<p>For example:</p>
<div class="highlight"><pre><span></span><code><span class="k">use</span><span class="w"> </span><span class="n">inStream</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nn">System</span><span class="p">.</span><span class="nn">IO</span><span class="p">.</span><span class="nn">File</span><span class="p">.</span><span class="n">OpenText</span><span class="w"> </span><span class="s">&quot;input.txt&quot;</span>
<span class="k">let</span><span class="w"> </span><span class="nv">line1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">inStream</span><span class="o">.</span><span class="n">ReadLine</span><span class="bp">()</span>
<span class="k">let</span><span class="w"> </span><span class="nv">line2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">inStream</span><span class="o">.</span><span class="n">ReadLine</span><span class="bp">()</span>
<span class="o">(</span><span class="n">line1</span><span class="o">,</span><span class="n">line2</span><span class="o">)</span>
</code></pre></div>
<p>The expression is first checked as an expression of form <code>let ident = expr1 in expr2</code> (<a href="./#661-value-definition-expressions">§6.6.1</a>), which results in an elaborated expression of the following form:</p>
<div class="highlight"><pre><span></span><code>let ident1 : ty1 = expr1 in expr2.
</code></pre></div>
<p>Only one value may be defined by a deterministic disposal expression, and the definition is not
generalized (<a href="../inference-procedures/#1467-generalization">§14.6.7</a>). The type <code>ty1</code> , is then asserted to be a subtype of <code>System.IDisposable</code>. If the
dynamic value of the expression after coercion to type <code>obj</code> is non-null, the <code>Dispose</code> method is called
on the value when the value goes out of scope. Thus the overall expression elaborates to this:</p>
<div class="highlight"><pre><span></span><code>let ident1 : ty1 = expr1
try expr2
finally (match ( ident :&gt; obj) with
         | null -&gt; ()
         | _ -&gt; (ident :&gt; System.IDisposable).Dispose())
</code></pre></div>
<h3 id="665-pinned-pointer-expressions">6.6.5 Pinned Pointer Expressions</h3>
<p>A <em>pinned pointer expression</em> allows a pointer to be extracted from an expression and bound to a name, preventing the value from being collected or moved by the garbage collector for the scope of the binding. This feature is intended for low-level programming scenarios.</p>
<p>A pinned pointer expression has the following form:</p>
<div class="highlight"><pre><span></span><code>use ident = fixed expr
</code></pre></div>
<p>For example, pinning a field within an object:</p>
<div class="highlight"><pre><span></span><code><span class="k">type</span><span class="w"> </span><span class="nc">Point</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="k">mutable</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">int</span><span class="o">;</span><span class="w"> </span><span class="k">mutable</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">int</span><span class="w"> </span><span class="o">}</span>

<span class="k">let</span><span class="w"> </span><span class="nv">pinObject</span><span class="bp">()</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="k">let</span><span class="w"> </span><span class="nv">point</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="o">;</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">}</span>
<span class="w">    </span><span class="k">use</span><span class="w"> </span><span class="n">p1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">fixed</span><span class="w"> </span><span class="o">&amp;</span><span class="n">point</span><span class="o">.</span><span class="n">x</span>
<span class="w">    </span><span class="c1">// code that uses p1 as a nativeptr&lt;int&gt;</span>
</code></pre></div>
<p>Pinning an array:</p>
<div class="highlight"><pre><span></span><code><span class="k">let</span><span class="w"> </span><span class="nv">pinArray</span><span class="bp">()</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="k">let</span><span class="w"> </span><span class="nv">arr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">[|</span><span class="w"> </span><span class="mi">0</span><span class="o">.</span><span class="mi">0</span><span class="o">;</span><span class="w"> </span><span class="mi">1</span><span class="o">.</span><span class="mi">5</span><span class="o">;</span><span class="w"> </span><span class="mi">2</span><span class="o">.</span><span class="mi">3</span><span class="w"> </span><span class="o">|]</span>
<span class="w">    </span><span class="k">use</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">fixed</span><span class="w"> </span><span class="n">arr</span>
<span class="w">    </span><span class="c1">// code that uses p as a nativeptr&lt;float&gt;</span>
</code></pre></div>
<p>Pinning a string:</p>
<div class="highlight"><pre><span></span><code><span class="k">let</span><span class="w"> </span><span class="nv">pinString</span><span class="bp">()</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="k">let</span><span class="w"> </span><span class="nv">str</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;Hello&quot;</span>
<span class="w">    </span><span class="k">use</span><span class="w"> </span><span class="n">pChar</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">fixed</span><span class="w"> </span><span class="n">str</span>
<span class="w">    </span><span class="c1">// code that uses pChar as a nativeptr&lt;char&gt;</span>
</code></pre></div>
<p>The <code>fixed</code> keyword is used to pin the expression and can only appear immediately to the right of a <code>use</code> binding. The pointer is fixed for the duration of the <code>use</code> binding's scope; once it goes out of scope, it is no longer pinned. This construct is not a try/finally <code>IDisposable</code> pattern but is instead used to define the scope of the pinning.</p>
<p>A <em>pinned pointer expression</em> is more efficient and convenient than creating a <code>GCHandle</code>.</p>
<p>Like all pointer-related code, the use of <code>fixed</code> is considered an unsafe feature and will result in a compiler warning. The use of <code>fixed</code> is restricted to expressions within functions or methods and cannot be used at the script or module level.</p>
<h2 id="67-type-related-expressions">6.7 Type-related Expressions</h2>
<h3 id="671-type-annotated-expressions">6.7.1 Type-Annotated Expressions</h3>
<p>A <em>type-annotated expression</em> has the following form, where <code>ty</code> indicates the static type of <code>expr</code>:</p>
<div class="highlight"><pre><span></span><code>expr : ty
</code></pre></div>
<p>For example:</p>
<div class="highlight"><pre><span></span><code><span class="o">(</span><span class="mi">1</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">int</span><span class="o">)</span>
<span class="k">let</span><span class="w"> </span><span class="nv">f</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">(</span><span class="n">x</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">string</span><span class="o">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">x</span>
</code></pre></div>
<p>When checked, the initial type of the overall expression is asserted to be equal to <code>ty</code>. Expression <code>expr</code>
is then checked with initial type <code>ty</code>. The expression elaborates to the elaborated form of <code>expr</code>. This
ensures that information from the annotation is used during the analysis of <code>expr</code> itself.</p>
<h3 id="672-static-coercion-expressions">6.7.2 Static Coercion Expressions</h3>
<p>A <em>static coercion expression</em> — also called a flexible type constraint — has the following form:</p>
<div class="highlight"><pre><span></span><code>expr :&gt; ty
</code></pre></div>
<p>The expression <code>upcast expr</code> is equivalent to <code>expr :&gt; _</code>, so the target type is the same as the initial
type of the overall expression. For example:</p>
<div class="highlight"><pre><span></span><code><span class="o">(</span><span class="mi">1</span><span class="w"> </span><span class="o">:&gt;</span><span class="w"> </span><span class="kt">obj</span><span class="o">)</span>
<span class="o">(</span><span class="s">&quot;Hello&quot;</span><span class="w"> </span><span class="o">:&gt;</span><span class="w"> </span><span class="kt">obj</span><span class="o">)</span>
<span class="o">([</span><span class="mi">1</span><span class="o">;</span><span class="mi">2</span><span class="o">;</span><span class="mi">3</span><span class="o">]</span><span class="w"> </span><span class="o">:&gt;</span><span class="w"> </span><span class="n">seq</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;).</span><span class="n">GetEnumerator</span><span class="bp">()</span>
<span class="o">(</span><span class="k">upcast</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">obj</span><span class="o">)</span>
</code></pre></div>
<p>The initial type of the overall expression is <code>ty</code>. Expression <code>expr</code> is checked using a fresh initial type
<code>tye</code>, with constraint <code>tye :&gt; ty</code>. Static coercions are a primitive elaborated form.</p>
<h3 id="673-dynamic-type-test-expressions">6.7.3 Dynamic Type-Test Expressions</h3>
<p>A dynamic type-test expression has the following form:</p>
<div class="highlight"><pre><span></span><code>expr :? ty
</code></pre></div>
<p>For example:</p>
<div class="highlight"><pre><span></span><code><span class="o">((</span><span class="mi">1</span><span class="w"> </span><span class="o">:&gt;</span><span class="w"> </span><span class="kt">obj</span><span class="o">)</span><span class="w"> </span><span class="o">:?</span><span class="w"> </span><span class="n">int</span><span class="o">)</span>
<span class="o">((</span><span class="mi">1</span><span class="w"> </span><span class="o">:&gt;</span><span class="w"> </span><span class="kt">obj</span><span class="o">)</span><span class="w"> </span><span class="o">:?</span><span class="w"> </span><span class="kt">string</span><span class="o">)</span>
</code></pre></div>
<p>The initial type of the overall expression is <code>bool</code>. Expression <code>expr</code> is checked using a fresh initial type
<code>tye</code>. After checking:</p>
<ul>
<li>The type <code>tye</code> must not be a variable type.</li>
<li>A warning is given if the type test will always be true and therefore is unnecessary.</li>
<li>The type <code>tye</code> must not be sealed.</li>
<li>If type <code>ty</code> is sealed, or if <code>ty</code> is a variable type, or if type <code>tye</code> is not an interface type, then <code>ty :&gt; tye</code>
    is asserted.</li>
</ul>
<p>Dynamic type tests are a primitive elaborated form.</p>
<h3 id="674-dynamic-coercion-expressions">6.7.4 Dynamic Coercion Expressions</h3>
<p>A dynamic coercion expression has the following form:</p>
<div class="highlight"><pre><span></span><code>expr :?&gt; ty
</code></pre></div>
<p>The expression downcast <code>e1</code> is equivalent to <code>expr :?&gt; _</code> , so the target type is the same as the initial
type of the overall expression. For example:</p>
<div class="highlight"><pre><span></span><code><span class="k">let</span><span class="w"> </span><span class="nv">obj1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">(</span><span class="mi">1</span><span class="w"> </span><span class="o">:&gt;</span><span class="w"> </span><span class="kt">obj</span><span class="o">)</span>
<span class="o">(</span><span class="n">obj1</span><span class="w"> </span><span class="o">:?&gt;</span><span class="w"> </span><span class="n">int</span><span class="o">)</span>
<span class="o">(</span><span class="n">obj1</span><span class="w"> </span><span class="o">:?&gt;</span><span class="w"> </span><span class="kt">string</span><span class="o">)</span>
<span class="o">(</span><span class="k">downcast</span><span class="w"> </span><span class="n">obj1</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">int</span><span class="o">)</span>
</code></pre></div>
<p>The initial type of the overall expression is <code>ty</code>. Expression <code>expr</code> is checked using a fresh initial type
<code>tye</code>. After these checks:</p>
<ul>
<li>The type <code>tye</code> must not be a variable type.</li>
<li>A warning is given if the type test will always be true and therefore is unnecessary.</li>
<li>The type <code>tye</code> must not be sealed.</li>
<li>If type <code>ty</code> is sealed, or if <code>ty</code> is a variable type, or if type <code>tye</code> is not an interface type, then <code>ty :&gt; tye</code>
    is asserted.</li>
</ul>
<p>Dynamic coercions are a primitive elaborated form.</p>
<h2 id="68-quoted-expressions">6.8 Quoted Expressions</h2>
<p>An expression in one of these forms is a quoted expression:</p>
<div class="highlight"><pre><span></span><code>&lt;@ expr @&gt;

&lt;@@ expr @@&gt;
</code></pre></div>
<p>The former is a <em>strongly typed quoted expression</em> , and the latter is a <em>weakly typed quoted expression</em>.
In both cases, the expression forms capture the enclosed expression in the form of a typed abstract
syntax tree.</p>
<p>The exact nodes that appear in the expression tree are determined by the elaborated form of <code>expr</code>
that type checking produces.</p>
<p>For details about the nodes that may be encountered, see the documentation for the
<code>FSharp.Quotations.Expr</code> type in the F# core library. In particular, quotations may contain:</p>
<ul>
<li>
<p>References to module-bound functions and values, and to type-bound members. For example:</p>
<div class="highlight"><pre><span></span><code><span class="k">let</span><span class="w"> </span><span class="nv">id</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span>
<span class="k">let</span><span class="w"> </span><span class="nv">f</span><span class="w"> </span><span class="o">(</span><span class="n">x</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">int</span><span class="o">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&lt;@</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">@&gt;</span>
</code></pre></div>
<p>In this case the value appears in the expression tree as a node of kind
<code>FSharp.Quotations.Expr.Call</code>.</p>
</li>
<li>
<p>A type, module, function, value, or member that is annotated with the <code>ReflectedDefinition</code>
    attribute. If so, the expression tree that forms its definition may be retrieved dynamically using
    the <code>FSharp.Quotations.Expr.TryGetReflectedDefinition</code>.</p>
<p>If the <code>ReflectedDefinition</code> attribute is applied to a type or module, it will be recursively applied
to all members, too.</p>
</li>
<li>
<p>References to defined values, such as the following:</p>
<div class="highlight"><pre><span></span><code><span class="k">let</span><span class="w"> </span><span class="nv">f</span><span class="w"> </span><span class="o">(</span><span class="n">x</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">int</span><span class="o">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&lt;@</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">@&gt;</span>
</code></pre></div>
<p>Such a value appears in the expression tree as a node of kind FSharp.Quotations.Expr.Value.</p>
</li>
<li>
<p>References to generic type parameters or uses of constructs whose type involves a generic
    parameter, such as the following:</p>
<div class="highlight"><pre><span></span><code><span class="k">let</span><span class="w"> </span><span class="nv">f</span><span class="w"> </span><span class="o">(</span><span class="n">x</span><span class="o">:</span><span class="k">&#39;</span><span class="n">T</span><span class="o">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&lt;@</span><span class="w"> </span><span class="o">(</span><span class="n">x</span><span class="o">,</span><span class="w"> </span><span class="n">x</span><span class="o">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">&#39;</span><span class="n">T</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">&#39;</span><span class="n">T</span><span class="w"> </span><span class="o">@&gt;</span>
</code></pre></div>
<p>In this case, the actual value of the type parameter is implicitly substituted throughout the type
annotations and types in the generated expression tree.</p>
</li>
</ul>
<p>As of F# 3. 1 , the following limitations apply to quoted expressions:</p>
<ul>
<li>Quotations may not use object expressions.</li>
<li>Quotations may not define expression-bound functions that are themselves inferred to be
    generic. Instead, expression-bound functions should either include type annotations to refer to a
    specific type or should be written by using module-bound functions or class-bound members.</li>
</ul>
<h3 id="681-strongly-typed-quoted-expressions">6.8.1 Strongly Typed Quoted Expressions</h3>
<p>A strongly typed quoted expression has the following form:</p>
<div class="highlight"><pre><span></span><code>&lt;@ expr @&gt;
</code></pre></div>
<p>For example:</p>
<div class="highlight"><pre><span></span><code><span class="o">&lt;@</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">@&gt;</span>

<span class="o">&lt;@</span><span class="w"> </span><span class="o">(</span><span class="k">fun</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="o">)</span><span class="w"> </span><span class="o">@&gt;</span>
</code></pre></div>
<p>In the first example, the type of the expression is <code>FSharp.Quotations.Expr&lt;int&gt;</code>. In the second
example, the type of the expression is <code>FSharp.Quotations.Expr&lt;int -&gt; int&gt;</code>.</p>
<p>When checked, the initial type of a strongly typed quoted expression <code>&lt;@ expr @&gt;</code> is asserted to be of
the form <code>FSharp.Quotations.Expr&lt;ty&gt;</code> for a fresh type <code>ty</code>. The expression <code>expr</code> is checked with initial
type <code>ty</code>.</p>
<h3 id="682-weakly-typed-quoted-expressions">6.8.2 Weakly Typed Quoted Expressions</h3>
<p>A <em>weakly typed quoted expression</em> has the following form:</p>
<div class="highlight"><pre><span></span><code>&lt;@@ expr @@&gt;
</code></pre></div>
<p>Weakly typed quoted expressions are similar to strongly quoted expressions but omit any type
annotation. For example:</p>
<div class="highlight"><pre><span></span><code><span class="o">&lt;@@</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">@@&gt;</span>

<span class="o">&lt;@@</span><span class="w"> </span><span class="o">(</span><span class="k">fun</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="o">)</span><span class="w"> </span><span class="o">@@&gt;</span>
</code></pre></div>
<p>In both these examples, the type of the expression is <code>FSharp.Quotations.Expr</code>.</p>
<p>When checked, the initial type of a weakly typed quoted expression <code>&lt;@@ expr @@&gt;</code> is asserted to be
of the form <code>FSharp.Quotations.Expr</code>. The expression <code>expr</code> is checked with fresh initial type <code>ty</code>.</p>
<h3 id="683-expression-splices">6.8.3 Expression Splices</h3>
<p>Both strongly typed and weakly typed quotations may contain expression splices in the following
forms:</p>
<div class="highlight"><pre><span></span><code>%expr
%%expr
</code></pre></div>
<p>These are respectively strongly typed and weakly typed splicing operators.</p>
<h4 id="6831-strongly-typed-expression-splices">6.8.3.1 Strongly Typed Expression Splices</h4>
<p>An expression of the following form is a <em>strongly typed expression splice</em> :</p>
<div class="highlight"><pre><span></span><code>%expr
</code></pre></div>
<p>For example, given</p>
<div class="highlight"><pre><span></span><code><span class="k">open</span><span class="w"> </span><span class="nn">FSharp.Quotations</span>
<span class="k">let</span><span class="w"> </span><span class="nv">f1</span><span class="w"> </span><span class="o">(</span><span class="n">v</span><span class="o">:</span><span class="n">Expr</span><span class="o">&lt;</span><span class="n">int</span><span class="o">&gt;)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&lt;@</span><span class="w"> </span><span class="o">%</span><span class="n">v</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">@&gt;</span>
<span class="k">let</span><span class="w"> </span><span class="nv">expr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">f1</span><span class="w"> </span><span class="o">&lt;@</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">@&gt;</span>
</code></pre></div>
<p>the identifier <code>expr</code> evaluates to the same expression tree as <code>&lt;@ 3 + 1 @&gt;</code>. The expression tree
for <code>&lt;@ 3 @&gt;</code> replaces the splice in the corresponding expression tree node.</p>
<p>A strongly typed expression splice may appear only in a quotation. Assuming that the splice
expression <code>%expr</code> is checked with initial type <code>ty</code> , the expression <code>expr</code> is checked with initial type
<code>FSharp.Quotations.Expr&lt;ty&gt;</code>.</p>
<blockquote>
<p>Note: The rules in this section apply to any use of the prefix operator
<code>FSharp.Core.ExtraTopLevelOperators.(~%)</code>. Uses of this operator must be applied to an
argument and may only appear in quoted expressions.</p>
</blockquote>
<p><strong>6.8.3.2 Weakly Typed Expression Splices</strong>
An expression of the following form is a <em>weakly typed expression splice</em> :</p>
<div class="highlight"><pre><span></span><code>%%expr
</code></pre></div>
<p>For example, given</p>
<div class="highlight"><pre><span></span><code><span class="k">open</span><span class="w"> </span><span class="nn">FSharp.Quotations</span>
<span class="k">let</span><span class="w"> </span><span class="nv">f1</span><span class="w"> </span><span class="o">(</span><span class="n">v</span><span class="o">:</span><span class="n">Expr</span><span class="o">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&lt;@</span><span class="w"> </span><span class="o">%%</span><span class="n">v</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">@&gt;</span>
<span class="k">let</span><span class="w"> </span><span class="nv">tree</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">f1</span><span class="w"> </span><span class="o">&lt;@@</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">@@&gt;</span>
</code></pre></div>
<p>the identifier <code>tree</code> evaluates to the same expression tree as <code>&lt;@ 3 + 1 @&gt;</code>. The expression tree
replaces the splice in the corresponding expression tree node.</p>
<p>A weakly typed expression splice may appear only in a quotation. Assuming that the splice
expression <code>%%expr</code> is checked with initial type <code>ty</code>, then the expression <code>expr</code> is checked with initial type
<code>FSharp.Quotations.Expr</code>. No additional constraint is placed on <code>ty</code>.</p>
<p>Additional type annotations are often required for successful use of this operator.</p>
<blockquote>
<p>Note: The rules in this section apply to any use of the prefix operator
<code>FSharp.Core.ExtraTopLevelOperators.(~%%)</code>, which is defined in the F# core library. Uses
of this operator must be applied to an argument and may only occur in quoted
expressions.</p>
</blockquote>
<h2 id="69-evaluation-of-elaborated-forms">6.9 Evaluation of Elaborated Forms</h2>
<p>At runtime, execution evaluates expressions to values. The evaluation semantics of each expression
form are specified in the subsections that follow.</p>
<h3 id="691-values-and-execution-context">6.9.1 Values and Execution Context</h3>
<p>The execution of elaborated F# expressions results in values. Values include:</p>
<ul>
<li>Primitive constant values</li>
<li>The special value <code>null</code></li>
<li>References to object values in the global heap of object values</li>
<li>Values for value types, containing a value for each field in the value type</li>
<li>Pointers to mutable locations (including static mutable locations, mutable fields and array
    elements)</li>
</ul>
<p>Evaluation assumes the following evaluation context:</p>
<ul>
<li>A global heap of object values. Each object value contains:</li>
<li>A runtime type and dispatch map</li>
<li>A set of fields with associated values</li>
<li>For array objects, an array of values in index order</li>
<li>For function objects, an expression which is the body of the function</li>
<li>An optional <em>union case label</em> , which is an identifier</li>
<li>A closure environment that assigns values to all variables that are referenced in the method
       bodies that are associated with the object</li>
<li>A global environment that maps runtime-type/name pairs to values.Each name identifies a static
    field in a type definition or a value in a module.</li>
<li>A local environment mapping names of variables to values.</li>
<li>A local stack of active exception handlers, made up of a stack of try/with and try/finally handlers.</li>
</ul>
<p>Evaluation may also raise an exception. In this case, the stack of active exception handlers is
processed until the exception is handled, in which case additional expressions may be executed (for</p>
<p>try/finally handlers), or an alternative expression may be evaluated (for try/with handlers), as
described below.</p>
<h3 id="692-parallel-execution-and-memory-model">6.9.2 Parallel Execution and Memory Model</h3>
<p>In a concurrent environment, evaluation may involve both multiple active computations (multiple
concurrent and parallel threads of execution) and multiple pending computations (pending
callbacks, such as those activated in response to an I/O event).</p>
<p>If multiple active computations concurrently access mutable locations in the global environment or
heap, the atomicity, read, and write guarantees of the underlying CLI implementation apply. The
guarantees are related to the logical sizes and characteristics of values, which in turn depend on
their type:</p>
<ul>
<li>F# reference types are guaranteed to map to CLI reference types. In the CLI memory model,
    reference types have atomic reads and writes.</li>
<li>F# value types map to a corresponding CLI value type that has corresponding fields. Reads and
    writes of sizes less than or equal to one machine word are atomic.</li>
</ul>
<p>The <code>VolatileField</code> attribute marks a mutable location as volatile in the compiled form of the code.</p>
<p>Ordering of reads and writes from mutable locations may be adjusted according to the limitations
specified by the CLI memory model. The following example shows situations in which changes to
read and write order can occur, with annotations about the order of reads:</p>
<div class="highlight"><pre><span></span><code><span class="k">type</span><span class="w"> </span><span class="nc">ClassContainingMutableData</span><span class="bp">()</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="k">let</span><span class="w"> </span><span class="nv">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="mi">2</span><span class="o">)</span>
<span class="w">    </span><span class="k">let</span><span class="w"> </span><span class="nv">mutable</span><span class="w"> </span><span class="n">mutableValue</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="mi">2</span><span class="o">)</span>

<span class="w">    </span><span class="o">[&lt;</span><span class="n">VolatileField</span><span class="o">&gt;]</span>
<span class="w">    </span><span class="k">let</span><span class="w"> </span><span class="nv">mutable</span><span class="w"> </span><span class="n">volatileMutableValue</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="mi">2</span><span class="o">)</span>

<span class="w">    </span><span class="k">member</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="nf">ReadValues</span><span class="bp">()</span><span class="w"> </span><span class="o">=</span>
<span class="w">        </span><span class="c1">// Two reads on an immutable value</span>
<span class="w">        </span><span class="k">let</span><span class="w"> </span><span class="o">(</span><span class="n">a1</span><span class="o">,</span><span class="w"> </span><span class="n">b1</span><span class="o">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">value</span>

<span class="w">        </span><span class="c1">// One read on mutableValue, which may be duplicated according</span>
<span class="w">        </span><span class="c1">// to ECMA CLI spec.</span>
<span class="w">        </span><span class="k">let</span><span class="w"> </span><span class="o">(</span><span class="n">a2</span><span class="o">,</span><span class="w"> </span><span class="n">b2</span><span class="o">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mutableValue</span>

<span class="w">        </span><span class="c1">// One read on volatileMutableValue, which may not be duplicated.</span>
<span class="w">        </span><span class="k">let</span><span class="w"> </span><span class="o">(</span><span class="n">a3</span><span class="o">,</span><span class="w"> </span><span class="n">b3</span><span class="o">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">volatileMutableValue</span>

<span class="w">        </span><span class="n">a1</span><span class="o">,</span><span class="w"> </span><span class="n">b1</span><span class="o">,</span><span class="w"> </span><span class="n">a2</span><span class="o">,</span><span class="w"> </span><span class="n">b2</span><span class="o">,</span><span class="w"> </span><span class="n">a3</span><span class="o">,</span><span class="w"> </span><span class="n">b3</span>

<span class="w">    </span><span class="k">member</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="nf">WriteValues</span><span class="bp">()</span><span class="w"> </span><span class="o">=</span>
<span class="w">        </span><span class="c1">// One read on mutableValue, which may be duplicated according</span>
<span class="w">        </span><span class="c1">// to ECMA CLI spec.</span>
<span class="w">        </span><span class="k">let</span><span class="w"> </span><span class="o">(</span><span class="n">a2</span><span class="o">,</span><span class="w"> </span><span class="n">b2</span><span class="o">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mutableValue</span>

<span class="w">        </span><span class="c1">// One write on mutableValue.</span>
<span class="w">        </span><span class="n">mutableValue</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="o">(</span><span class="n">a2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="n">b2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="o">)</span>

<span class="w">        </span><span class="c1">// One read on volatileMutableValue, which may not be duplicated.</span>
<span class="w">        </span><span class="k">let</span><span class="w"> </span><span class="o">(</span><span class="n">a3</span><span class="o">,</span><span class="w"> </span><span class="n">b3</span><span class="o">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">volatileMutableValue</span>

<span class="w">        </span><span class="c1">// One write on volatileMutableValue.</span>
<span class="w">        </span><span class="n">volatileMutableValue</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="o">(</span><span class="n">a3</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="n">b3</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="o">)</span>

<span class="k">let</span><span class="w"> </span><span class="nv">obj</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ClassContainingMutableData</span><span class="bp">()</span>
<span class="nn">Async</span><span class="p">.</span><span class="n">Parallel</span><span class="w"> </span><span class="o">[</span><span class="w"> </span><span class="n">async</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="kt">obj</span><span class="o">.</span><span class="n">WriteValues</span><span class="bp">()</span><span class="w"> </span><span class="o">};</span>
<span class="w">                 </span><span class="n">async</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="kt">obj</span><span class="o">.</span><span class="n">WriteValues</span><span class="bp">()</span><span class="w"> </span><span class="o">};</span>
<span class="w">                 </span><span class="n">async</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="kt">obj</span><span class="o">.</span><span class="n">ReadValues</span><span class="bp">()</span><span class="w"> </span><span class="o">};</span>
<span class="w">                 </span><span class="n">async</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="kt">obj</span><span class="o">.</span><span class="n">ReadValues</span><span class="bp">()</span><span class="w"> </span><span class="o">}</span><span class="w"> </span><span class="o">]</span>
</code></pre></div>
<h3 id="693-zero-values">6.9.3 Zero Values</h3>
<p>Some types have a <em>zero value</em>. The zero value is the “default” value for the type in the CLI execution
environment. The following types have the following zero values:</p>
<ul>
<li>For reference types, the <code>null</code> value.</li>
<li>For value types, the value with all fields set to the zero value for the type of the field. The zero
    value is also computed by the F# library function <code>Unchecked.defaultof&lt;ty&gt;</code>.</li>
</ul>
<h3 id="694-taking-the-address-of-an-elaborated-expression">6.9.4 Taking the Address of an Elaborated Expression</h3>
<p>When the F# compiler determines the elaborated forms of certain expressions, it must compute a
“reference” to an elaborated expression <code>expr</code> , written <code>AddressOf(expr, mutation)</code>. The <code>AddressOf</code>
operation is used internally within this specification to indicate the elaborated forms of address-of
expressions, assignment expressions, and method and property calls on objects of variable and value
types.</p>
<p>The <code>AddressOf</code> operation is computed as follows:</p>
<ul>
<li>If <code>expr</code> has form <code>path</code> where <code>path</code> is a reference to a value with type <code>byref&lt;ty&gt;</code>, the elaborated
    form is <code>&amp;path</code>.</li>
<li>If <code>expr</code> has form <code>expra.field</code> where <code>field</code> is a mutable, non-readonly CLI field, the elaborated
    form is <code>&amp;(AddressOf(expra).field)</code>.</li>
<li>If <code>expr</code> has form expra.[exprb] where the operation is an array lookup, the elaborated form is
    <code>&amp;(AddressOf(expra).[exprb])</code>.</li>
<li>If <code>expr</code> has any other form, the elaborated form is <code>&amp;v</code> ,where <code>v</code> is a fresh mutable local value that
    is initialized by adding <code>let v = expr</code> to the overall elaborated form for the entire assignment
    expression. This initialization is known as a <em>defensive copy</em> of an immutable value. If <code>expr</code> is a
    struct, <code>expr</code> is copied each time the <code>AddressOf</code> operation is applied, which results in a different
    address each time. To keep the struct in place, the field that contains it should be marked as
    mutable.</li>
</ul>
<p>The <code>AddressOf</code> operation is computed with respect to <code>mutation</code>, which indicates whether the
relevant elaborated form uses the resulting pointer to change the contents of memory. This
assumption changes the errors and warnings reported.</p>
<ul>
<li>If <code>mutation</code> is <code>DefinitelyMutates</code>, then an error is given if a defensive copy must be created.</li>
<li>If <code>mutation</code> is <code>PossiblyMutates</code>, then a warning is given if a defensive copy arises.</li>
</ul>
<p>An F# compiler can optionally upgrade <code>PossiblyMutates</code> to <code>DefinitelyMutates</code> for calls to property
setters and methods named <code>MoveNext</code> and <code>GetNextArg</code>, which are the most common cases of struct-
mutators in CLI library design. This is done by the F# compiler.</p>
<blockquote>
<p>Note:In F#, the warning “copy due to possible mutation of value type” is a level 4
  warning and is not reported when using the default settings of the F# compiler. This is
  because the majority of value types in CLI libraries are immutable. This is warning
  number 52 in the F# implementation.
  <br> CLI libraries do not include metadata to indicate whether a particular value type is
  immutable. Unless a value is held in arrays or locations marked mutable, or a value type
  is known to be immutable to the F# compiler, F# inserts copies to ensure that
  inadvertent mutation does not occur.</p>
</blockquote>
<h3 id="695-evaluating-value-references">6.9.5 Evaluating Value References</h3>
<p>At runtime, an elaborated value reference <code>v</code> is evaluated by looking up the value of <code>v</code> in the local
environment.</p>
<h3 id="696-evaluating-function-applications">6.9.6 Evaluating Function Applications</h3>
<p>At runtime, an elaborated application of a function <code>f e1 ... en</code> is evaluated as follows:</p>
<ul>
<li>The expressions <code>f</code> and <code>e1 ... en</code>, are evaluated.</li>
<li>If <code>f</code> evaluates to a function value with closure environment <code>E</code>, arguments <code>v1 ... vm</code>, and body <code>expr</code>,
    where <code>m &lt;= n</code> , then <code>E</code> is extended by mapping <code>v1 ... vm</code> to the argument values for <code>e1 ... em</code>. The
    expression <code>expr</code> is then evaluated in this extended environment and any remaining arguments
    applied.</li>
<li>If <code>f</code> evaluates to a function value with more than <code>n</code> arguments, then a new function value is
    returned with an extended closure mapping <code>n</code> additional formal argument names to the
    argument values for <code>e1 ... em</code>.</li>
</ul>
<p>The result of calling the <code>obj.GetType()</code> method on the resulting object is under-specified (see
<a href="./#6924-values-with-underspecified-object-identity-and-type-identity">§6.9.24</a>).</p>
<h3 id="697-evaluating-method-applications">6.9.7 Evaluating Method Applications</h3>
<p>At runtime an elaborated application of a method is evaluated as follows:</p>
<ul>
<li>The elaborated form is <code>e0.M(e1 , ..., en)</code> for an instance method or <code>M(e, ..., en)</code> for a static method.</li>
<li>The (optional) <code>e0</code> and <code>e1</code> ,..., <em>en</em> are evaluated in order.</li>
<li>If <code>e0</code> evaluates to <code>null</code>, a <code>NullReferenceException</code> is raised.</li>
<li>If the method is declared <code>abstract</code> — that is, if it is a virtual dispatch slot — then the body of the
    member is chosen according to the dispatch maps of the value of <code>e0</code> (<a href="../inference-procedures/#148-dispatch-slot-checking">§14.8</a>).</li>
<li>The formal parameters of the method are mapped to corresponding argument values. The body
    of the method member is evaluated in the resulting environment.</li>
</ul>
<h3 id="698-evaluating-union-cases">6.9.8 Evaluating Union Cases</h3>
<p>At runtime, an elaborated use of a union case <code>Case(e1 , ..., en)</code> for a union type <code>ty</code> is evaluated as
follows:</p>
<ul>
<li>The expressions <code>e1, ..., en</code> are evaluated in order.</li>
<li>The result of evaluation is an object value with union case label <code>Case</code> and fields given by the
    values of <code>e1 , ..., en</code>.</li>
<li>If the type <code>ty</code> uses null as a representation (<a href="../types-and-type-constraints/#548-nullness">§5.4.8</a>) and <code>Case</code> is the single union case without
    arguments, the generated value is <code>null</code>.</li>
<li>The runtime type of the object is either <code>ty</code> or an internally generated type that is compatible
    with <code>ty</code>.</li>
</ul>
<h3 id="699-evaluating-field-lookups">6.9.9 Evaluating Field Lookups</h3>
<p>At runtime, an elaborated lookup of a CLI or F# fields is evaluated as follows:</p>
<ul>
<li>The elaborated form is <code>expr.F</code> for an instance field or <code>F</code> for a static field.</li>
<li>The (optional) <code>expr</code> is evaluated.</li>
<li>If <code>expr</code> evaluates to <code>null</code>, a <code>NullReferenceException</code> is raised.</li>
<li>The value of the field is read from either the global field table or the local field table associated
    with the object.</li>
</ul>
<h3 id="6910-evaluating-array-expressions">6.9.10 Evaluating Array Expressions</h3>
<p>At runtime, an elaborated array expression <code>[| e1; ...; en |]ty</code> is evaluated as follows:</p>
<ul>
<li>Each expression <code>e1 ... en</code> is evaluated in order.</li>
<li>The result of evaluation is a new array of runtime type <code>ty[]</code> that contains the resulting values in
    order.</li>
</ul>
<h3 id="6911-evaluating-record-expressions">6.9.11 Evaluating Record Expressions</h3>
<p>At runtime, an elaborated record construction <code>{ field1 = e1; ... ; fieldn = en }ty</code> is evaluated as
follows:</p>
<ul>
<li>Each expression <code>e1 ... en</code> is evaluated in order.</li>
<li>The result of evaluation is an object of type <code>ty</code> with the given field values</li>
</ul>
<h3 id="6912-evaluating-function-expressions">6.9.12 Evaluating Function Expressions</h3>
<p>At runtime, an elaborated function expression <code>(fun v1 ... vn -&gt; expr)</code> is evaluated as follows:</p>
<ul>
<li>The expression evaluates to a function object with a closure that assigns values to all variables
    that are referenced in <code>expr</code> and a function body that is <code>expr</code>.</li>
<li>The values in the closure are the current values of those variables in the execution environment.</li>
<li>The result of calling the <code>obj.GetType()</code> method on the resulting object is under-specified (see
    <a href="./#6924-values-with-underspecified-object-identity-and-type-identity">§6.9.24</a>).</li>
</ul>
<h3 id="6913-evaluating-object-expressions">6.9.13 Evaluating Object Expressions</h3>
<p>At runtime, elaborated object expressions</p>
<div class="highlight"><pre><span></span><code>{ new ty0 args-expr? object-members
      interface ty1 object-members1
      interface tyn object-membersn }
</code></pre></div>
<p>is evaluated as follows:</p>
<ul>
<li>The expression evaluates to an object whose runtime type is compatible with all of the <code>tyi</code> and
    which has the corresponding dispatch map (<a href="../inference-procedures/#148-dispatch-slot-checking">§14.8</a>). If present, the base construction expression
    <code>ty0 (args-expr)</code> is executed as the first step in the construction of the object.</li>
<li>The object is given a closure that assigns values to all variables that are referenced in <code>expr</code>.</li>
<li>The values in the closure are the current values of those variables in the execution environment.</li>
</ul>
<p>The result of calling the <code>obj.GetType()</code> method on the resulting object is under-specified (see
<a href="./#6924-values-with-underspecified-object-identity-and-type-identity">§6.9.24</a>).</p>
<h3 id="6914-evaluating-definition-expressions">6.9.14 Evaluating Definition Expressions</h3>
<p>At runtime, each elaborated definition <code>pat = expr</code> is evaluated as follows:</p>
<ul>
<li>The expression <code>expr</code> is evaluated.</li>
<li>The expression is then matched against <code>pat</code> to produce a value for each variable pattern (<a href="../patterns/#72-named-patterns">§7.2</a>)
    in <code>pat</code>.</li>
<li>These mappings are added to the local environment.</li>
</ul>
<h3 id="6915-evaluating-integer-for-loops">6.9.15 Evaluating Integer For Loops</h3>
<p>At runtime, an integer for loop <code>for var = expr1 to expr2 do expr3 done</code> is evaluated as follows:</p>
<ul>
<li>Expressions <code>expr1</code> and <code>expr2</code> are evaluated once to values <code>v1</code> and <code>v2</code>.</li>
<li>The expression <code>expr3</code> is evaluated repeatedly with the variable <code>var</code> assigned successive values in
    the range of <code>v1</code> up to <code>v2</code>.</li>
<li>If <code>v1</code> is greater than <code>v2</code> , then <code>expr3</code> is never evaluated.</li>
</ul>
<h3 id="6916-evaluating-while-loops">6.9.16 Evaluating While Loops</h3>
<p>As runtime, while-loops <code>while expr1 do expr2 done</code> are evaluated as follows:</p>
<ul>
<li>Expression <code>expr1</code> is evaluated to a value <code>v1</code>.</li>
<li>If <code>v1</code> is true, expression <code>expr2</code> is evaluated, and the expression <code>while expr1 do expr2 done</code> is
    evaluated again.</li>
<li>If <code>v1</code> is <code>false</code>, the loop terminates and the resulting value is <code>null</code> (the representation of the only
    value of type <code>unit</code>)</li>
</ul>
<h3 id="6917-evaluating-static-coercion-expressions">6.9.17 Evaluating Static Coercion Expressions</h3>
<p>At runtime, elaborated static coercion expressions of the form <code>expr :&gt; ty</code> are evaluated as follows:</p>
<ul>
<li>Expression <code>expr</code> is evaluated to a value <code>v</code>.</li>
<li>If the static type of <code>e</code> is a value type, and <code>ty</code> is a reference type, <code>v</code> is <em>boxed</em> ; that is, <code>v</code> is converted
    to an object on the heap with the same field assignments as the original value. The expression
    evaluates to a reference to this object.</li>
<li>Otherwise, the expression evaluates to <code>v</code>.</li>
</ul>
<h3 id="6918-evaluating-dynamic-type-test-expressions">6.9.18 Evaluating Dynamic Type-Test Expressions</h3>
<p>At runtime, elaborated dynamic type test expressions <code>expr :? ty</code> are evaluated as follows:</p>
<ol>
<li>Expression <code>expr</code> is evaluated to a value <code>v</code>.</li>
<li>If <code>v</code> is <code>null</code>, then:<ul>
<li>If <code>tye</code> uses <code>null</code> as a representation (<a href="../types-and-type-constraints/#548-nullness">§5.4.8</a>), the result is <code>true</code>.</li>
<li>Otherwise the expression evaluates to <code>false</code>.</li>
</ul>
</li>
<li>If <code>v</code> is not <code>null</code> and has runtime type <code>vty</code> which dynamically converts to <code>ty</code> (<a href="../types-and-type-constraints/#5410-dynamic-conversion-between-types">§5.4.10</a>), the
    expression evaluates to <code>true</code>. However, if <code>ty</code> is an enumeration type, the expression evaluates to
    <code>true</code> if and only if <code>ty</code> is precisely <code>vty</code>.</li>
</ol>
<h3 id="6919-evaluating-dynamic-coercion-expressions">6.9.19 Evaluating Dynamic Coercion Expressions</h3>
<p>At runtime, elaborated dynamic coercion expressions <code>expr :?&gt; ty</code> are evaluated as follows:</p>
<ol>
<li>Expression <code>expr</code> is evaluated to a value <code>v</code>.</li>
<li>If <code>v</code> is <code>null</code>:<ul>
<li>If <code>tye</code> uses <code>null</code> as a representation (<a href="../types-and-type-constraints/#548-nullness">§5.4.8</a>), the result is the <code>null</code> value.</li>
<li>Otherwise a <code>NullReferenceException</code> is raised.</li>
</ul>
</li>
<li>If <code>v</code> is not <code>null</code>:<ul>
<li>If <code>v</code> has dynamic type <code>vty</code> which <em>dynamically converts</em> to <code>ty</code> (<a href="../types-and-type-constraints/#5410-dynamic-conversion-between-types">§5.4.10</a>), the expression evaluates to the dynamic conversion of <code>v</code> to <code>ty</code>.<ul>
<li>If <code>vty</code> is a reference type and <code>ty</code> is a value type, then <code>v</code> is <em>unboxed</em> ; that is, <code>v</code> is
     converted from an object on the heap to a struct value with the same field
     assignments as the object. The expression evaluates to this value.</li>
<li>Otherwise, the expression evaluates to <code>v</code>.</li>
</ul>
</li>
<li>Otherwise an <code>InvalidCastException</code> is raised.</li>
</ul>
</li>
</ol>
<p>Expressions of the form <code>expr :?&gt; ty</code> evaluate in the same way as the F# library function
<code>unbox&lt;ty&gt;(expr)</code>.</p>
<blockquote>
<p>Note: Some F# types — most notably the <code>option&lt;_&gt;</code> type — use <code>null</code> as a representation
    for efficiency reasons (<a href="../types-and-type-constraints/#548-nullness">§5.4.8</a>). For these  types, boxing and unboxing can lose type
    distinctions. For example, contrast the following two examples:</p>
</blockquote>
<pre><code>```fsother
&gt; (box([]:string list) :?&gt; int list);;
System.InvalidCastException...
&gt; (box(None:string option) :?&gt; int option);;
val it : int option = None
```
</code></pre>
<blockquote>
<p>In the first case, the conversion from an empty list of strings to an empty list of integers
    (after first boxing) fails. In the second case, the conversion from a string option to an
    integer option (after first boxing) succeeds.</p>
</blockquote>
<h3 id="6920-evaluating-sequential-execution-expressions">6.9.20 Evaluating Sequential Execution Expressions</h3>
<p>At runtime, elaborated sequential expressions <code>expr1 ; expr2</code> are evaluated as follows:</p>
<ul>
<li>The expression <code>expr1</code> is evaluated for its side effects and the result is discarded.</li>
<li>The expression <code>expr2</code> is evaluated to a value <code>v2</code> and the result of the overall expression is <code>v2</code>.</li>
</ul>
<h3 id="6921-evaluating-try-with-expressions">6.9.21 Evaluating Try-with Expressions</h3>
<p>At runtime, elaborated try-with expressions try <code>expr1 with rules</code> are evaluated as follows:</p>
<ul>
<li>The expression <code>expr1</code> is evaluated to a value <code>v1</code>.</li>
<li>If no exception occurs, the result is the value <code>v1</code>.</li>
<li>If an exception occurs, the pattern rules are executed against the resulting exception value.</li>
<li>If no rule matches, the exception is reraised.</li>
<li>If a rule <code>pat -&gt; expr2</code> matches, the mapping <code>pat = v1</code> is added to the local environment,
       and <code>expr2</code> is evaluated.</li>
</ul>
<h3 id="6922-evaluating-try-finally-expressions">6.9.22 Evaluating Try-finally Expressions</h3>
<p>At runtime, elaborated try-finally expressions try <code>expr1 finally expr2</code> are evaluated as follows:</p>
<ul>
<li>The expression <code>expr1</code> is evaluated.</li>
<li>If the result of this evaluation is a value <code>v</code> , then <code>expr2</code> is evaluated.
       1) If this evaluation results in an exception, then the overall result is that exception.
       2) If this evaluation does not result in an exception, then the overall result is <code>v</code>.</li>
<li>If the result of this evaluation is an exception, then <code>expr2</code> is evaluated.
       3) If this evaluation results in an exception, then the overall result is that exception.
       4) If this evaluation does not result in an exception, then the original exception is re-
          raised.</li>
</ul>
<h3 id="6923-evaluating-addressof-expressions">6.9.23 Evaluating AddressOf Expressions</h3>
<p>At runtime, an elaborated address-of expression is evaluated as follows. First, the expression has
one of the following forms:</p>
<ul>
<li><code>&amp;path</code> where <code>path</code> is a static field.</li>
<li><code>&amp;(expr.field)</code></li>
<li><code>&amp;(expra.[exprb])</code></li>
<li><code>&amp;v</code> where <code>v</code> is a local mutable value.</li>
</ul>
<p>The expression evaluates to the address of the referenced local mutable value, mutable field, or
mutable static field.</p>
<blockquote>
<p>Note: The underlying CIL execution machinery that F# uses supports covariant arrays, as
evidenced by the fact that the type <code>string[]</code> dynamically converts to <code>obj[]</code> (§5.4.10).
Although this feature is rarely used in F#, its existence means that array assignments and
taking the address of array elements may fail at runtime with a
<code>System.ArrayTypeMismatchException</code> if the runtime type of the target array does not
match the runtime type of the element being assigned. For example, the following code
fails at runtime:</p>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">let</span><span class="w"> </span><span class="nv">f</span><span class="w"> </span><span class="o">(</span><span class="n">x</span><span class="o">:</span><span class="w"> </span><span class="n">byref</span><span class="o">&lt;</span><span class="kt">obj</span><span class="o">&gt;)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">()</span>

<span class="k">let</span><span class="w"> </span><span class="nv">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nn">Array</span><span class="p">.</span><span class="n">zeroCreate</span><span class="o">&lt;</span><span class="kt">obj</span><span class="o">&gt;</span><span class="w"> </span><span class="mi">10</span>
<span class="k">let</span><span class="w"> </span><span class="nv">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nn">Array</span><span class="p">.</span><span class="n">zeroCreate</span><span class="o">&lt;</span><span class="kt">string</span><span class="o">&gt;</span><span class="w"> </span><span class="mi">10</span>
<span class="n">f</span><span class="w"> </span><span class="o">(&amp;</span><span class="n">a</span><span class="o">.[</span><span class="mi">0</span><span class="o">])</span>
<span class="k">let</span><span class="w"> </span><span class="nv">bb</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">((</span><span class="n">b</span><span class="w"> </span><span class="o">:&gt;</span><span class="w"> </span><span class="kt">obj</span><span class="o">)</span><span class="w"> </span><span class="o">:?&gt;</span><span class="w"> </span><span class="kt">obj</span><span class="bp">[]</span><span class="o">)</span>
<span class="c1">// The next line raises a System.ArrayTypeMismatchException exception.</span>
<span class="n">F</span><span class="w"> </span><span class="o">(&amp;</span><span class="n">bb</span><span class="o">.[</span><span class="mi">1</span><span class="o">])</span>
</code></pre></div>
<h3 id="6924-values-with-underspecified-object-identity-and-type-identity">6.9.24 Values with Underspecified Object Identity and Type Identity</h3>
<p>The CLI and F# support operations that detect object identity—that is, whether two object
references refer to the same “physical” object. For example, <code>System.Object.ReferenceEquals(obj1, obj2)</code>
returns true if the two object references refer to the same object. Similarly,
<code>System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode()</code> returns a hash code that is partly
based on physical object identity, and the <code>AddHandler</code> and <code>RemoveHandler</code> operations (which register
and unregister event handlers) are based on the object identity of delegate values.</p>
<p>The results of these operations are underspecified when used with values of the following F# types:</p>
<ul>
<li>Function types</li>
<li>Tuple types</li>
<li>Immutable record types</li>
<li>Union types</li>
<li>Boxed immutable value types</li>
</ul>
<p>For two values of such types, the results of <code>System.Object.ReferenceEquals</code> and
<code>System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode</code> are underspecified; however, the
operations terminate and do not raise exceptions. An implementation of F# is not required to define
the results of these operations for values of these types.</p>
<p>For function values and objects that are returned by object expressions, the results of the following
operations are underspecified in the same way:</p>
<ul>
<li><code>Object.GetHashCode()</code></li>
<li><code>Object.GetType()</code></li>
</ul>
<p>For union types the results of the following operations are underspecified in the same way:</p>
<ul>
<li><code>Object.GetType()</code></li>
</ul>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
    <div class="md-copyright__highlight">
      Copyright © 2005-2025 F# contributors. Made available under the <a href='https://creativecommons.org/licenses/by/4.0/'>Creative Commons CC-by 4.0</a> licence.
    </div>
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    
      
      <script id="__config" type="application/json">{"base": "..", "features": [], "search": "../assets/javascripts/workers/search.973d3a69.min.js", "tags": null, "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}, "version": null}</script>
    
    
      <script src="../assets/javascripts/bundle.f55a23d4.min.js"></script>
      
    
  </body>
</html>